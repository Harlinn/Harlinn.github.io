<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Harlinn.Windows: Harlinn::Common::Core::IO::Path Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Harlinn.Windows<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_path.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Harlinn::Common::Core::IO::Path Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_path_1_1_internal.html">Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a548d13211858a9dbba7c901c0eb4a9e5" id="r_a548d13211858a9dbba7c901c0eb4a9e5"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt;</td></tr>
<tr class="memitem:a548d13211858a9dbba7c901c0eb4a9e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a548d13211858a9dbba7c901c0eb4a9e5">IsDirectorySeparator</a> (CharT c) noexcept</td></tr>
<tr class="separator:a548d13211858a9dbba7c901c0eb4a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2defcc978ff9c9c7a9b0d937b41a4cc7" id="r_a2defcc978ff9c9c7a9b0d937b41a4cc7"><td class="memTemplParams" colspan="2">template&lt;SimpleCharSpanLike SpanT&gt; </td></tr>
<tr class="memitem:a2defcc978ff9c9c7a9b0d937b41a4cc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2defcc978ff9c9c7a9b0d937b41a4cc7">IsDirectorySeparator</a> (const SpanT &amp;str) noexcept</td></tr>
<tr class="separator:a2defcc978ff9c9c7a9b0d937b41a4cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148789b534f913a65a577bf8687c5a58" id="r_a148789b534f913a65a577bf8687c5a58"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt;</td></tr>
<tr class="memitem:a148789b534f913a65a577bf8687c5a58"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a148789b534f913a65a577bf8687c5a58">IsValidDriveChar</a> (CharT value) noexcept</td></tr>
<tr class="separator:a148789b534f913a65a577bf8687c5a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662bf3730191f44018570b062fcbaca0" id="r_a662bf3730191f44018570b062fcbaca0"><td class="memTemplParams" colspan="2">template&lt;SimpleCharSpanLike SpanT&gt; </td></tr>
<tr class="memitem:a662bf3730191f44018570b062fcbaca0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a662bf3730191f44018570b062fcbaca0">IsValidDriveChar</a> (const SpanT &amp;str) noexcept</td></tr>
<tr class="separator:a662bf3730191f44018570b062fcbaca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc7d7f47df1c9e6966e254c25973cff" id="r_a1bc7d7f47df1c9e6966e254c25973cff"><td class="memTemplParams" colspan="2">template&lt;SimpleCharSpanLike SpanT&gt; </td></tr>
<tr class="memitem:a1bc7d7f47df1c9e6966e254c25973cff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1bc7d7f47df1c9e6966e254c25973cff">EndsWithDirectorySeparator</a> (const SpanT &amp;path) noexcept</td></tr>
<tr class="memdesc:a1bc7d7f47df1c9e6966e254c25973cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value that indicates whether the specified path ends in a directory separator.  <br /></td></tr>
<tr class="separator:a1bc7d7f47df1c9e6966e254c25973cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13426da0ccbd008545c48233c19967cd" id="r_a13426da0ccbd008545c48233c19967cd"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, wchar_t&gt; || std::is_same_v&lt;CharT, char&gt;</td></tr>
<tr class="memitem:a13426da0ccbd008545c48233c19967cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13426da0ccbd008545c48233c19967cd">EndsWithDirectorySeparator</a> (const CharT *path) noexcept</td></tr>
<tr class="memdesc:a13426da0ccbd008545c48233c19967cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value that indicates whether the specified path ends in a directory separator.  <br /></td></tr>
<tr class="separator:a13426da0ccbd008545c48233c19967cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bffa3730c9e0483ec988fe2745a09e" id="r_a62bffa3730c9e0483ec988fe2745a09e"><td class="memTemplParams" colspan="2">template&lt;SimpleCharSpanLike StringT&gt; </td></tr>
<tr class="memitem:a62bffa3730c9e0483ec988fe2745a09e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62bffa3730c9e0483ec988fe2745a09e">EndsInDirectorySeparator</a> (const StringT &amp;path) noexcept</td></tr>
<tr class="memdesc:a62bffa3730c9e0483ec988fe2745a09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value that indicates whether the specified path ends in a directory separator.  <br /></td></tr>
<tr class="separator:a62bffa3730c9e0483ec988fe2745a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab896cb76ab8156e5875e0a9ba950287b" id="r_ab896cb76ab8156e5875e0a9ba950287b"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, wchar_t&gt; || std::is_same_v&lt;CharT, char&gt;</td></tr>
<tr class="memitem:ab896cb76ab8156e5875e0a9ba950287b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab896cb76ab8156e5875e0a9ba950287b">EndsInDirectorySeparator</a> (const CharT *path) noexcept</td></tr>
<tr class="memdesc:ab896cb76ab8156e5875e0a9ba950287b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value that indicates whether the specified path ends in a directory separator.  <br /></td></tr>
<tr class="separator:ab896cb76ab8156e5875e0a9ba950287b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243368956d5ef165a7ad0e6eccf2109d" id="r_a243368956d5ef165a7ad0e6eccf2109d"><td class="memTemplParams" colspan="2">template&lt;SimpleCharSpanLike SpanT&gt; </td></tr>
<tr class="memitem:a243368956d5ef165a7ad0e6eccf2109d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a243368956d5ef165a7ad0e6eccf2109d">StartsWithDirectorySeparator</a> (const SpanT &amp;path) noexcept</td></tr>
<tr class="memdesc:a243368956d5ef165a7ad0e6eccf2109d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value that indicates whether the specified path starts with a directory separator.  <br /></td></tr>
<tr class="separator:a243368956d5ef165a7ad0e6eccf2109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8788149a070d28f56f9d21755a55470" id="r_ab8788149a070d28f56f9d21755a55470"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, wchar_t&gt; || std::is_same_v&lt;CharT, char&gt;</td></tr>
<tr class="memitem:ab8788149a070d28f56f9d21755a55470"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8788149a070d28f56f9d21755a55470">StartsWithDirectorySeparator</a> (const CharT *path) noexcept</td></tr>
<tr class="memdesc:ab8788149a070d28f56f9d21755a55470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value that indicates whether the specified path starts with a directory separator.  <br /></td></tr>
<tr class="separator:ab8788149a070d28f56f9d21755a55470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6542c80266c9ed5a9a5b1a390d5f49c" id="r_aa6542c80266c9ed5a9a5b1a390d5f49c"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, SimpleCharSpanLike SpanT&gt; <br />
requires std::is_same_v&lt;typename SpanT::value_type, typename ResultT::value_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT, const typename ResultT::value_type*, typename ResultT::size_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT, typename ResultT::size_type, typename ResultT::value_type&gt; &amp;&amp; (StringLike&lt;SpanT&gt; == false)</td></tr>
<tr class="memitem:aa6542c80266c9ed5a9a5b1a390d5f49c"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6542c80266c9ed5a9a5b1a390d5f49c">EnsurePathEndsWithDirectorySeparator</a> (const SpanT &amp;path)</td></tr>
<tr class="memdesc:aa6542c80266c9ed5a9a5b1a390d5f49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directory separator to the argument path if it does not end with a directory separator.  <br /></td></tr>
<tr class="separator:aa6542c80266c9ed5a9a5b1a390d5f49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be4240749be4c6e2b7e3699ce43781c" id="r_a4be4240749be4c6e2b7e3699ce43781c"><td class="memTemplParams" colspan="2">template&lt;StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires std::is_same_v&lt;typename ResultT::value_type, typename StringT::value_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT, const typename StringT::value_type*, typename StringT::size_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT, typename StringT::size_type, typename StringT::value_type&gt;</td></tr>
<tr class="memitem:a4be4240749be4c6e2b7e3699ce43781c"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4be4240749be4c6e2b7e3699ce43781c">EnsurePathEndsWithDirectorySeparator</a> (const StringT &amp;path)</td></tr>
<tr class="memdesc:a4be4240749be4c6e2b7e3699ce43781c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directory separator to the argument path if it does not end with a directory separator.  <br /></td></tr>
<tr class="separator:a4be4240749be4c6e2b7e3699ce43781c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae513595f5fc2c8b2af9b389015b70306" id="r_ae513595f5fc2c8b2af9b389015b70306"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, typename ResultT::value_type&gt; &amp;&amp; ( std::is_same_v&lt;CharT, wchar_t&gt; || std::is_same_v&lt;CharT, char&gt; ) &amp;&amp; std::is_constructible_v&lt;ResultT, const typename ResultT::value_type*, typename ResultT::size_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT, typename ResultT::size_type, typename ResultT::value_type&gt;</td></tr>
<tr class="memitem:ae513595f5fc2c8b2af9b389015b70306"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae513595f5fc2c8b2af9b389015b70306">EnsurePathEndsWithDirectorySeparator</a> (const CharT *path)</td></tr>
<tr class="memdesc:ae513595f5fc2c8b2af9b389015b70306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directory separator to the argument path if it does not end with a directory separator.  <br /></td></tr>
<tr class="separator:ae513595f5fc2c8b2af9b389015b70306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae678f6a466ce71656f361b767ee5e2e3" id="r_ae678f6a466ce71656f361b767ee5e2e3"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, SimpleCharSpanLike SpanT&gt; <br />
requires std::is_same_v&lt;typename SpanT::value_type,typename ResultT::value_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT,const typename ResultT::value_type*, typename ResultT::size_type&gt; &amp;&amp; ( StringLike&lt;SpanT&gt; == false )</td></tr>
<tr class="memitem:ae678f6a466ce71656f361b767ee5e2e3"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae678f6a466ce71656f361b767ee5e2e3">RemoveTrailingDirectorySeparator</a> (const SpanT &amp;path)</td></tr>
<tr class="memdesc:ae678f6a466ce71656f361b767ee5e2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims one trailing directory separator beyond the root of the specified path.  <br /></td></tr>
<tr class="separator:ae678f6a466ce71656f361b767ee5e2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefb8eacb5f7c84a26b29a7559e686e2" id="r_aaefb8eacb5f7c84a26b29a7559e686e2"><td class="memTemplParams" colspan="2">template&lt;StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type,typename ResultT::value_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT,const typename ResultT::value_type*, typename ResultT::size_type&gt;</td></tr>
<tr class="memitem:aaefb8eacb5f7c84a26b29a7559e686e2"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaefb8eacb5f7c84a26b29a7559e686e2">RemoveTrailingDirectorySeparator</a> (const StringT &amp;path)</td></tr>
<tr class="memdesc:aaefb8eacb5f7c84a26b29a7559e686e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims one trailing directory separator beyond the root of the specified path.  <br /></td></tr>
<tr class="separator:aaefb8eacb5f7c84a26b29a7559e686e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1f1944b7eb9a10b69bf1d160e2deac" id="r_a2b1f1944b7eb9a10b69bf1d160e2deac"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, typename CharT &gt; <br />
requires std::is_same_v&lt;CharT,typename ResultT::value_type&gt; &amp;&amp; ( std::is_same_v&lt;CharT, wchar_t&gt; || std::is_same_v&lt;CharT, char&gt; ) &amp;&amp; std::is_constructible_v&lt;ResultT,const typename ResultT::value_type*, typename ResultT::size_type&gt;</td></tr>
<tr class="memitem:a2b1f1944b7eb9a10b69bf1d160e2deac"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b1f1944b7eb9a10b69bf1d160e2deac">RemoveTrailingDirectorySeparator</a> (const CharT *path)</td></tr>
<tr class="memdesc:a2b1f1944b7eb9a10b69bf1d160e2deac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims one trailing directory separator beyond the root of the specified path.  <br /></td></tr>
<tr class="separator:a2b1f1944b7eb9a10b69bf1d160e2deac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7916c64723656350b6732004457aeff6" id="r_a7916c64723656350b6732004457aeff6"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, SimpleCharSpanLike SpanT1, SimpleCharSpanLike SpanT2&gt; <br />
requires ( std::is_same_v&lt;typename ResultT::value_type, std::remove_cvref_t&lt; typename SpanT1::value_type&gt; &gt; &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, std::remove_cvref_t&lt; typename SpanT2::value_type&gt; &gt; ) &amp;&amp; ( StringLike&lt;SpanT1&gt; == false &amp;&amp; StringLike&lt;SpanT2&gt; == false )</td></tr>
<tr class="memitem:a7916c64723656350b6732004457aeff6"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7916c64723656350b6732004457aeff6">Combine</a> (const SpanT1 &amp;startOfPath, const SpanT2 &amp;remainingPath)</td></tr>
<tr class="memdesc:a7916c64723656350b6732004457aeff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts.  <br /></td></tr>
<tr class="separator:a7916c64723656350b6732004457aeff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1017318802a8322bf3f4ecd016d3fd1d" id="r_a1017318802a8322bf3f4ecd016d3fd1d"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, SimpleCharSpanLike SpanT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, typename SpanT::value_type&gt; &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt; &amp;&amp; (StringLike&lt;SpanT&gt; == false)</td></tr>
<tr class="memitem:a1017318802a8322bf3f4ecd016d3fd1d"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1017318802a8322bf3f4ecd016d3fd1d">Combine</a> (const SpanT &amp;startOfPath, const CharT *remainingPath)</td></tr>
<tr class="memdesc:a1017318802a8322bf3f4ecd016d3fd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts.  <br /></td></tr>
<tr class="separator:a1017318802a8322bf3f4ecd016d3fd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45b2797e8b316d5975a1fd2db489188" id="r_ad45b2797e8b316d5975a1fd2db489188"><td class="memTemplParams" colspan="2">template&lt;StringLike StringT, typename CharT , StringLike ResultT = StringT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename StringT::value_type&gt; &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</td></tr>
<tr class="memitem:ad45b2797e8b316d5975a1fd2db489188"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad45b2797e8b316d5975a1fd2db489188">Combine</a> (const StringT &amp;startOfPath, const CharT *remainingPath)</td></tr>
<tr class="memdesc:ad45b2797e8b316d5975a1fd2db489188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts.  <br /></td></tr>
<tr class="separator:ad45b2797e8b316d5975a1fd2db489188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06b3ec0ff0f4ff24ccffc7f74d5ef42" id="r_ad06b3ec0ff0f4ff24ccffc7f74d5ef42"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, typename CharT , SimpleCharSpanLike SpanT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, typename SpanT::value_type&gt; &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt; &amp;&amp; ( StringLike&lt;SpanT&gt; == false )</td></tr>
<tr class="memitem:ad06b3ec0ff0f4ff24ccffc7f74d5ef42"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad06b3ec0ff0f4ff24ccffc7f74d5ef42">Combine</a> (const CharT *startOfPath, const SpanT &amp;remainingPath)</td></tr>
<tr class="memdesc:ad06b3ec0ff0f4ff24ccffc7f74d5ef42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts.  <br /></td></tr>
<tr class="separator:ad06b3ec0ff0f4ff24ccffc7f74d5ef42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b37f1e985dc215e4853f0bd5cf2d39" id="r_a13b37f1e985dc215e4853f0bd5cf2d39"><td class="memTemplParams" colspan="2">template&lt;typename CharT , StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename StringT::value_type&gt;</td></tr>
<tr class="memitem:a13b37f1e985dc215e4853f0bd5cf2d39"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13b37f1e985dc215e4853f0bd5cf2d39">Combine</a> (const CharT *startOfPath, const StringT &amp;remainingPath)</td></tr>
<tr class="memdesc:a13b37f1e985dc215e4853f0bd5cf2d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts.  <br /></td></tr>
<tr class="separator:a13b37f1e985dc215e4853f0bd5cf2d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac928a965cc475e644441fe3b2673a4ed" id="r_ac928a965cc475e644441fe3b2673a4ed"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</td></tr>
<tr class="memitem:ac928a965cc475e644441fe3b2673a4ed"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac928a965cc475e644441fe3b2673a4ed">Combine</a> (const CharT *startOfPath, const CharT *remainingPath)</td></tr>
<tr class="memdesc:ac928a965cc475e644441fe3b2673a4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts.  <br /></td></tr>
<tr class="separator:ac928a965cc475e644441fe3b2673a4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538878290e2cf316af3391a5669b19ad" id="r_a538878290e2cf316af3391a5669b19ad"><td class="memTemplParams" colspan="2">template&lt;SimpleCharSpanLike StringT1, SimpleCharSpanLike StringT2, StringLike ResultT = std::conditional_t&lt;StringLike&lt;StringT1&gt;, StringT1, StringT2 &gt;&gt; <br />
requires std::is_same_v&lt;typename StringT1::value_type, std::remove_cvref_t&lt; typename StringT2::value_type&gt; &gt;</td></tr>
<tr class="memitem:a538878290e2cf316af3391a5669b19ad"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a538878290e2cf316af3391a5669b19ad">Combine</a> (const StringT1 &amp;startOfPath, const StringT2 &amp;remainingPath)</td></tr>
<tr class="memdesc:a538878290e2cf316af3391a5669b19ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts.  <br /></td></tr>
<tr class="separator:a538878290e2cf316af3391a5669b19ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc7f22b339d569215676829498afc08" id="r_a2cc7f22b339d569215676829498afc08"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, SimpleCharSpanLike SpanT1, SimpleCharSpanLike SpanT2&gt; <br />
requires ( std::is_same_v&lt;typename ResultT::value_type, std::remove_cvref_t&lt; typename SpanT1::value_type&gt; &gt; &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, std::remove_cvref_t&lt; typename SpanT2::value_type&gt; &gt; ) &amp;&amp; ( StringLike&lt;SpanT1&gt; == false &amp;&amp; StringLike&lt;SpanT2&gt; == false )</td></tr>
<tr class="memitem:a2cc7f22b339d569215676829498afc08"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2cc7f22b339d569215676829498afc08">ChangeExtension</a> (const SpanT1 &amp;path, const SpanT2 &amp;newExtension)</td></tr>
<tr class="memdesc:a2cc7f22b339d569215676829498afc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the extension of a path string.  <br /></td></tr>
<tr class="separator:a2cc7f22b339d569215676829498afc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a1a00a107b0c1e30ed3a27d2d07248" id="r_a66a1a00a107b0c1e30ed3a27d2d07248"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, SimpleCharSpanLike SpanT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, typename SpanT::value_type&gt; &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt; &amp;&amp; (StringLike&lt;SpanT&gt; == false)</td></tr>
<tr class="memitem:a66a1a00a107b0c1e30ed3a27d2d07248"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66a1a00a107b0c1e30ed3a27d2d07248">ChangeExtension</a> (const SpanT &amp;path, const CharT *newExtension)</td></tr>
<tr class="memdesc:a66a1a00a107b0c1e30ed3a27d2d07248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the extension of a path string.  <br /></td></tr>
<tr class="separator:a66a1a00a107b0c1e30ed3a27d2d07248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cda9483a4400475d7ec2a6b7e1c845b" id="r_a9cda9483a4400475d7ec2a6b7e1c845b"><td class="memTemplParams" colspan="2">template&lt;StringLike StringT, typename CharT , StringLike ResultT = StringT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</td></tr>
<tr class="memitem:a9cda9483a4400475d7ec2a6b7e1c845b"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9cda9483a4400475d7ec2a6b7e1c845b">ChangeExtension</a> (const StringT &amp;path, const CharT *newExtension)</td></tr>
<tr class="memdesc:a9cda9483a4400475d7ec2a6b7e1c845b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the extension of a path string.  <br /></td></tr>
<tr class="separator:a9cda9483a4400475d7ec2a6b7e1c845b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117189634dcdf05e12c3f6865977900" id="r_a7117189634dcdf05e12c3f6865977900"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, typename CharT , SimpleCharSpanLike SpanT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, typename SpanT::value_type&gt; &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt; &amp;&amp; ( StringLike&lt;SpanT&gt; == false )</td></tr>
<tr class="memitem:a7117189634dcdf05e12c3f6865977900"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7117189634dcdf05e12c3f6865977900">ChangeExtension</a> (const CharT *path, const SpanT &amp;newExtension)</td></tr>
<tr class="memdesc:a7117189634dcdf05e12c3f6865977900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the extension of a path string.  <br /></td></tr>
<tr class="separator:a7117189634dcdf05e12c3f6865977900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1f2e2fa2bb6e60e2ad57b10066620c" id="r_a2a1f2e2fa2bb6e60e2ad57b10066620c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</td></tr>
<tr class="memitem:a2a1f2e2fa2bb6e60e2ad57b10066620c"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a1f2e2fa2bb6e60e2ad57b10066620c">ChangeExtension</a> (const CharT *path, const StringT &amp;newExtension)</td></tr>
<tr class="memdesc:a2a1f2e2fa2bb6e60e2ad57b10066620c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the extension of a path string.  <br /></td></tr>
<tr class="separator:a2a1f2e2fa2bb6e60e2ad57b10066620c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1d979282b6292c9e41bea140f462e4" id="r_ace1d979282b6292c9e41bea140f462e4"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</td></tr>
<tr class="memitem:ace1d979282b6292c9e41bea140f462e4"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace1d979282b6292c9e41bea140f462e4">ChangeExtension</a> (const CharT *path, const CharT *newExtension)</td></tr>
<tr class="memdesc:ace1d979282b6292c9e41bea140f462e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the extension of a path string.  <br /></td></tr>
<tr class="separator:ace1d979282b6292c9e41bea140f462e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a204f22a20fc8d85a3a97cbed84542" id="r_a67a204f22a20fc8d85a3a97cbed84542"><td class="memTemplParams" colspan="2">template&lt;SimpleCharSpanLike StringT1, SimpleCharSpanLike StringT2, StringLike ResultT = std::conditional_t&lt;StringLike&lt;StringT1&gt;, StringT1, StringT2 &gt;&gt; <br />
requires std::is_same_v&lt;typename StringT1::value_type, std::remove_cvref_t&lt; typename StringT2::value_type&gt; &gt;</td></tr>
<tr class="memitem:a67a204f22a20fc8d85a3a97cbed84542"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a67a204f22a20fc8d85a3a97cbed84542">ChangeExtension</a> (const StringT1 &amp;path, const StringT2 &amp;newExtension)</td></tr>
<tr class="memdesc:a67a204f22a20fc8d85a3a97cbed84542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the extension of a path string.  <br /></td></tr>
<tr class="separator:a67a204f22a20fc8d85a3a97cbed84542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe69eba005a7d12264fceb6787437bd6" id="r_abe69eba005a7d12264fceb6787437bd6"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, SimpleStringLike StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt; &amp;&amp; ( StringLike&lt;StringT&gt; == false )</td></tr>
<tr class="memitem:abe69eba005a7d12264fceb6787437bd6"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe69eba005a7d12264fceb6787437bd6">LongPathName</a> (const StringT &amp;path)</td></tr>
<tr class="memdesc:abe69eba005a7d12264fceb6787437bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the specified path to its long form.  <br /></td></tr>
<tr class="separator:abe69eba005a7d12264fceb6787437bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e304cf4006b93929ac9aed96c476fc3" id="r_a8e304cf4006b93929ac9aed96c476fc3"><td class="memTemplParams" colspan="2">template&lt;StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt;</td></tr>
<tr class="memitem:a8e304cf4006b93929ac9aed96c476fc3"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e304cf4006b93929ac9aed96c476fc3">LongPathName</a> (const StringT &amp;path)</td></tr>
<tr class="memdesc:a8e304cf4006b93929ac9aed96c476fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the specified path to its long form.  <br /></td></tr>
<tr class="separator:a8e304cf4006b93929ac9aed96c476fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4b9112c87243eda94ac20c1aaa06a8" id="r_a5c4b9112c87243eda94ac20c1aaa06a8"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</td></tr>
<tr class="memitem:a5c4b9112c87243eda94ac20c1aaa06a8"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c4b9112c87243eda94ac20c1aaa06a8">LongPathName</a> (const CharT *path)</td></tr>
<tr class="memdesc:a5c4b9112c87243eda94ac20c1aaa06a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the specified path to its long form.  <br /></td></tr>
<tr class="separator:a5c4b9112c87243eda94ac20c1aaa06a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32cf939dd791ab80d29323332dbc4c0" id="r_ad32cf939dd791ab80d29323332dbc4c0"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, SimpleStringLike StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt; &amp;&amp; ( StringLike&lt;StringT&gt; == false )</td></tr>
<tr class="memitem:ad32cf939dd791ab80d29323332dbc4c0"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad32cf939dd791ab80d29323332dbc4c0">ShortPathName</a> (const StringT &amp;path)</td></tr>
<tr class="memdesc:ad32cf939dd791ab80d29323332dbc4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the short path form of the specified path.  <br /></td></tr>
<tr class="separator:ad32cf939dd791ab80d29323332dbc4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ec65807e19e0fb8891d09fbf9eab30" id="r_a13ec65807e19e0fb8891d09fbf9eab30"><td class="memTemplParams" colspan="2">template&lt;StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt;</td></tr>
<tr class="memitem:a13ec65807e19e0fb8891d09fbf9eab30"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13ec65807e19e0fb8891d09fbf9eab30">ShortPathName</a> (const StringT &amp;path)</td></tr>
<tr class="memdesc:a13ec65807e19e0fb8891d09fbf9eab30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the short path form of the specified path.  <br /></td></tr>
<tr class="separator:a13ec65807e19e0fb8891d09fbf9eab30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92cf901dcd99dfb10e342d272e1e1ef" id="r_ab92cf901dcd99dfb10e342d272e1e1ef"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</td></tr>
<tr class="memitem:ab92cf901dcd99dfb10e342d272e1e1ef"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab92cf901dcd99dfb10e342d272e1e1ef">ShortPathName</a> (const CharT *path)</td></tr>
<tr class="memdesc:ab92cf901dcd99dfb10e342d272e1e1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the short path form of the specified path.  <br /></td></tr>
<tr class="separator:ab92cf901dcd99dfb10e342d272e1e1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26625ae1a930ab1cc2a5ea524e88deb2" id="r_a26625ae1a930ab1cc2a5ea524e88deb2"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, SimpleStringLike StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt; &amp;&amp; ( StringLike&lt;StringT&gt; == false )</td></tr>
<tr class="memitem:a26625ae1a930ab1cc2a5ea524e88deb2"><td class="memTemplItemLeft" align="right" valign="top">StringT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26625ae1a930ab1cc2a5ea524e88deb2">FullPath</a> (const StringT &amp;path, typename ResultT::size_type *indexOfFileName=nullptr)</td></tr>
<tr class="memdesc:a26625ae1a930ab1cc2a5ea524e88deb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the full path and file name of the specified file.  <br /></td></tr>
<tr class="separator:a26625ae1a930ab1cc2a5ea524e88deb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b52e116f24af7b9bcb167e3c991f1a" id="r_a54b52e116f24af7b9bcb167e3c991f1a"><td class="memTemplParams" colspan="2">template&lt;StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt;</td></tr>
<tr class="memitem:a54b52e116f24af7b9bcb167e3c991f1a"><td class="memTemplItemLeft" align="right" valign="top">StringT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54b52e116f24af7b9bcb167e3c991f1a">FullPath</a> (const StringT &amp;path, typename ResultT::size_type *indexOfFileName=nullptr)</td></tr>
<tr class="memdesc:a54b52e116f24af7b9bcb167e3c991f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the full path and file name of the specified file.  <br /></td></tr>
<tr class="separator:a54b52e116f24af7b9bcb167e3c991f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223e983f80e3e323c9cd91d379504565" id="r_a223e983f80e3e323c9cd91d379504565"><td class="memTemplParams" colspan="2">template&lt;StringLike ResultT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</td></tr>
<tr class="memitem:a223e983f80e3e323c9cd91d379504565"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a223e983f80e3e323c9cd91d379504565">FullPath</a> (const CharT *path, typename ResultT::size_type *indexOfFileName=nullptr)</td></tr>
<tr class="memdesc:a223e983f80e3e323c9cd91d379504565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the full path and file name of the specified file.  <br /></td></tr>
<tr class="separator:a223e983f80e3e323c9cd91d379504565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4da2774a7d8df3a26a188b2f9dfc46" id="r_a6e4da2774a7d8df3a26a188b2f9dfc46"><td class="memTemplParams" colspan="2">template&lt;StringLike StringT&gt; </td></tr>
<tr class="memitem:a6e4da2774a7d8df3a26a188b2f9dfc46"><td class="memTemplItemLeft" align="right" valign="top">StringT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e4da2774a7d8df3a26a188b2f9dfc46">RelativePath</a> (const StringT &amp;fromPath, DWORD fromAttributes, const StringT &amp;relativeToPath, DWORD toAttributes)</td></tr>
<tr class="separator:a6e4da2774a7d8df3a26a188b2f9dfc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9cb57ea2a4372211c9b87da457d0f6" id="r_aca9cb57ea2a4372211c9b87da457d0f6"><td class="memTemplParams" colspan="2">template&lt;StringLike StringT&gt; </td></tr>
<tr class="memitem:aca9cb57ea2a4372211c9b87da457d0f6"><td class="memTemplItemLeft" align="right" valign="top">StringT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca9cb57ea2a4372211c9b87da457d0f6">RelativePath</a> (const StringT &amp;fromDirectory, const StringT &amp;relativeToFilePath)</td></tr>
<tr class="separator:aca9cb57ea2a4372211c9b87da457d0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799ec0c5c5e93d40113baa96b5423533" id="r_a799ec0c5c5e93d40113baa96b5423533"><td class="memTemplParams" colspan="2">template&lt;typename Ch , StringLike StringT&gt; <br />
requires std::is_same_v&lt;std::remove_cvref_t&lt;typename StringT::value_type&gt;, Ch&gt;</td></tr>
<tr class="memitem:a799ec0c5c5e93d40113baa96b5423533"><td class="memTemplItemLeft" align="right" valign="top">StringT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a799ec0c5c5e93d40113baa96b5423533">RelativePath</a> (const Ch *fromPath, DWORD fromAttributes, const Ch *relativeToPath, DWORD toAttributes)</td></tr>
<tr class="separator:a799ec0c5c5e93d40113baa96b5423533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a247982d3166e6d5cf33e03019a40f" id="r_ab3a247982d3166e6d5cf33e03019a40f"><td class="memTemplParams" colspan="2">template&lt;typename Ch , StringLike StringT&gt; <br />
requires std::is_same_v&lt;std::remove_cvref_t&lt;typename StringT::value_type&gt;, Ch&gt;</td></tr>
<tr class="memitem:ab3a247982d3166e6d5cf33e03019a40f"><td class="memTemplItemLeft" align="right" valign="top">StringT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab3a247982d3166e6d5cf33e03019a40f">RelativePath</a> (const Ch *fromDirectory, const Ch *relativeToFilePath)</td></tr>
<tr class="separator:ab3a247982d3166e6d5cf33e03019a40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2e11c812c18f360e4fab15893ac4d8" id="r_abd2e11c812c18f360e4fab15893ac4d8"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; )</td></tr>
<tr class="memitem:abd2e11c812c18f360e4fab15893ac4d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_basic_string.html">BasicString</a>&lt; CharT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd2e11c812c18f360e4fab15893ac4d8">GetParentDirectory</a> (const CharT *path)</td></tr>
<tr class="separator:abd2e11c812c18f360e4fab15893ac4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0de4c6a9f411624c7730b332b3343e" id="r_a2b0de4c6a9f411624c7730b332b3343e"><td class="memTemplParams" colspan="2">template&lt;StringLike StringT&gt; </td></tr>
<tr class="memitem:a2b0de4c6a9f411624c7730b332b3343e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_basic_string.html">BasicString</a>&lt; typename StringT::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b0de4c6a9f411624c7730b332b3343e">GetParentDirectory</a> (const StringT &amp;path)</td></tr>
<tr class="separator:a2b0de4c6a9f411624c7730b332b3343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e536dc1becdf6ede91a40ca454e0315" id="r_a5e536dc1becdf6ede91a40ca454e0315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e536dc1becdf6ede91a40ca454e0315">CommonPrefix</a> (const wchar_t *path1, const wchar_t *path2, wchar_t *commonPrefix=nullptr)</td></tr>
<tr class="separator:a5e536dc1becdf6ede91a40ca454e0315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfc911b569c9963ae3a4311870e5884" id="r_a3cfc911b569c9963ae3a4311870e5884"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; <br />
requires (std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt;)</td></tr>
<tr class="memitem:a3cfc911b569c9963ae3a4311870e5884"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3cfc911b569c9963ae3a4311870e5884">IsRelative</a> (const CharT *path)</td></tr>
<tr class="separator:a3cfc911b569c9963ae3a4311870e5884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005ec2aaf7e3dbc4a715d9395eb4359f" id="r_a005ec2aaf7e3dbc4a715d9395eb4359f"><td class="memTemplParams" colspan="2">template&lt;SimpleStringLike StringT&gt; </td></tr>
<tr class="memitem:a005ec2aaf7e3dbc4a715d9395eb4359f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a005ec2aaf7e3dbc4a715d9395eb4359f">IsRelative</a> (const StringT &amp;path)</td></tr>
<tr class="separator:a005ec2aaf7e3dbc4a715d9395eb4359f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0708ac85394e978c5f3f144470a69260" id="r_a0708ac85394e978c5f3f144470a69260"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; )</td></tr>
<tr class="memitem:a0708ac85394e978c5f3f144470a69260"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0708ac85394e978c5f3f144470a69260">IsRoot</a> (const CharT *path)</td></tr>
<tr class="separator:a0708ac85394e978c5f3f144470a69260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0847dfd74651418971b0cac40651b23" id="r_af0847dfd74651418971b0cac40651b23"><td class="memTemplParams" colspan="2">template&lt;SimpleCharSpanLike StringT&gt; </td></tr>
<tr class="memitem:af0847dfd74651418971b0cac40651b23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0847dfd74651418971b0cac40651b23">IsPathRooted</a> (const StringT &amp;path)</td></tr>
<tr class="separator:af0847dfd74651418971b0cac40651b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ac30b3a9896d230efc810ab8a439e5" id="r_a75ac30b3a9896d230efc810ab8a439e5"><td class="memTemplParams" colspan="2">template&lt;SimpleStringLike StringT&gt; </td></tr>
<tr class="memitem:a75ac30b3a9896d230efc810ab8a439e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a75ac30b3a9896d230efc810ab8a439e5">IsRoot</a> (const StringT &amp;path)</td></tr>
<tr class="separator:a75ac30b3a9896d230efc810ab8a439e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02497be698a71b3473c56aad3480c7aa" id="r_a02497be698a71b3473c56aad3480c7aa"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; )</td></tr>
<tr class="memitem:a02497be698a71b3473c56aad3480c7aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02497be698a71b3473c56aad3480c7aa">IsUNC</a> (const CharT *path)</td></tr>
<tr class="separator:a02497be698a71b3473c56aad3480c7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcc5e750949eefbd6d74098022a593e" id="r_aebcc5e750949eefbd6d74098022a593e"><td class="memTemplParams" colspan="2">template&lt;SimpleStringLike StringT&gt; </td></tr>
<tr class="memitem:aebcc5e750949eefbd6d74098022a593e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aebcc5e750949eefbd6d74098022a593e">IsUNC</a> (const <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7b2b8eb82c826297870ffb50d3739060">WideString</a> &amp;path)</td></tr>
<tr class="separator:aebcc5e750949eefbd6d74098022a593e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a042d7cb54eaf59189237286f951ed069" id="r_a042d7cb54eaf59189237286f951ed069"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a042d7cb54eaf59189237286f951ed069">DirectorySeparatorChar</a> = '\\'</td></tr>
<tr class="separator:a042d7cb54eaf59189237286f951ed069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ef8aef7da5f09dc46028f6121731e7" id="r_a20ef8aef7da5f09dc46028f6121731e7"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20ef8aef7da5f09dc46028f6121731e7">AltDirectorySeparatorChar</a> = '/'</td></tr>
<tr class="separator:a20ef8aef7da5f09dc46028f6121731e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466f975e38a263269839cae1f160be61" id="r_a466f975e38a263269839cae1f160be61"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a466f975e38a263269839cae1f160be61">VolumeSeparatorChar</a> = ':'</td></tr>
<tr class="separator:a466f975e38a263269839cae1f160be61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91731f9cf1878f40bf24d46b546fea02" id="r_a91731f9cf1878f40bf24d46b546fea02"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91731f9cf1878f40bf24d46b546fea02">PathSeparator</a> = ';'</td></tr>
<tr class="separator:a91731f9cf1878f40bf24d46b546fea02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1909676e42726c16398525622229032" id="r_ad1909676e42726c16398525622229032"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1909676e42726c16398525622229032">MaxPath</a> = 260</td></tr>
<tr class="separator:ad1909676e42726c16398525622229032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4e9b74ad76427e2007d4ce3bb20dde" id="r_aca4e9b74ad76427e2007d4ce3bb20dde"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca4e9b74ad76427e2007d4ce3bb20dde">MaxDirectoryLength</a> = 255</td></tr>
<tr class="separator:aca4e9b74ad76427e2007d4ce3bb20dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ace1d979282b6292c9e41bea140f462e4" name="ace1d979282b6292c9e41bea140f462e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1d979282b6292c9e41bea140f462e4">&#9670;&#160;</a></span>ChangeExtension() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::ChangeExtension </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>newExtension</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the extension of a path string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">newExtension</td><td>The new extension for the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path with the new extension. </dd></dl>

</div>
</div>
<a id="a7117189634dcdf05e12c3f6865977900" name="a7117189634dcdf05e12c3f6865977900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117189634dcdf05e12c3f6865977900">&#9670;&#160;</a></span>ChangeExtension() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, typename CharT , SimpleCharSpanLike SpanT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, typename SpanT::value_type&gt; &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt; &amp;&amp; ( StringLike&lt;SpanT&gt; == false )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::ChangeExtension </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpanT &amp;</td>          <td class="paramname"><span class="paramname"><em>newExtension</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the extension of a path string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
    <tr><td class="paramname">SpanT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept, but not the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">newExtension</td><td>The new extension for the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path with the new extension. </dd></dl>

</div>
</div>
<a id="a2a1f2e2fa2bb6e60e2ad57b10066620c" name="a2a1f2e2fa2bb6e60e2ad57b10066620c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1f2e2fa2bb6e60e2ad57b10066620c">&#9670;&#160;</a></span>ChangeExtension() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::ChangeExtension </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>newExtension</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the extension of a path string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
    <tr><td class="paramname">StringT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. The purpose of this overload is to let this type be deduced from the startOfPath parameter. </td></tr>
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. By default this type is deduced from the type of StringT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">newExtension</td><td>The new extension for the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path with the new extension. </dd></dl>

</div>
</div>
<a id="a66a1a00a107b0c1e30ed3a27d2d07248" name="a66a1a00a107b0c1e30ed3a27d2d07248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a1a00a107b0c1e30ed3a27d2d07248">&#9670;&#160;</a></span>ChangeExtension() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, SimpleCharSpanLike SpanT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, typename SpanT::value_type&gt; &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt; &amp;&amp; (StringLike&lt;SpanT&gt; == false)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::ChangeExtension </td>
          <td>(</td>
          <td class="paramtype">const SpanT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>newExtension</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the extension of a path string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">SpanT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept, but not the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. </td></tr>
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">newExtension</td><td>The new extension for the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path with the new extension. </dd></dl>

</div>
</div>
<a id="a2cc7f22b339d569215676829498afc08" name="a2cc7f22b339d569215676829498afc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc7f22b339d569215676829498afc08">&#9670;&#160;</a></span>ChangeExtension() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, SimpleCharSpanLike SpanT1, SimpleCharSpanLike SpanT2&gt; <br />
requires ( std::is_same_v&lt;typename ResultT::value_type, std::remove_cvref_t&lt; typename SpanT1::value_type&gt; &gt; &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, std::remove_cvref_t&lt; typename SpanT2::value_type&gt; &gt; ) &amp;&amp; ( StringLike&lt;SpanT1&gt; == false &amp;&amp; StringLike&lt;SpanT2&gt; == false )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::ChangeExtension </td>
          <td>(</td>
          <td class="paramtype">const SpanT1 &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpanT2 &amp;</td>          <td class="paramname"><span class="paramname"><em>newExtension</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the extension of a path string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">SpanT1</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept, but not the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept if SpanT2 matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. </td></tr>
    <tr><td class="paramname">SpanT2</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept, but not the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept if SpanT1 matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">newExtension</td><td>The new extension for the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path with the new extension. </dd></dl>

</div>
</div>
<a id="a9cda9483a4400475d7ec2a6b7e1c845b" name="a9cda9483a4400475d7ec2a6b7e1c845b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cda9483a4400475d7ec2a6b7e1c845b">&#9670;&#160;</a></span>ChangeExtension() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike StringT, typename CharT , StringLike ResultT = StringT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::ChangeExtension </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>newExtension</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the extension of a path string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. The purpose of this overload is to let this type be deduced from the startOfPath parameter. </td></tr>
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. By default this type is deduced from the type of StringT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">newExtension</td><td>The new extension for the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path with the new extension. </dd></dl>

</div>
</div>
<a id="a67a204f22a20fc8d85a3a97cbed84542" name="a67a204f22a20fc8d85a3a97cbed84542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a204f22a20fc8d85a3a97cbed84542">&#9670;&#160;</a></span>ChangeExtension() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleCharSpanLike StringT1, SimpleCharSpanLike StringT2, StringLike ResultT = std::conditional_t&lt;StringLike&lt;StringT1&gt;, StringT1, StringT2 &gt;&gt; <br />
requires std::is_same_v&lt;typename StringT1::value_type, std::remove_cvref_t&lt; typename StringT2::value_type&gt; &gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::ChangeExtension </td>
          <td>(</td>
          <td class="paramtype">const StringT1 &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT2 &amp;</td>          <td class="paramname"><span class="paramname"><em>newExtension</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the extension of a path string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringT1</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept. </td></tr>
    <tr><td class="paramname">StringT2</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept. </td></tr>
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. By default this type is deduced from the type of StringT1 or StringT2 as long as at least one of the types satisfies the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. When both satisfies the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept, ResultT is deduced to be of type StringT1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path. </td></tr>
    <tr><td class="paramname">newExtension</td><td>The new extension for the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path with the new extension. </dd></dl>

</div>
</div>
<a id="ac928a965cc475e644441fe3b2673a4ed" name="ac928a965cc475e644441fe3b2673a4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac928a965cc475e644441fe3b2673a4ed">&#9670;&#160;</a></span>Combine() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::Combine </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>startOfPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>remainingPath</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startOfPath</td><td>A pointer to a zero terminated string containing the first part of the path. </td></tr>
    <tr><td class="paramname">remainingPath</td><td>A pointer to a zero terminated string containing the second part of the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined path. </dd></dl>

</div>
</div>
<a id="ad06b3ec0ff0f4ff24ccffc7f74d5ef42" name="ad06b3ec0ff0f4ff24ccffc7f74d5ef42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06b3ec0ff0f4ff24ccffc7f74d5ef42">&#9670;&#160;</a></span>Combine() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, typename CharT , SimpleCharSpanLike SpanT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, typename SpanT::value_type&gt; &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt; &amp;&amp; ( StringLike&lt;SpanT&gt; == false )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::Combine </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>startOfPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpanT &amp;</td>          <td class="paramname"><span class="paramname"><em>remainingPath</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
    <tr><td class="paramname">SpanT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept, but not the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startOfPath</td><td>The first part of the path. </td></tr>
    <tr><td class="paramname">remainingPath</td><td>A pointer to a zero terminated string containing the second part of the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined path. </dd></dl>
<p>Use this overload when the type of the result cannot be deduced from the remainingPath argument type. </p>

</div>
</div>
<a id="a13b37f1e985dc215e4853f0bd5cf2d39" name="a13b37f1e985dc215e4853f0bd5cf2d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b37f1e985dc215e4853f0bd5cf2d39">&#9670;&#160;</a></span>Combine() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename StringT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::Combine </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>startOfPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>remainingPath</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
    <tr><td class="paramname">StringT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. The purpose of this overload is to let this type be deduced from the startOfPath parameter. </td></tr>
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. By default this type is deduced from the type of StringT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startOfPath</td><td>The first part of the path. </td></tr>
    <tr><td class="paramname">remainingPath</td><td>A pointer to a zero terminated string containing the second part of the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined path. </dd></dl>
<p>Use this overload when the type of the result can be deduced from the remainingPath argument type. </p>

</div>
</div>
<a id="a1017318802a8322bf3f4ecd016d3fd1d" name="a1017318802a8322bf3f4ecd016d3fd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1017318802a8322bf3f4ecd016d3fd1d">&#9670;&#160;</a></span>Combine() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, SimpleCharSpanLike SpanT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, typename SpanT::value_type&gt; &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt; &amp;&amp; (StringLike&lt;SpanT&gt; == false)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::Combine </td>
          <td>(</td>
          <td class="paramtype">const SpanT &amp;</td>          <td class="paramname"><span class="paramname"><em>startOfPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>remainingPath</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">SpanT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept, but not the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. </td></tr>
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startOfPath</td><td>The first part of the path. </td></tr>
    <tr><td class="paramname">remainingPath</td><td>A pointer to a zero terminated string containing the second part of the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined path. </dd></dl>
<p>Use this overload when the type of the result cannot be deduced from the startOfPath argument type. </p>

</div>
</div>
<a id="a7916c64723656350b6732004457aeff6" name="a7916c64723656350b6732004457aeff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7916c64723656350b6732004457aeff6">&#9670;&#160;</a></span>Combine() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, SimpleCharSpanLike SpanT1, SimpleCharSpanLike SpanT2&gt; <br />
requires ( std::is_same_v&lt;typename ResultT::value_type, std::remove_cvref_t&lt; typename SpanT1::value_type&gt; &gt; &amp;&amp; std::is_same_v&lt;typename ResultT::value_type, std::remove_cvref_t&lt; typename SpanT2::value_type&gt; &gt; ) &amp;&amp; ( StringLike&lt;SpanT1&gt; == false &amp;&amp; StringLike&lt;SpanT2&gt; == false )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::Combine </td>
          <td>(</td>
          <td class="paramtype">const SpanT1 &amp;</td>          <td class="paramname"><span class="paramname"><em>startOfPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpanT2 &amp;</td>          <td class="paramname"><span class="paramname"><em>remainingPath</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">SpanT1</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept, but not the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept if SpanT2 matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. </td></tr>
    <tr><td class="paramname">SpanT2</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept, but not the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept if SpanT1 matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startOfPath</td><td>The first part of the path. </td></tr>
    <tr><td class="paramname">remainingPath</td><td>The second part of the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined path. </dd></dl>
<p>Use this overload when the type of the result cannot be deduced from either of the argument types. </p>

</div>
</div>
<a id="ad45b2797e8b316d5975a1fd2db489188" name="ad45b2797e8b316d5975a1fd2db489188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45b2797e8b316d5975a1fd2db489188">&#9670;&#160;</a></span>Combine() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike StringT, typename CharT , StringLike ResultT = StringT&gt; <br />
requires ( std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename StringT::value_type&gt; &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::Combine </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>startOfPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>remainingPath</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. The purpose of this overload is to let this type be deduced from the startOfPath parameter. </td></tr>
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. By default this type is deduced from the type of StringT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startOfPath</td><td>The first part of the path. </td></tr>
    <tr><td class="paramname">remainingPath</td><td>A pointer to a zero terminated string containing the second part of the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined path. </dd></dl>
<p>Use this overload when the type of the result can be deduced from the startOfPath argument type. </p>

</div>
</div>
<a id="a538878290e2cf316af3391a5669b19ad" name="a538878290e2cf316af3391a5669b19ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538878290e2cf316af3391a5669b19ad">&#9670;&#160;</a></span>Combine() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleCharSpanLike StringT1, SimpleCharSpanLike StringT2, StringLike ResultT = std::conditional_t&lt;StringLike&lt;StringT1&gt;, StringT1, StringT2 &gt;&gt; <br />
requires std::is_same_v&lt;typename StringT1::value_type, std::remove_cvref_t&lt; typename StringT2::value_type&gt; &gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::Combine </td>
          <td>(</td>
          <td class="paramtype">const StringT1 &amp;</td>          <td class="paramname"><span class="paramname"><em>startOfPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT2 &amp;</td>          <td class="paramname"><span class="paramname"><em>remainingPath</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines strings into a path, and, if necessary, inserts a directory separator between the the two parts. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringT1</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept. </td></tr>
    <tr><td class="paramname">StringT2</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept. </td></tr>
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. By default this type is deduced from the type of StringT1 or StringT2 as long as at least one of the types satisfies the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept. When both satisfies the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept, ResultT is deduced to be of type StringT1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startOfPath</td><td>The first part of the path. </td></tr>
    <tr><td class="paramname">remainingPath</td><td>The second part of the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined path. </dd></dl>
<p>Use this overload when the type of the result can be deduced from the remainingPath argument type. </p>

</div>
</div>
<a id="a5e536dc1becdf6ede91a40ca454e0315" name="a5e536dc1becdf6ede91a40ca454e0315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e536dc1becdf6ede91a40ca454e0315">&#9670;&#160;</a></span>CommonPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Harlinn::Common::Core::IO::Path::CommonPrefix </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>path1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>path2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *</td>          <td class="paramname"><span class="paramname"><em>commonPrefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab896cb76ab8156e5875e0a9ba950287b" name="ab896cb76ab8156e5875e0a9ba950287b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab896cb76ab8156e5875e0a9ba950287b">&#9670;&#160;</a></span>EndsInDirectorySeparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, wchar_t&gt; || std::is_same_v&lt;CharT, char&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::EndsInDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value that indicates whether the specified path ends in a directory separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A pointer to the zero terminated path to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the specified path ends in a directory separator, otherwise false. </dd></dl>

</div>
</div>
<a id="a62bffa3730c9e0483ec988fe2745a09e" name="a62bffa3730c9e0483ec988fe2745a09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bffa3730c9e0483ec988fe2745a09e">&#9670;&#160;</a></span>EndsInDirectorySeparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleCharSpanLike StringT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::EndsInDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value that indicates whether the specified path ends in a directory separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the specified path ends in a directory separator, otherwise false. </dd></dl>

</div>
</div>
<a id="a13426da0ccbd008545c48233c19967cd" name="a13426da0ccbd008545c48233c19967cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13426da0ccbd008545c48233c19967cd">&#9670;&#160;</a></span>EndsWithDirectorySeparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, wchar_t&gt; || std::is_same_v&lt;CharT, char&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::EndsWithDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value that indicates whether the specified path ends in a directory separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A pointer to the zero terminated path to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the specified path ends in a directory separator, otherwise false. </dd></dl>

</div>
</div>
<a id="a1bc7d7f47df1c9e6966e254c25973cff" name="a1bc7d7f47df1c9e6966e254c25973cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc7d7f47df1c9e6966e254c25973cff">&#9670;&#160;</a></span>EndsWithDirectorySeparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleCharSpanLike SpanT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::EndsWithDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const SpanT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value that indicates whether the specified path ends in a directory separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SpanT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the specified path ends in a directory separator, otherwise false. </dd></dl>

</div>
</div>
<a id="ae513595f5fc2c8b2af9b389015b70306" name="ae513595f5fc2c8b2af9b389015b70306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae513595f5fc2c8b2af9b389015b70306">&#9670;&#160;</a></span>EnsurePathEndsWithDirectorySeparator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, typename ResultT::value_type&gt; &amp;&amp; ( std::is_same_v&lt;CharT, wchar_t&gt; || std::is_same_v&lt;CharT, char&gt; ) &amp;&amp; std::is_constructible_v&lt;ResultT, const typename ResultT::value_type*, typename ResultT::size_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT, typename ResultT::size_type, typename ResultT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::EnsurePathEndsWithDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a directory separator to the argument path if it does not end with a directory separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A path with or without a directory separator at the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path with a directory separator at the end. </dd></dl>

</div>
</div>
<a id="aa6542c80266c9ed5a9a5b1a390d5f49c" name="aa6542c80266c9ed5a9a5b1a390d5f49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6542c80266c9ed5a9a5b1a390d5f49c">&#9670;&#160;</a></span>EnsurePathEndsWithDirectorySeparator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, SimpleCharSpanLike SpanT&gt; <br />
requires std::is_same_v&lt;typename SpanT::value_type, typename ResultT::value_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT, const typename ResultT::value_type*, typename ResultT::size_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT, typename ResultT::size_type, typename ResultT::value_type&gt; &amp;&amp; (StringLike&lt;SpanT&gt; == false)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::EnsurePathEndsWithDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const SpanT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a directory separator to the argument path if it does not end with a directory separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">SpanT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept. The type of SpanT::value_type must be of the same type as StringT::value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A path with or without a directory separator at the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path with a directory separator at the end. </dd></dl>

</div>
</div>
<a id="a4be4240749be4c6e2b7e3699ce43781c" name="a4be4240749be4c6e2b7e3699ce43781c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be4240749be4c6e2b7e3699ce43781c">&#9670;&#160;</a></span>EnsurePathEndsWithDirectorySeparator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires std::is_same_v&lt;typename ResultT::value_type, typename StringT::value_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT, const typename StringT::value_type*, typename StringT::size_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT, typename StringT::size_type, typename StringT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::EnsurePathEndsWithDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a directory separator to the argument path if it does not end with a directory separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the argument path. </td></tr>
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A path with or without a directory separator at the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path with a directory separator at the end. </dd></dl>

</div>
</div>
<a id="a223e983f80e3e323c9cd91d379504565" name="a223e983f80e3e323c9cd91d379504565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223e983f80e3e323c9cd91d379504565">&#9670;&#160;</a></span>FullPath() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::FullPath </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ResultT::size_type *</td>          <td class="paramname"><span class="paramname"><em>indexOfFileName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the full path and file name of the specified file. </p>

</div>
</div>
<a id="a26625ae1a930ab1cc2a5ea524e88deb2" name="a26625ae1a930ab1cc2a5ea524e88deb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26625ae1a930ab1cc2a5ea524e88deb2">&#9670;&#160;</a></span>FullPath() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, SimpleStringLike StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt; &amp;&amp; ( StringLike&lt;StringT&gt; == false )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringT Harlinn::Common::Core::IO::Path::FullPath </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ResultT::size_type *</td>          <td class="paramname"><span class="paramname"><em>indexOfFileName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the full path and file name of the specified file. </p>

</div>
</div>
<a id="a54b52e116f24af7b9bcb167e3c991f1a" name="a54b52e116f24af7b9bcb167e3c991f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b52e116f24af7b9bcb167e3c991f1a">&#9670;&#160;</a></span>FullPath() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringT Harlinn::Common::Core::IO::Path::FullPath </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ResultT::size_type *</td>          <td class="paramname"><span class="paramname"><em>indexOfFileName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the full path and file name of the specified file. </p>

</div>
</div>
<a id="abd2e11c812c18f360e4fab15893ac4d8" name="abd2e11c812c18f360e4fab15893ac4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2e11c812c18f360e4fab15893ac4d8">&#9670;&#160;</a></span>GetParentDirectory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_basic_string.html">BasicString</a>&lt; CharT &gt; Harlinn::Common::Core::IO::Path::GetParentDirectory </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b0de4c6a9f411624c7730b332b3343e" name="a2b0de4c6a9f411624c7730b332b3343e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0de4c6a9f411624c7730b332b3343e">&#9670;&#160;</a></span>GetParentDirectory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike StringT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_basic_string.html">BasicString</a>&lt; typename StringT::value_type &gt; Harlinn::Common::Core::IO::Path::GetParentDirectory </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a548d13211858a9dbba7c901c0eb4a9e5" name="a548d13211858a9dbba7c901c0eb4a9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548d13211858a9dbba7c901c0eb4a9e5">&#9670;&#160;</a></span>IsDirectorySeparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">CharT</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2defcc978ff9c9c7a9b0d937b41a4cc7" name="a2defcc978ff9c9c7a9b0d937b41a4cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2defcc978ff9c9c7a9b0d937b41a4cc7">&#9670;&#160;</a></span>IsDirectorySeparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleCharSpanLike SpanT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const SpanT &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0847dfd74651418971b0cac40651b23" name="af0847dfd74651418971b0cac40651b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0847dfd74651418971b0cac40651b23">&#9670;&#160;</a></span>IsPathRooted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleCharSpanLike StringT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsPathRooted </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cfc911b569c9963ae3a4311870e5884" name="a3cfc911b569c9963ae3a4311870e5884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfc911b569c9963ae3a4311870e5884">&#9670;&#160;</a></span>IsRelative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; <br />
requires (std::is_same_v&lt;CharT,char&gt; || std::is_same_v&lt;CharT, wchar_t&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsRelative </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a005ec2aaf7e3dbc4a715d9395eb4359f" name="a005ec2aaf7e3dbc4a715d9395eb4359f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005ec2aaf7e3dbc4a715d9395eb4359f">&#9670;&#160;</a></span>IsRelative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleStringLike StringT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsRelative </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0708ac85394e978c5f3f144470a69260" name="a0708ac85394e978c5f3f144470a69260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0708ac85394e978c5f3f144470a69260">&#9670;&#160;</a></span>IsRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsRoot </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75ac30b3a9896d230efc810ab8a439e5" name="a75ac30b3a9896d230efc810ab8a439e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ac30b3a9896d230efc810ab8a439e5">&#9670;&#160;</a></span>IsRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleStringLike StringT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsRoot </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02497be698a71b3473c56aad3480c7aa" name="a02497be698a71b3473c56aad3480c7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02497be698a71b3473c56aad3480c7aa">&#9670;&#160;</a></span>IsUNC() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsUNC </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebcc5e750949eefbd6d74098022a593e" name="aebcc5e750949eefbd6d74098022a593e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcc5e750949eefbd6d74098022a593e">&#9670;&#160;</a></span>IsUNC() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleStringLike StringT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsUNC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7b2b8eb82c826297870ffb50d3739060">WideString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a148789b534f913a65a577bf8687c5a58" name="a148789b534f913a65a577bf8687c5a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148789b534f913a65a577bf8687c5a58">&#9670;&#160;</a></span>IsValidDriveChar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsValidDriveChar </td>
          <td>(</td>
          <td class="paramtype">CharT</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a662bf3730191f44018570b062fcbaca0" name="a662bf3730191f44018570b062fcbaca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662bf3730191f44018570b062fcbaca0">&#9670;&#160;</a></span>IsValidDriveChar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleCharSpanLike SpanT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::IsValidDriveChar </td>
          <td>(</td>
          <td class="paramtype">const SpanT &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c4b9112c87243eda94ac20c1aaa06a8" name="a5c4b9112c87243eda94ac20c1aaa06a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4b9112c87243eda94ac20c1aaa06a8">&#9670;&#160;</a></span>LongPathName() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::LongPathName </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the specified path to its long form. </p>

</div>
</div>
<a id="abe69eba005a7d12264fceb6787437bd6" name="abe69eba005a7d12264fceb6787437bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe69eba005a7d12264fceb6787437bd6">&#9670;&#160;</a></span>LongPathName() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, SimpleStringLike StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt; &amp;&amp; ( StringLike&lt;StringT&gt; == false )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::LongPathName </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the specified path to its long form. </p>

</div>
</div>
<a id="a8e304cf4006b93929ac9aed96c476fc3" name="a8e304cf4006b93929ac9aed96c476fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e304cf4006b93929ac9aed96c476fc3">&#9670;&#160;</a></span>LongPathName() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::LongPathName </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the specified path to its long form. </p>

</div>
</div>
<a id="ab3a247982d3166e6d5cf33e03019a40f" name="ab3a247982d3166e6d5cf33e03019a40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a247982d3166e6d5cf33e03019a40f">&#9670;&#160;</a></span>RelativePath() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ch , StringLike StringT&gt; <br />
requires std::is_same_v&lt;std::remove_cvref_t&lt;typename StringT::value_type&gt;, Ch&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringT Harlinn::Common::Core::IO::Path::RelativePath </td>
          <td>(</td>
          <td class="paramtype">const Ch *</td>          <td class="paramname"><span class="paramname"><em>fromDirectory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ch *</td>          <td class="paramname"><span class="paramname"><em>relativeToFilePath</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a799ec0c5c5e93d40113baa96b5423533" name="a799ec0c5c5e93d40113baa96b5423533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799ec0c5c5e93d40113baa96b5423533">&#9670;&#160;</a></span>RelativePath() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ch , StringLike StringT&gt; <br />
requires std::is_same_v&lt;std::remove_cvref_t&lt;typename StringT::value_type&gt;, Ch&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringT Harlinn::Common::Core::IO::Path::RelativePath </td>
          <td>(</td>
          <td class="paramtype">const Ch *</td>          <td class="paramname"><span class="paramname"><em>fromPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>fromAttributes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ch *</td>          <td class="paramname"><span class="paramname"><em>relativeToPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>toAttributes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca9cb57ea2a4372211c9b87da457d0f6" name="aca9cb57ea2a4372211c9b87da457d0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9cb57ea2a4372211c9b87da457d0f6">&#9670;&#160;</a></span>RelativePath() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike StringT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringT Harlinn::Common::Core::IO::Path::RelativePath </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>fromDirectory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>relativeToFilePath</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e4da2774a7d8df3a26a188b2f9dfc46" name="a6e4da2774a7d8df3a26a188b2f9dfc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4da2774a7d8df3a26a188b2f9dfc46">&#9670;&#160;</a></span>RelativePath() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike StringT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringT Harlinn::Common::Core::IO::Path::RelativePath </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>fromPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>fromAttributes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>relativeToPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>toAttributes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b1f1944b7eb9a10b69bf1d160e2deac" name="a2b1f1944b7eb9a10b69bf1d160e2deac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1f1944b7eb9a10b69bf1d160e2deac">&#9670;&#160;</a></span>RemoveTrailingDirectorySeparator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, typename CharT &gt; <br />
requires std::is_same_v&lt;CharT,typename ResultT::value_type&gt; &amp;&amp; ( std::is_same_v&lt;CharT, wchar_t&gt; || std::is_same_v&lt;CharT, char&gt; ) &amp;&amp; std::is_constructible_v&lt;ResultT,const typename ResultT::value_type*, typename ResultT::size_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::RemoveTrailingDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trims one trailing directory separator beyond the root of the specified path. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. The type of CharT must be of the same type as ResultT::value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A path with or without a directory separator at the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path without a directory separator at the end. </dd></dl>

</div>
</div>
<a id="ae678f6a466ce71656f361b767ee5e2e3" name="ae678f6a466ce71656f361b767ee5e2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae678f6a466ce71656f361b767ee5e2e3">&#9670;&#160;</a></span>RemoveTrailingDirectorySeparator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, SimpleCharSpanLike SpanT&gt; <br />
requires std::is_same_v&lt;typename SpanT::value_type,typename ResultT::value_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT,const typename ResultT::value_type*, typename ResultT::size_type&gt; &amp;&amp; ( StringLike&lt;SpanT&gt; == false )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::RemoveTrailingDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const SpanT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trims one trailing directory separator beyond the root of the specified path. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
    <tr><td class="paramname">SpanT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept. The type of SpanT::value_type must be of the same type as ResultT::value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A path with or without a directory separator at the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path without a directory separator at the end. </dd></dl>

</div>
</div>
<a id="aaefb8eacb5f7c84a26b29a7559e686e2" name="aaefb8eacb5f7c84a26b29a7559e686e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefb8eacb5f7c84a26b29a7559e686e2">&#9670;&#160;</a></span>RemoveTrailingDirectorySeparator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type,typename ResultT::value_type&gt; &amp;&amp; std::is_constructible_v&lt;ResultT,const typename ResultT::value_type*, typename ResultT::size_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::RemoveTrailingDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trims one trailing directory separator beyond the root of the specified path. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StringT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the argument path. </td></tr>
    <tr><td class="paramname">ResultT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_string_like.html" title="Matches zero terminated C++ string classes with sequential memory layout that implements an API simil...">StringLike</a> concept specifying the type of the returned value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A path with or without a directory separator at the end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path without a directory separator at the end. </dd></dl>

</div>
</div>
<a id="ab92cf901dcd99dfb10e342d272e1e1ef" name="ab92cf901dcd99dfb10e342d272e1e1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92cf901dcd99dfb10e342d272e1e1ef">&#9670;&#160;</a></span>ShortPathName() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, typename CharT &gt; <br />
requires ( std::is_same_v&lt;CharT, char&gt; || std::is_same_v&lt;CharT, wchar_t&gt; ) &amp;&amp; std::is_same_v&lt;CharT, typename ResultT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::ShortPathName </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the short path form of the specified path. </p>

</div>
</div>
<a id="ad32cf939dd791ab80d29323332dbc4c0" name="ad32cf939dd791ab80d29323332dbc4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32cf939dd791ab80d29323332dbc4c0">&#9670;&#160;</a></span>ShortPathName() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike ResultT, SimpleStringLike StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt; &amp;&amp; ( StringLike&lt;StringT&gt; == false )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::ShortPathName </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the short path form of the specified path. </p>

</div>
</div>
<a id="a13ec65807e19e0fb8891d09fbf9eab30" name="a13ec65807e19e0fb8891d09fbf9eab30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ec65807e19e0fb8891d09fbf9eab30">&#9670;&#160;</a></span>ShortPathName() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StringLike StringT, StringLike ResultT = StringT&gt; <br />
requires std::is_same_v&lt;typename StringT::value_type, std::remove_cvref_t&lt; typename ResultT::value_type&gt; &gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Common::Core::IO::Path::ShortPathName </td>
          <td>(</td>
          <td class="paramtype">const StringT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the short path form of the specified path. </p>

</div>
</div>
<a id="ab8788149a070d28f56f9d21755a55470" name="ab8788149a070d28f56f9d21755a55470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8788149a070d28f56f9d21755a55470">&#9670;&#160;</a></span>StartsWithDirectorySeparator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; <br />
requires std::is_same_v&lt;CharT, wchar_t&gt; || std::is_same_v&lt;CharT, char&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::StartsWithDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const CharT *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value that indicates whether the specified path starts with a directory separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>Either char or wchar_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A pointer to the zero terminated path to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the specified path starts with a directory separator, otherwise false. </dd></dl>

</div>
</div>
<a id="a243368956d5ef165a7ad0e6eccf2109d" name="a243368956d5ef165a7ad0e6eccf2109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243368956d5ef165a7ad0e6eccf2109d">&#9670;&#160;</a></span>StartsWithDirectorySeparator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleCharSpanLike SpanT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Path::StartsWithDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const SpanT &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value that indicates whether the specified path starts with a directory separator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SpanT</td><td>A type that matches the <a class="el" href="concept_harlinn_1_1_common_1_1_core_1_1_simple_char_span_like.html" title="Matches most common string classes with sequential memory layout. Do not assume that they are zero te...">SimpleCharSpanLike</a> concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the specified path starts with a directory separator, otherwise false. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a20ef8aef7da5f09dc46028f6121731e7" name="a20ef8aef7da5f09dc46028f6121731e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ef8aef7da5f09dc46028f6121731e7">&#9670;&#160;</a></span>AltDirectorySeparatorChar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char Harlinn::Common::Core::IO::Path::AltDirectorySeparatorChar = '/'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a042d7cb54eaf59189237286f951ed069" name="a042d7cb54eaf59189237286f951ed069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042d7cb54eaf59189237286f951ed069">&#9670;&#160;</a></span>DirectorySeparatorChar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char Harlinn::Common::Core::IO::Path::DirectorySeparatorChar = '\\'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca4e9b74ad76427e2007d4ce3bb20dde" name="aca4e9b74ad76427e2007d4ce3bb20dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4e9b74ad76427e2007d4ce3bb20dde">&#9670;&#160;</a></span>MaxDirectoryLength</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Common::Core::IO::Path::MaxDirectoryLength = 255</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1909676e42726c16398525622229032" name="ad1909676e42726c16398525622229032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1909676e42726c16398525622229032">&#9670;&#160;</a></span>MaxPath</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Common::Core::IO::Path::MaxPath = 260</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91731f9cf1878f40bf24d46b546fea02" name="a91731f9cf1878f40bf24d46b546fea02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91731f9cf1878f40bf24d46b546fea02">&#9670;&#160;</a></span>PathSeparator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char Harlinn::Common::Core::IO::Path::PathSeparator = ';'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a466f975e38a263269839cae1f160be61" name="a466f975e38a263269839cae1f160be61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466f975e38a263269839cae1f160be61">&#9670;&#160;</a></span>VolumeSeparatorChar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char Harlinn::Common::Core::IO::Path::VolumeSeparatorChar = ':'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_harlinn.html">Harlinn</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_common.html">Common</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html">Core</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o.html">IO</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_path.html">Path</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>

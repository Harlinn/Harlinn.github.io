<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Harlinn.Windows: Harlinn::Windows::Media::StreamingMediaSink Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Harlinn.Windows<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_harlinn_1_1_windows_1_1_media_1_1_streaming_media_sink.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_harlinn_1_1_windows_1_1_media_1_1_streaming_media_sink-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Harlinn::Windows::Media::StreamingMediaSink Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;HWStreamingMediaSink.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Harlinn::Windows::Media::StreamingMediaSink:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_harlinn_1_1_windows_1_1_media_1_1_streaming_media_sink__inherit__graph.svg" width="492" height="80"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Harlinn::Windows::Media::StreamingMediaSink:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_harlinn_1_1_windows_1_1_media_1_1_streaming_media_sink__coll__graph.svg" width="492" height="80"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2eb29b90f16e9f4769d495c9fc458c0c" id="r_a2eb29b90f16e9f4769d495c9fc458c0c"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eb29b90f16e9f4769d495c9fc458c0c">GetCharacteristics</a> (__RPC__out DWORD *pdwCharacteristics) override</td></tr>
<tr class="memdesc:a2eb29b90f16e9f4769d495c9fc458c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the characteristics of the media sink.  <br /></td></tr>
<tr class="separator:a2eb29b90f16e9f4769d495c9fc458c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa4b8fa40b6b67dcb837747c84e1c78" id="r_a1fa4b8fa40b6b67dcb837747c84e1c78"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fa4b8fa40b6b67dcb837747c84e1c78">AddStreamSink</a> (DWORD dwStreamSinkIdentifier, __RPC__in_opt IMFMediaType *pMediaType, __RPC__deref_out_opt IMFStreamSink **ppStreamSink) override</td></tr>
<tr class="memdesc:a1fa4b8fa40b6b67dcb837747c84e1c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new stream sink to the media sink.  <br /></td></tr>
<tr class="separator:a1fa4b8fa40b6b67dcb837747c84e1c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2765571112b19daa510fec06aa8aa9" id="r_a9c2765571112b19daa510fec06aa8aa9"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c2765571112b19daa510fec06aa8aa9">RemoveStreamSink</a> (DWORD dwStreamSinkIdentifier) override</td></tr>
<tr class="memdesc:a9c2765571112b19daa510fec06aa8aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a stream sink from the media sink.  <br /></td></tr>
<tr class="separator:a9c2765571112b19daa510fec06aa8aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19984a07be83775a3e37b3e36bdcbb08" id="r_a19984a07be83775a3e37b3e36bdcbb08"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19984a07be83775a3e37b3e36bdcbb08">GetStreamSinkCount</a> (__RPC__out DWORD *pcStreamSinkCount) override</td></tr>
<tr class="memdesc:a19984a07be83775a3e37b3e36bdcbb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of stream sinks on this media sink.  <br /></td></tr>
<tr class="separator:a19984a07be83775a3e37b3e36bdcbb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820e79f57f1a797d120ba5891df53fc1" id="r_a820e79f57f1a797d120ba5891df53fc1"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a820e79f57f1a797d120ba5891df53fc1">GetStreamSinkByIndex</a> (DWORD dwIndex, __RPC__deref_out_opt IMFStreamSink **ppStreamSink) override</td></tr>
<tr class="memdesc:a820e79f57f1a797d120ba5891df53fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a stream sink, specified by index.  <br /></td></tr>
<tr class="separator:a820e79f57f1a797d120ba5891df53fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02191f4d9ba773cb304d99019e85dfb" id="r_ab02191f4d9ba773cb304d99019e85dfb"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab02191f4d9ba773cb304d99019e85dfb">GetStreamSinkById</a> (DWORD dwStreamSinkIdentifier, __RPC__deref_out_opt IMFStreamSink **ppStreamSink) override</td></tr>
<tr class="memdesc:ab02191f4d9ba773cb304d99019e85dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a stream sink, specified by stream identifier.  <br /></td></tr>
<tr class="separator:ab02191f4d9ba773cb304d99019e85dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1740d2275a4fab9d822e85c8ccf776" id="r_ada1740d2275a4fab9d822e85c8ccf776"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada1740d2275a4fab9d822e85c8ccf776">SetPresentationClock</a> (__RPC__in_opt IMFPresentationClock *pPresentationClock) override</td></tr>
<tr class="memdesc:ada1740d2275a4fab9d822e85c8ccf776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the presentation clock on the media sink.  <br /></td></tr>
<tr class="separator:ada1740d2275a4fab9d822e85c8ccf776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa800f8271eadcbabccefaaa6e1339c4f" id="r_aa800f8271eadcbabccefaaa6e1339c4f"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa800f8271eadcbabccefaaa6e1339c4f">GetPresentationClock</a> (__RPC__deref_out_opt IMFPresentationClock **ppPresentationClock) override</td></tr>
<tr class="memdesc:aa800f8271eadcbabccefaaa6e1339c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the presentation clock that was set on the media sink.  <br /></td></tr>
<tr class="separator:aa800f8271eadcbabccefaaa6e1339c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e39bb426d8a5dc5363b02289f2a582" id="r_a51e39bb426d8a5dc5363b02289f2a582"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51e39bb426d8a5dc5363b02289f2a582">Shutdown</a> () override</td></tr>
<tr class="memdesc:a51e39bb426d8a5dc5363b02289f2a582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down the media sink and releases the resources it is using.  <br /></td></tr>
<tr class="separator:a51e39bb426d8a5dc5363b02289f2a582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca070e60865d488cd86c3381ac5aba4b" id="r_aca070e60865d488cd86c3381ac5aba4b"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca070e60865d488cd86c3381ac5aba4b">BeginFinalize</a> (IMFAsyncCallback *pCallback, IUnknown *punkState) override</td></tr>
<tr class="memdesc:aca070e60865d488cd86c3381ac5aba4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the media sink to asynchronously take any steps it needs to finish its tasks.  <br /></td></tr>
<tr class="separator:aca070e60865d488cd86c3381ac5aba4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be41ab92e9f12d2f91bc57f89c94500" id="r_a7be41ab92e9f12d2f91bc57f89c94500"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7be41ab92e9f12d2f91bc57f89c94500">EndFinalize</a> (IMFAsyncResult *pResult) override</td></tr>
<tr class="memdesc:a7be41ab92e9f12d2f91bc57f89c94500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes an asynchronous finalize operation.  <br /></td></tr>
<tr class="separator:a7be41ab92e9f12d2f91bc57f89c94500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d1a12421d9dd9269cf3721512b6fc8" id="r_ad2d1a12421d9dd9269cf3721512b6fc8"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2d1a12421d9dd9269cf3721512b6fc8">OnClockStart</a> (MFTIME hnsSystemTime, LONGLONG llClockStartOffset) override</td></tr>
<tr class="memdesc:ad2d1a12421d9dd9269cf3721512b6fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the presentation clock starts.  <br /></td></tr>
<tr class="separator:ad2d1a12421d9dd9269cf3721512b6fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887e58171b385b7b41543e4117624162" id="r_a887e58171b385b7b41543e4117624162"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a887e58171b385b7b41543e4117624162">OnClockStop</a> (MFTIME hnsSystemTime) override</td></tr>
<tr class="memdesc:a887e58171b385b7b41543e4117624162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the presentation clock stops.  <br /></td></tr>
<tr class="separator:a887e58171b385b7b41543e4117624162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d1ca774b6cba40e538a3a7f2e3390c" id="r_a92d1ca774b6cba40e538a3a7f2e3390c"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92d1ca774b6cba40e538a3a7f2e3390c">OnClockPause</a> (MFTIME hnsSystemTime) override</td></tr>
<tr class="memdesc:a92d1ca774b6cba40e538a3a7f2e3390c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the presentation clock pauses.  <br /></td></tr>
<tr class="separator:a92d1ca774b6cba40e538a3a7f2e3390c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b4deb6edb3bb74acab5b09ea0a2833" id="r_a26b4deb6edb3bb74acab5b09ea0a2833"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26b4deb6edb3bb74acab5b09ea0a2833">OnClockRestart</a> (MFTIME hnsSystemTime) override</td></tr>
<tr class="memdesc:a26b4deb6edb3bb74acab5b09ea0a2833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the presentation clock restarts from the same position while paused.  <br /></td></tr>
<tr class="separator:a26b4deb6edb3bb74acab5b09ea0a2833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49258e5fb6a3590f605ea4f8db4dd5ba" id="r_a49258e5fb6a3590f605ea4f8db4dd5ba"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49258e5fb6a3590f605ea4f8db4dd5ba">OnClockSetRate</a> (MFTIME hnsSystemTime, float flRate) override</td></tr>
<tr class="memdesc:a49258e5fb6a3590f605ea4f8db4dd5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the rate changes on the presentation clock.  <br /></td></tr>
<tr class="separator:a49258e5fb6a3590f605ea4f8db4dd5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b277ac6c8139e454cddd88503c6631" id="r_a64b277ac6c8139e454cddd88503c6631"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64b277ac6c8139e454cddd88503c6631">GetParameters</a> (__RPC__out DWORD *pdwFlags, __RPC__out DWORD *pdwQueue) override</td></tr>
<tr class="memdesc:a64b277ac6c8139e454cddd88503c6631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides configuration information to the dispatching thread for a callback.  <br /></td></tr>
<tr class="separator:a64b277ac6c8139e454cddd88503c6631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6882b0f3f0177990150a3dcaa9c136e" id="r_aa6882b0f3f0177990150a3dcaa9c136e"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6882b0f3f0177990150a3dcaa9c136e">Invoke</a> (__RPC__in_opt IMFAsyncResult *pAsyncResult) override</td></tr>
<tr class="separator:aa6882b0f3f0177990150a3dcaa9c136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1fa4b8fa40b6b67dcb837747c84e1c78" name="a1fa4b8fa40b6b67dcb837747c84e1c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa4b8fa40b6b67dcb837747c84e1c78">&#9670;&#160;</a></span>AddStreamSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::AddStreamSink </td>
          <td>(</td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>dwStreamSinkIdentifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__RPC__in_opt IMFMediaType *</td>          <td class="paramname"><span class="paramname"><em>pMediaType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__RPC__deref_out_opt IMFStreamSink **</td>          <td class="paramname"><span class="paramname"><em>ppStreamSink</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new stream sink to the media sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwStreamSinkIdentifier</td><td>Identifier for the new stream. The value is arbitrary but must be unique </td></tr>
    <tr><td class="paramname">pMediaType</td><td>Pointer to the IMFMediaType interface, specifying the media type for the stream. This parameter can be NULL. </td></tr>
    <tr><td class="paramname">ppStreamSink</td><td>Receives a pointer to the new stream sink's IMFStreamSink interface. The caller must release the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_INVALIDSTREAMNUMBER: The specified stream identifier is not valid.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
<li>
MF_E_STREAMSINK_EXISTS: There is already a stream sink with the same stream identifier.  </li>
<li>
MF_E_STREAMSINKS_FIXED: This media sink has a fixed set of stream sinks.New stream sinks cannot be added.  </li>
</ul>
</dd></dl>
<p>Not all media sinks support this method. If the media sink does not support this method, the IMFMediaSink::GetCharacteristics method returns the MEDIASINK_FIXED_STREAMS flag. </p>
<p>If pMediaType is NULL, use the IMFMediaTypeHandler interface to set the media type. Call IMFStreamSink::GetMediaTypeHandler to get a pointer to the interface. </p>
<p>&lt;/remakrs&gt; </p>

</div>
</div>
<a id="aca070e60865d488cd86c3381ac5aba4b" name="aca070e60865d488cd86c3381ac5aba4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca070e60865d488cd86c3381ac5aba4b">&#9670;&#160;</a></span>BeginFinalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::BeginFinalize </td>
          <td>(</td>
          <td class="paramtype">IMFAsyncCallback *</td>          <td class="paramname"><span class="paramname"><em>pCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IUnknown *</td>          <td class="paramname"><span class="paramname"><em>punkState</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the media sink to asynchronously take any steps it needs to finish its tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallback</td><td>Pointer to the IMFAsyncCallback interface of an asynchronous object. The caller must implement this interface. </td></tr>
    <tr><td class="paramname">punkState</td><td>Pointer to the IUnknown interface of a state object, defined by the caller. This parameter can be NULL. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
</ul>
</dd></dl>
<p>Many archive media sinks have steps they need to do at the end of archiving to complete their file operations, such as updating the header (for some formats) or flushing all pending writes to disk. In some cases, this may include expensive operations such as indexing the content. BeginFinalize is an asynchronous way to initiate final tasks. </p>
<p>When the finalize operation is complete, the callback object's IMFAsyncCallback::Invoke method is called. At that point, the application should call IMFFinalizableMediaSink::EndFinalize to complete the asynchronous request. </p>

</div>
</div>
<a id="a7be41ab92e9f12d2f91bc57f89c94500" name="a7be41ab92e9f12d2f91bc57f89c94500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be41ab92e9f12d2f91bc57f89c94500">&#9670;&#160;</a></span>EndFinalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::EndFinalize </td>
          <td>(</td>
          <td class="paramtype">IMFAsyncResult *</td>          <td class="paramname"><span class="paramname"><em>pResult</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes an asynchronous finalize operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pResult</td><td>Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the IMFAsyncCallback::Invoke method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
</ul>
</dd></dl>
<p>Call this method after the IMFFinalizableMediaSink::BeginFinalize method completes asynchronously. </p>

</div>
</div>
<a id="a2eb29b90f16e9f4769d495c9fc458c0c" name="a2eb29b90f16e9f4769d495c9fc458c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb29b90f16e9f4769d495c9fc458c0c">&#9670;&#160;</a></span>GetCharacteristics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::GetCharacteristics </td>
          <td>(</td>
          <td class="paramtype">__RPC__out DWORD *</td>          <td class="paramname"><span class="paramname"><em>pdwCharacteristics</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the characteristics of the media sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdwCharacteristics</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Receives a bitwise OR of zero or more flags. The following flags are defined: </p>
<ul>
<li>
MEDIASINK_FIXED_STREAMS (0x00000001): The media sink has a fixed number of streams. It does not support the IMFMediaSink::AddStreamSink and IMFMediaSink::RemoveStreamSink methods.This flag is a hint to the application.  </li>
<li>
<p class="startli"></p>
<p class="interli">MEDIASINK_CANNOT_MATCH_CLOCK (0x00000002):The media sink cannot match rates with an external clock. For best results, this media sink should be used as the time source for the presentation clock. If any other time source is used, the media sink cannot match rates with the clock, with poor results(for example, glitching). </p>
<p class="interli"></p>
<p class="interli">This flag should be used sparingly, because it limits how the pipeline can be configured. </p>
<p class="endli"></p>
</li>
<li>
MEDIASINK_RATELESS (0x00000004): The media sink is rateless. It consumes samples as quickly as possible, and does not synchronize itself to a presentation clock. Most archiving sinks are rateless.  </li>
<li>
<p class="startli"></p>
<p class="interli">MEDIASINK_CLOCK_REQUIRED (0x00000008): The media sink requires a presentation clock. The presentation clock is set by calling the media sink's IMFMediaSink::SetPresentationClock method. </p>
<p class="interli"></p>
<p class="interli">This flag is obsolete, because all media sinks must support the SetPresentationClock method, even if the media sink ignores the clock (as in a rateless media sink). </p>
<p class="endli"></p>
</li>
<li>
MEDIASINK_CAN_PREROLL (0x00000010): The media sink can accept preroll samples before the presentation clock starts. The media sink exposes the IMFMediaSinkPreroll interface.  </li>
<li>
MEDIASINK_REQUIRE_REFERENCE_MEDIATYPE (0x00000020): The first stream sink (index 0) is a reference stream. The reference stream must have a media type before the media types can be set on the other stream sinks.  </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a64b277ac6c8139e454cddd88503c6631" name="a64b277ac6c8139e454cddd88503c6631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b277ac6c8139e454cddd88503c6631">&#9670;&#160;</a></span>GetParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::GetParameters </td>
          <td>(</td>
          <td class="paramtype">__RPC__out DWORD *</td>          <td class="paramname"><span class="paramname"><em>pdwFlags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__RPC__out DWORD *</td>          <td class="paramname"><span class="paramname"><em>pdwQueue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides configuration information to the dispatching thread for a callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdwFlags</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Receives a flag indicating the behavior of the callback object's IMFAsyncCallback::Invoke method. The following values are defined. The default value is zero. </p>
<ul>
<li>
Zero: The callback does not take a long time to complete, but has no specific restrictions on what system calls it makes. The callback generally takes less than 30 milliseconds to complete.  </li>
<li>
<p class="startli"></p>
<p class="interli">MFASYNC_FAST_IO_PROCESSING_CALLBACK: The callback does very minimal processing. It takes less than 1 millisecond to complete. </p>
<p class="interli"></p>
<p class="interli">The callback must be invoked from one of the following work queues: </p>
<ul>
<li>
MFASYNC_CALLBACK_QUEUE_IO  </li>
<li>
MFASYNC_CALLBACK_QUEUE_TIMER  </li>
</ul>
</li>
<li>
<p class="startli"></p>
<p class="interli">MFASYNC_SIGNAL_CALLBACK: Implies MFASYNC_FAST_IO_PROCESSING_CALLBACK, with the additional restriction that the callback does no processing (less than 50 microseconds), and the only system call it makes is SetEvent. </p>
<p class="interli"></p>
<p class="interli">The callback must be invoked from one of the following work queues: </p>
<ul>
<li>
MFASYNC_CALLBACK_QUEUE_IO  </li>
<li>
MFASYNC_CALLBACK_QUEUE_TIMER  </li>
</ul>
</li>
<li>
MFASYNC_BLOCKING_CALLBACK: Blocking callback.  </li>
<li>
MFASYNC_REPLY_CALLBACK: Reply callback.  </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdwQueue</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Receives the identifier of the work queue on which the callback is dispatched. </p>
<p>This value can specify one of the standard <a class="el" href="namespace_harlinn_1_1_windows_1_1_media.html">Media</a> Foundation work queues, or a work queue created by the application. For list of standard <a class="el" href="namespace_harlinn_1_1_windows_1_1_media.html">Media</a> Foundation work queues, see Work Queue Identifiers. To create a new work queue, call MFAllocateWorkQueue. The default value is MFASYNC_CALLBACK_QUEUE_STANDARD. </p>
<p>If the work queue is not compatible with the value returned in pdwFlags, the <a class="el" href="namespace_harlinn_1_1_windows_1_1_media.html">Media</a> Foundation platform returns MF_E_INVALID_WORKQUEUE when it tries to dispatch the callback. (See MFPutWorkItem.) </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
E_NOTIMPL: Not implemented. Assume the default behavior.  </li>
</ul>
</dd></dl>
<p>The GetParameters method returns information about the callback so that the dispatching thread can optimize the process that it uses to invoke the callback. </p>
<p>If the method returns a value other than zero in the pdwFlags parameter, your Invoke method must meet the requirements described here. Otherwise, the callback might delay the pipeline. </p>
<p>If you want default values for both parameters, return E_NOTIMPL. The default values are given in the parameter descriptions on this page. </p>

</div>
</div>
<a id="aa800f8271eadcbabccefaaa6e1339c4f" name="aa800f8271eadcbabccefaaa6e1339c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa800f8271eadcbabccefaaa6e1339c4f">&#9670;&#160;</a></span>GetPresentationClock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::GetPresentationClock </td>
          <td>(</td>
          <td class="paramtype">__RPC__deref_out_opt IMFPresentationClock **</td>          <td class="paramname"><span class="paramname"><em>ppPresentationClock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the presentation clock that was set on the media sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppPresentationClock</td><td>Receives a pointer to the presentation clock's IMFPresentationClock interface. The caller must release the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_NO_CLOCK: No clock has been set.To set the presentation clock, call IMFMediaSink::SetPresentationClock.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab02191f4d9ba773cb304d99019e85dfb" name="ab02191f4d9ba773cb304d99019e85dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02191f4d9ba773cb304d99019e85dfb">&#9670;&#160;</a></span>GetStreamSinkById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::GetStreamSinkById </td>
          <td>(</td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>dwStreamSinkIdentifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__RPC__deref_out_opt IMFStreamSink **</td>          <td class="paramname"><span class="paramname"><em>ppStreamSink</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a stream sink, specified by stream identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwStreamSinkIdentifier</td><td>Stream identifier of the stream sink. </td></tr>
    <tr><td class="paramname">ppStreamSink</td><td>Receives a pointer to the stream's IMFStreamSink interface. The caller must release the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_INVALIDSTREAMNUMBER: The stream identifier is not valid.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
</ul>
</dd></dl>
<p>If you add a stream sink by calling the IMFMediaSink::AddStreamSink method, the stream identifier is specified in the dwStreamSinkIdentifier parameter of that method. If the media sink has a fixed set of streams, the media sink assigns the stream identifiers. </p>
<p>To enumerate the streams by index number instead of stream identifier, call IMFMediaSink::GetStreamSinkByIndex. </p>

</div>
</div>
<a id="a820e79f57f1a797d120ba5891df53fc1" name="a820e79f57f1a797d120ba5891df53fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820e79f57f1a797d120ba5891df53fc1">&#9670;&#160;</a></span>GetStreamSinkByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::GetStreamSinkByIndex </td>
          <td>(</td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>dwIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__RPC__deref_out_opt IMFStreamSink **</td>          <td class="paramname"><span class="paramname"><em>ppStreamSink</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a stream sink, specified by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwIndex</td><td>Zero-based index of the stream. To get the number of streams, call IMFMediaSink::GetStreamSinkCount. </td></tr>
    <tr><td class="paramname">ppStreamSink</td><td>Receives a pointer to the stream's IMFStreamSink interface. The caller must release the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_INVALIDINDEX: Invalid index.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
</ul>
</dd></dl>
<p>Enumerating stream sinks is not a thread-safe operation, because stream sinks can be added or removed between calls to this method. </p>

</div>
</div>
<a id="a19984a07be83775a3e37b3e36bdcbb08" name="a19984a07be83775a3e37b3e36bdcbb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19984a07be83775a3e37b3e36bdcbb08">&#9670;&#160;</a></span>GetStreamSinkCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::GetStreamSinkCount </td>
          <td>(</td>
          <td class="paramtype">__RPC__out DWORD *</td>          <td class="paramname"><span class="paramname"><em>pcStreamSinkCount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of stream sinks on this media sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcStreamSinkCount</td><td>Receives the number of stream sinks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa6882b0f3f0177990150a3dcaa9c136e" name="aa6882b0f3f0177990150a3dcaa9c136e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6882b0f3f0177990150a3dcaa9c136e">&#9670;&#160;</a></span>Invoke()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::Invoke </td>
          <td>(</td>
          <td class="paramtype">__RPC__in_opt IMFAsyncResult *</td>          <td class="paramname"><span class="paramname"><em>pAsyncResult</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92d1ca774b6cba40e538a3a7f2e3390c" name="a92d1ca774b6cba40e538a3a7f2e3390c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d1ca774b6cba40e538a3a7f2e3390c">&#9670;&#160;</a></span>OnClockPause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::OnClockPause </td>
          <td>(</td>
          <td class="paramtype">MFTIME</td>          <td class="paramname"><span class="paramname"><em>hnsSystemTime</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the presentation clock pauses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hnsSystemTime</td><td>The system time when the clock was paused, in 100-nanosecond units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code </dd></dl>
<p>When the presentation clock's IMFPresentationClock::Pause method is called, the clock notifies the presentation time source by calling the time source's OnClockPause method. This call occurs synchronously within the Pause method. If the time source returns an error from OnClockPause, the presentation clock's Pause method returns an error and the state change does not take place. </p>
<p>For any object that is not the presentation time source, the OnClockPause method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored. </p>

</div>
</div>
<a id="a26b4deb6edb3bb74acab5b09ea0a2833" name="a26b4deb6edb3bb74acab5b09ea0a2833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b4deb6edb3bb74acab5b09ea0a2833">&#9670;&#160;</a></span>OnClockRestart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::OnClockRestart </td>
          <td>(</td>
          <td class="paramtype">MFTIME</td>          <td class="paramname"><span class="paramname"><em>hnsSystemTime</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the presentation clock restarts from the same position while paused. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hnsSystemTime</td><td>The system time when the clock restarted, in 100-nanosecond units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </dd></dl>
<p>This method is called if the presentation clock is paused and the IMFPresentationClock::Start method is called with the value PRESENTATION_CURRENT_POSITION. </p>
<p>The clock notifies the presentation time source by calling the time source's OnClockRestart method. This call occurs synchronously within the Start method. If the time source returns an error from OnClockRestart, the presentation clock's Start method returns an error and the state change does not take place. </p>
<p>For any object that is not the presentation time source, the OnClockRestart method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored. </p>

</div>
</div>
<a id="a49258e5fb6a3590f605ea4f8db4dd5ba" name="a49258e5fb6a3590f605ea4f8db4dd5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49258e5fb6a3590f605ea4f8db4dd5ba">&#9670;&#160;</a></span>OnClockSetRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::OnClockSetRate </td>
          <td>(</td>
          <td class="paramtype">MFTIME</td>          <td class="paramname"><span class="paramname"><em>hnsSystemTime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>flRate</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the rate changes on the presentation clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hnsSystemTime</td><td>The system time when the rate was set, in 100-nanosecond units. </td></tr>
    <tr><td class="paramname">flRate</td><td>The new rate, as a multiplier of the normal playback rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </dd></dl>
<p>When the presentation clock's IMFRateControl::SetRate method is called, the clock notifies the presentation time source by calling the time source's OnClockSetRate method. This call occurs synchronously within the SetRate method. If the time source returns an error from OnClockSetRate, the presentation clock's SetRate method returns an error and the state change does not take place. </p>
<p>For any object that is not the presentation time source, the OnClockSetRate method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored. </p>

</div>
</div>
<a id="ad2d1a12421d9dd9269cf3721512b6fc8" name="ad2d1a12421d9dd9269cf3721512b6fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d1a12421d9dd9269cf3721512b6fc8">&#9670;&#160;</a></span>OnClockStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::OnClockStart </td>
          <td>(</td>
          <td class="paramtype">MFTIME</td>          <td class="paramname"><span class="paramname"><em>hnsSystemTime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LONGLONG</td>          <td class="paramname"><span class="paramname"><em>llClockStartOffset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the presentation clock starts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hnsSystemTime</td><td>The system time when the clock started, in 100-nanosecond units. </td></tr>
    <tr><td class="paramname">llClockStartOffset</td><td>The new starting time for the clock, in 100-nanosecond units. This parameter can also equal PRESENTATION_CURRENT_POSITION, indicating the clock has started or restarted from its current position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </dd></dl>
<p>This method is called when the presentation clock's IMFPresentationClock::Start method is called, with the following exception: If the clock is paused and Start is called with the value PRESENTATION_CURRENT_POSITION, IMFClockStateSink::OnClockRestart is called instead of OnClockStart. </p>
<p>The clock notifies the presentation time source by calling the time source's OnClockStart method. This call occurs synchronously within the Start method. If the time source returns an error from OnClockStart, the presentation clock's Start method returns an error and the state change does not take place. </p>
<p>For any object that is not the presentation time source, the OnClockStart method is called asynchronously, after the state change is completed. In that case, the return value from this method is ignored. </p>
<p>The value given in llClockStartOffset is the presentation time when the clock starts, so it is relative to the start of the presentation. <a class="el" href="namespace_harlinn_1_1_windows_1_1_media.html">Media</a> sinks should not render any data with a presentation time earlier than llClockStartOffSet. If a sample straddles the offsetthat is, if the offset falls between the sample's start and stop timesthe sink should either trim the sample so that only data after llClockStartOffset is rendered, or else simply drop the sample. </p>

</div>
</div>
<a id="a887e58171b385b7b41543e4117624162" name="a887e58171b385b7b41543e4117624162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887e58171b385b7b41543e4117624162">&#9670;&#160;</a></span>OnClockStop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::OnClockStop </td>
          <td>(</td>
          <td class="paramtype">MFTIME</td>          <td class="paramname"><span class="paramname"><em>hnsSystemTime</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the presentation clock stops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hnsSystemTime</td><td>The system time when the clock stopped, in 100-nanosecond units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_SINK_ALREADYSTOPPED: Deprecated.Do not use this error code.  </li>
</ul>
</dd></dl>
<p>When the presentation clock's IMFPresentationClock::Stop method is called, the clock notifies the presentation time source by calling the presentation time source's OnClockStop method. This call occurs synchronously within the Stop method. If the time source returns an error from OnClockStop, the presentation clock's Stop method returns an error and the state change does not take place. </p>
<p>For any object that is not the presentation time source, the OnClockStop method is called asynchronously, after the state change is completed. </p>
<p>If an object is already stopped, it should return S_OK from OnClockStop. It should not return an error code. </p>

</div>
</div>
<a id="a9c2765571112b19daa510fec06aa8aa9" name="a9c2765571112b19daa510fec06aa8aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2765571112b19daa510fec06aa8aa9">&#9670;&#160;</a></span>RemoveStreamSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::RemoveStreamSink </td>
          <td>(</td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>dwStreamSinkIdentifier</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a stream sink from the media sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwStreamSinkIdentifier</td><td>Identifier of the stream to remove. The stream identifier is defined when you call IMFMediaSink::AddStreamSink to add the stream sink. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
E_INVALIDARG: This particular stream sink cannot be removed.  </li>
<li>
MF_E_INVALIDSTREAMNUMBER: The stream number is not valid.  </li>
<li>
MF_E_NOT_INITIALIZED: The media sink has not been initialized.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
<li>
MF_E_STREAMSINKS_FIXED: This media sink has a fixed set of stream sinks.Stream sinks cannot be removed.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ada1740d2275a4fab9d822e85c8ccf776" name="ada1740d2275a4fab9d822e85c8ccf776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1740d2275a4fab9d822e85c8ccf776">&#9670;&#160;</a></span>SetPresentationClock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::SetPresentationClock </td>
          <td>(</td>
          <td class="paramtype">__RPC__in_opt IMFPresentationClock *</td>          <td class="paramname"><span class="paramname"><em>pPresentationClock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the presentation clock on the media sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPresentationClock</td><td>Pointer to the IMFPresentationClock interface of the presentation clock, or NULL. If the value is NULL, the media sink stops listening to the presentation clock that was previously set, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_CLOCK_NO_TIME_SOURCE: The presentation clock does not have a time source.Call SetTimeSource on the presentation clock.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
</ul>
</dd></dl>
<p>During streaming, the media sink attempts to match rates with the presentation clock. Ideally, the media sink presents samples at the correct time according to the presentation clock and does not fall behind. Rateless media sinks are an exception to this rule, as they consume samples as quickly as possible and ignore the clock. If the sink is rateless, the IMFMediaSink::GetCharacteristics method returns the MEDIASINK_RATELESS flag. </p>
<p>The presentation clock must have a time source. Before calling this method, call IMFPresentationClock::SetTimeSource on the presentation clock to set the presentation time source. Some media sinks provide time sources; therefore, the media sink might be the time source for its own presentation clock. Regardless of what object provides the time source, however, the media sink must attempt to match rates with the clock specified in pPresentationClock. If a media sink cannot match rates with an external time source, the media sink's IMFMediaSink::GetCharacteristics method retrieves the MEDIASINK_CANNOT_MATCH_CLOCK flag. In this case, SetPresentationClock will still succeed, but the results will not be optimal. The sink might not render samples quickly enough to match rates with the presentation clock. </p>
<p>If pPresentationClock is non-NULL, the media sink must register for clock state notifications, by calling IMFPresentationClock::AddClockStateSink on the presentation clock. If the method is called again with a new presentation clock, or if pPresentationClock is NULL, the media sink must call IMFPresentationClock::RemoveClockStateSink to deregister itself from the previous clock. </p>
<p>All media sinks must support this method. </p>

</div>
</div>
<a id="a51e39bb426d8a5dc5363b02289f2a582" name="a51e39bb426d8a5dc5363b02289f2a582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e39bb426d8a5dc5363b02289f2a582">&#9670;&#160;</a></span>Shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingMediaSink::Shutdown </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuts down the media sink and releases the resources it is using. </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_SHUTDOWN: The media sink was shut down.  </li>
</ul>
</dd></dl>
<p>If the application creates the media sink, it is responsible for calling Shutdown to avoid memory or resource leaks. In most applications, however, the application creates an activation object for the media sink, and the <a class="el" href="namespace_harlinn_1_1_windows_1_1_media.html">Media</a> Session uses that object to create the media sink. In that case, the <a class="el" href="namespace_harlinn_1_1_windows_1_1_media.html">Media</a> Session  not the application  shuts down the media sink. (For more information, see Activation Objects.) </p>
<p>After this method returns, all methods on the media sink return MF_E_SHUTDOWN, except for IUnknown methods and IMFMediaEventGenerator methods. The sink will not raise any events after this method is called. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_h_w_streaming_media_sink_8h.html">HWStreamingMediaSink.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_harlinn.html">Harlinn</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_windows_1_1_media.html">Media</a></li><li class="navelem"><a class="el" href="class_harlinn_1_1_windows_1_1_media_1_1_streaming_media_sink.html">StreamingMediaSink</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>

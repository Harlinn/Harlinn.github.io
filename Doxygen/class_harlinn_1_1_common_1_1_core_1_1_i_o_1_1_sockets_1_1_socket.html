<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Harlinn.Windows: Harlinn::Common::Core::IO::Sockets::Socket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Harlinn.Windows<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Harlinn::Common::Core::IO::Sockets::Socket Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a socket descriptor that is bound to a specific transport-service provider.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;HCCSocket.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Harlinn::Common::Core::IO::Sockets::Socket:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket__inherit__graph.svg" width="814" height="318"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4ff98a1b209fd2bf2956668183730e8a" id="r_a4ff98a1b209fd2bf2956668183730e8a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff98a1b209fd2bf2956668183730e8a">Flags</a> = <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">SocketFlags</a></td></tr>
<tr class="separator:a4ff98a1b209fd2bf2956668183730e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac4e63936a25c68e274e679cff60c59c3" id="r_ac4e63936a25c68e274e679cff60c59c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e63936a25c68e274e679cff60c59c3">Socket</a> ()</td></tr>
<tr class="memdesc:ac4e63936a25c68e274e679cff60c59c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is not bound to a socket descriptor.  <br /></td></tr>
<tr class="separator:ac4e63936a25c68e274e679cff60c59c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b9d55dfb3163f72c8788caff1a7cf1" id="r_ae4b9d55dfb3163f72c8788caff1a7cf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4b9d55dfb3163f72c8788caff1a7cf1">Socket</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#af395a3acb64247117d47181425e02e19">AddressFamily</a> addressFamily, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22">SocketType</a> socketType, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a07f3d621b4627a07bc6a6e36b0d53eb5">ProtocolType</a> protocolType)</td></tr>
<tr class="memdesc:ae4b9d55dfb3163f72c8788caff1a7cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is bound to a specific transport service provider.  <br /></td></tr>
<tr class="separator:ae4b9d55dfb3163f72c8788caff1a7cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366082282f20cfb9c338ec5db35531bd" id="r_a366082282f20cfb9c338ec5db35531bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a366082282f20cfb9c338ec5db35531bd">Socket</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#af395a3acb64247117d47181425e02e19">AddressFamily</a> addressFamily, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22">SocketType</a> socketType, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a07f3d621b4627a07bc6a6e36b0d53eb5">ProtocolType</a> protocolType, const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_protocol_info.html">ProtocolInfo</a> &amp;protocolInfo, GROUP group, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">Flags</a> flags)</td></tr>
<tr class="memdesc:a366082282f20cfb9c338ec5db35531bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is bound to a specific transport service provider.  <br /></td></tr>
<tr class="separator:a366082282f20cfb9c338ec5db35531bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e14334fdc70d15361ae16a2179ca54" id="r_a66e14334fdc70d15361ae16a2179ca54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66e14334fdc70d15361ae16a2179ca54">Socket</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#af395a3acb64247117d47181425e02e19">AddressFamily</a> addressFamily, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22">SocketType</a> socketType, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a07f3d621b4627a07bc6a6e36b0d53eb5">ProtocolType</a> protocolType, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">Flags</a> flags)</td></tr>
<tr class="memdesc:a66e14334fdc70d15361ae16a2179ca54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is bound to a specific transport service provider.  <br /></td></tr>
<tr class="separator:a66e14334fdc70d15361ae16a2179ca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a44fde34388ac99b2f3d7630f73f18" id="r_a29a44fde34388ac99b2f3d7630f73f18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29a44fde34388ac99b2f3d7630f73f18">Socket</a> (const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a29a44fde34388ac99b2f3d7630f73f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy constructor.  <br /></td></tr>
<tr class="separator:a29a44fde34388ac99b2f3d7630f73f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdf1080a5501232603eca39b02f4b49" id="r_a9bdf1080a5501232603eca39b02f4b49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bdf1080a5501232603eca39b02f4b49">Socket</a> (<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a9bdf1080a5501232603eca39b02f4b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object, taking ownership of the socket descriptor of the argument <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object.  <br /></td></tr>
<tr class="separator:a9bdf1080a5501232603eca39b02f4b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33236c593f282a934d41e12059ef4769" id="r_a33236c593f282a934d41e12059ef4769"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33236c593f282a934d41e12059ef4769">~Socket</a> ()</td></tr>
<tr class="separator:a33236c593f282a934d41e12059ef4769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7e76db1e83362397013ffcc0662e5d" id="r_abc7e76db1e83362397013ffcc0662e5d"><td class="memItemLeft" align="right" valign="top">SOCKET&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc7e76db1e83362397013ffcc0662e5d">Detach</a> ()</td></tr>
<tr class="separator:abc7e76db1e83362397013ffcc0662e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761c899a557a94a99084c97ed1f38f03" id="r_a761c899a557a94a99084c97ed1f38f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a761c899a557a94a99084c97ed1f38f03">operator=</a> (const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a761c899a557a94a99084c97ed1f38f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy assignment allowed.  <br /></td></tr>
<tr class="separator:a761c899a557a94a99084c97ed1f38f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1870523a42e2b62abad77a06634e276e" id="r_a1870523a42e2b62abad77a06634e276e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1870523a42e2b62abad77a06634e276e">operator=</a> (<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a1870523a42e2b62abad77a06634e276e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of the socket descriptor of the argument <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object.  <br /></td></tr>
<tr class="separator:a1870523a42e2b62abad77a06634e276e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8223e6c6f0aa2404a15d128522a1a38" id="r_af8223e6c6f0aa2404a15d128522a1a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8223e6c6f0aa2404a15d128522a1a38">Close</a> () noexcept</td></tr>
<tr class="memdesc:af8223e6c6f0aa2404a15d128522a1a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the socket descriptor.  <br /></td></tr>
<tr class="separator:af8223e6c6f0aa2404a15d128522a1a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3a17c5c2324de7f37b005d0c5d53f1" id="r_a6d3a17c5c2324de7f37b005d0c5d53f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d3a17c5c2324de7f37b005d0c5d53f1">Open</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#af395a3acb64247117d47181425e02e19">AddressFamily</a> addressFamily, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22">SocketType</a> socketType, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a07f3d621b4627a07bc6a6e36b0d53eb5">ProtocolType</a> protocolType, LPWSAPROTOCOL_INFOW protocolInfo, GROUP group, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">Flags</a> flags=Flags::None)</td></tr>
<tr class="separator:a6d3a17c5c2324de7f37b005d0c5d53f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4abcde5558694707128b10c45bd632" id="r_a0c4abcde5558694707128b10c45bd632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c4abcde5558694707128b10c45bd632">Open</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#af395a3acb64247117d47181425e02e19">AddressFamily</a> addressFamily, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22">SocketType</a> socketType, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a07f3d621b4627a07bc6a6e36b0d53eb5">ProtocolType</a> protocolType, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">Flags</a> flags=Flags::None)</td></tr>
<tr class="memdesc:a0c4abcde5558694707128b10c45bd632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a new socket descriptor for the <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is bound to a specific transport service provider.  <br /></td></tr>
<tr class="separator:a0c4abcde5558694707128b10c45bd632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f1dcede8edec0852f66876cd712485" id="r_ae6f1dcede8edec0852f66876cd712485"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6f1dcede8edec0852f66876cd712485">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:ae6f1dcede8edec0852f66876cd712485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the value for the socket handle/descriptor is not INVALID_SOCKET.  <br /></td></tr>
<tr class="separator:ae6f1dcede8edec0852f66876cd712485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e41fcd09ba86f697cd5b423a24fc767" id="r_a7e41fcd09ba86f697cd5b423a24fc767"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e41fcd09ba86f697cd5b423a24fc767">IsValid</a> () const noexcept</td></tr>
<tr class="memdesc:a7e41fcd09ba86f697cd5b423a24fc767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the value for the socket handle/descriptor is not INVALID_SOCKET.  <br /></td></tr>
<tr class="separator:a7e41fcd09ba86f697cd5b423a24fc767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd8cda5a773596eb48e294d5a638465" id="r_a3cd8cda5a773596eb48e294d5a638465"><td class="memItemLeft" align="right" valign="top">constexpr SOCKET&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cd8cda5a773596eb48e294d5a638465">Handle</a> () const</td></tr>
<tr class="memdesc:a3cd8cda5a773596eb48e294d5a638465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value for the socket handle/descriptor.  <br /></td></tr>
<tr class="separator:a3cd8cda5a773596eb48e294d5a638465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ef273cd75a205e1a48850c8d27dad9" id="r_aa1ef273cd75a205e1a48850c8d27dad9"><td class="memTemplParams" colspan="2">template&lt;typename ConnectionSocketT &gt; <br />
requires std::is_base_of_v&lt;<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Sockets::Socket</a>,ConnectionSocketT&gt;</td></tr>
<tr class="memitem:aa1ef273cd75a205e1a48850c8d27dad9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa1ef273cd75a205e1a48850c8d27dad9">Accept</a> (sockaddr *address, int *addressLength, ConnectionSocketT &amp;result) const</td></tr>
<tr class="separator:aa1ef273cd75a205e1a48850c8d27dad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332b190aceefc247d556df62b312665f" id="r_a332b190aceefc247d556df62b312665f"><td class="memTemplParams" colspan="2">template&lt;typename ConnectionSocketT &gt; <br />
requires std::is_base_of_v&lt;<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Sockets::Socket</a>, ConnectionSocketT&gt;</td></tr>
<tr class="memitem:a332b190aceefc247d556df62b312665f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a332b190aceefc247d556df62b312665f">Accept</a> (<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;address, ConnectionSocketT &amp;result) const</td></tr>
<tr class="separator:a332b190aceefc247d556df62b312665f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b136d438fc042c1e57cc69c84e51346" id="r_a2b136d438fc042c1e57cc69c84e51346"><td class="memTemplParams" colspan="2">template&lt;typename ConnectionSocketT &gt; <br />
requires std::is_base_of_v&lt;<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Sockets::Socket</a>, ConnectionSocketT&gt;</td></tr>
<tr class="memitem:a2b136d438fc042c1e57cc69c84e51346"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b136d438fc042c1e57cc69c84e51346">Accept</a> (ConnectionSocketT &amp;result) const</td></tr>
<tr class="separator:a2b136d438fc042c1e57cc69c84e51346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98103015fedc455bef0cfc5dbbceb143" id="r_a98103015fedc455bef0cfc5dbbceb143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98103015fedc455bef0cfc5dbbceb143">Accept</a> (<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;address) const</td></tr>
<tr class="memdesc:a98103015fedc455bef0cfc5dbbceb143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permits an incoming connection attempt on a socket.  <br /></td></tr>
<tr class="separator:a98103015fedc455bef0cfc5dbbceb143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13218ff19f1642b91644d207399b1a45" id="r_a13218ff19f1642b91644d207399b1a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13218ff19f1642b91644d207399b1a45">Accept</a> () const</td></tr>
<tr class="memdesc:a13218ff19f1642b91644d207399b1a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permits an incoming connection attempt on a socket.  <br /></td></tr>
<tr class="separator:a13218ff19f1642b91644d207399b1a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9681b65c77227f1eef251ae70c76d4" id="r_a5b9681b65c77227f1eef251ae70c76d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b9681b65c77227f1eef251ae70c76d4">Accept</a> (LPCONDITIONPROC conditionFunction, ULONG_PTR callbackData, sockaddr *address, int *addressLength, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;result) const</td></tr>
<tr class="separator:a5b9681b65c77227f1eef251ae70c76d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19369cbdf6e91dd74b3034e1cc619a45" id="r_a19369cbdf6e91dd74b3034e1cc619a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19369cbdf6e91dd74b3034e1cc619a45">Accept</a> (LPCONDITIONPROC conditionFunction, ULONG_PTR callbackData, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;address, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;result) const</td></tr>
<tr class="separator:a19369cbdf6e91dd74b3034e1cc619a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fef1cbd9790094c58929cba5cd9d59" id="r_ab7fef1cbd9790094c58929cba5cd9d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7fef1cbd9790094c58929cba5cd9d59">Accept</a> (LPCONDITIONPROC conditionFunction, ULONG_PTR callbackData, sockaddr *addr=nullptr, int *addrlen=nullptr) const</td></tr>
<tr class="memdesc:ab7fef1cbd9790094c58929cba5cd9d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally accepts a connection based on the return value of a condition function, provides quality of service flow specifications, and allows the transfer of connection data.  <br /></td></tr>
<tr class="separator:ab7fef1cbd9790094c58929cba5cd9d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227294022f3a9aa7e6bd91850151d129" id="r_a227294022f3a9aa7e6bd91850151d129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a227294022f3a9aa7e6bd91850151d129">Accept</a> (LPCONDITIONPROC conditionFunction, ULONG_PTR callbackData, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;address) const</td></tr>
<tr class="separator:a227294022f3a9aa7e6bd91850151d129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6700160212b044611f00803997852f" id="r_a8d6700160212b044611f00803997852f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d6700160212b044611f00803997852f">ConnectEx</a> (const sockaddr *name, int namelen, PVOID sendBuffer, DWORD sendDataLength, LPDWORD bytesSent, OVERLAPPED *overlapped) const</td></tr>
<tr class="separator:a8d6700160212b044611f00803997852f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbe7439f72f50caa1cbc8d55131d678" id="r_afdbe7439f72f50caa1cbc8d55131d678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdbe7439f72f50caa1cbc8d55131d678">AcceptEx</a> (const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;acceptSocket, PVOID outputBuffer, DWORD receiveDataLength, DWORD localAddressLength, DWORD remoteAddressLength, DWORD *bytesReceived, OVERLAPPED *overlapped) const</td></tr>
<tr class="separator:afdbe7439f72f50caa1cbc8d55131d678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4800881a438b1be24fee0dd0d612829" id="r_ad4800881a438b1be24fee0dd0d612829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4800881a438b1be24fee0dd0d612829">GetAcceptExSockaddrs</a> (const <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#af82811a69582d9f85a78627741d07b19">Byte</a> *outputBuffer, DWORD receiveDataLength, DWORD localAddressLength, DWORD remoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength) const</td></tr>
<tr class="separator:ad4800881a438b1be24fee0dd0d612829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f038af72da5ef9879620cc66d9eb44" id="r_a29f038af72da5ef9879620cc66d9eb44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29f038af72da5ef9879620cc66d9eb44">DisconnectEx</a> (OVERLAPPED *overlapped, bool reuse) const</td></tr>
<tr class="separator:a29f038af72da5ef9879620cc66d9eb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fa5968bb7e499e989a397db3d1e966" id="r_a21fa5968bb7e499e989a397db3d1e966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21fa5968bb7e499e989a397db3d1e966">Disconnect</a> (bool reuse=false) const</td></tr>
<tr class="separator:a21fa5968bb7e499e989a397db3d1e966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0f68b4debeab98c83b5064da278a1a" id="r_ada0f68b4debeab98c83b5064da278a1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada0f68b4debeab98c83b5064da278a1a">Bind</a> (const sockaddr *addr, int addrlen) const</td></tr>
<tr class="memdesc:ada0f68b4debeab98c83b5064da278a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates a local address with a socket.  <br /></td></tr>
<tr class="separator:ada0f68b4debeab98c83b5064da278a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32eaa76fbcd99e2c9b4daf6a3ed1afd" id="r_ac32eaa76fbcd99e2c9b4daf6a3ed1afd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac32eaa76fbcd99e2c9b4daf6a3ed1afd">Bind</a> (const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;address) const</td></tr>
<tr class="separator:ac32eaa76fbcd99e2c9b4daf6a3ed1afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e51c94172ca0c3b9565e7d918df0509" id="r_a0e51c94172ca0c3b9565e7d918df0509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e51c94172ca0c3b9565e7d918df0509">Bind</a> (const wchar_t *address, <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a16d9ed304994b417f1b60c1431408c7e">UInt16</a> port) const</td></tr>
<tr class="separator:a0e51c94172ca0c3b9565e7d918df0509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a08dfe8d674c1f2617269b91717832" id="r_a02a08dfe8d674c1f2617269b91717832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02a08dfe8d674c1f2617269b91717832">Bind</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a16d9ed304994b417f1b60c1431408c7e">UInt16</a> port) const</td></tr>
<tr class="separator:a02a08dfe8d674c1f2617269b91717832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02720ca29ea0e5a65ba82e568a2a4606" id="r_a02720ca29ea0e5a65ba82e568a2a4606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02720ca29ea0e5a65ba82e568a2a4606">Connect</a> (const sockaddr *addr, int addrLength) const</td></tr>
<tr class="memdesc:a02720ca29ea0e5a65ba82e568a2a4606"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>Connect</code> function establishes a connection to a specified socket.  <br /></td></tr>
<tr class="separator:a02720ca29ea0e5a65ba82e568a2a4606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ea8123e2202d772096cc6f519a50d5" id="r_ab7ea8123e2202d772096cc6f519a50d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7ea8123e2202d772096cc6f519a50d5">Connect</a> (const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;address) const</td></tr>
<tr class="separator:ab7ea8123e2202d772096cc6f519a50d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380c314e851ee965704dabb7c00e9904" id="r_a380c314e851ee965704dabb7c00e9904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a380c314e851ee965704dabb7c00e9904">Connect</a> (const sockaddr *addr, int addrLength, WSABUF *callerData, WSABUF *calleeData, QOS *SQOS, QOS *GQOS=nullptr) const</td></tr>
<tr class="memdesc:a380c314e851ee965704dabb7c00e9904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a connection to another socket application, exchanges connect data, and specifies required quality of service based on the specified FLOWSPEC structure.  <br /></td></tr>
<tr class="separator:a380c314e851ee965704dabb7c00e9904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771d829c9b38a2c49c69bb85b7b7da90" id="r_a771d829c9b38a2c49c69bb85b7b7da90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a771d829c9b38a2c49c69bb85b7b7da90">Connect</a> (const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;address, WSABUF *callerData, WSABUF *calleeData, QOS *SQOS, QOS *GQOS=nullptr) const</td></tr>
<tr class="separator:a771d829c9b38a2c49c69bb85b7b7da90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac782bb0c802a7111f875d07875d56602" id="r_ac782bb0c802a7111f875d07875d56602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac782bb0c802a7111f875d07875d56602">ConnectByList</a> (SOCKET_ADDRESS_LIST *socketAddresses, DWORD *localAddressLength, SOCKADDR *localAddress, DWORD *remoteAddressLength, SOCKADDR *remoteAddress, const timeval *timeout=nullptr, OVERLAPPED *reserved=nullptr) const</td></tr>
<tr class="separator:ac782bb0c802a7111f875d07875d56602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3517ba543f5f9569570eac64f3180d" id="r_aef3517ba543f5f9569570eac64f3180d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef3517ba543f5f9569570eac64f3180d">ConnectByList</a> (SOCKET_ADDRESS_LIST *socketAddresses, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;localAddress, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;remoteAddress, const timeval *timeout=nullptr, OVERLAPPED *reserved=nullptr) const</td></tr>
<tr class="separator:aef3517ba543f5f9569570eac64f3180d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42573227572a5e90ab9ea9325d75a8f5" id="r_a42573227572a5e90ab9ea9325d75a8f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42573227572a5e90ab9ea9325d75a8f5">ConnectByName</a> (LPWSTR nodeName, LPWSTR serviceName, DWORD *localAddressLength, SOCKADDR *localAddress, DWORD *remoteAddressLength, SOCKADDR *remoteAddress, const timeval *timeout=nullptr, OVERLAPPED *reserved=nullptr) const</td></tr>
<tr class="separator:a42573227572a5e90ab9ea9325d75a8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbc2dde93f66e9c9be6e440c9a404c9" id="r_aadbc2dde93f66e9c9be6e440c9a404c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadbc2dde93f66e9c9be6e440c9a404c9">ConnectByName</a> (LPWSTR nodeName, LPWSTR serviceName, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;localAddress, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;remoteAddress, const timeval *timeout=nullptr, OVERLAPPED *reserved=nullptr) const</td></tr>
<tr class="separator:aadbc2dde93f66e9c9be6e440c9a404c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af725f24c80240d1f02dd9f036b9bc801" id="r_af725f24c80240d1f02dd9f036b9bc801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af725f24c80240d1f02dd9f036b9bc801">Duplicate</a> (DWORD processId, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_protocol_info.html">ProtocolInfo</a> &amp;protocolInfo) const</td></tr>
<tr class="separator:af725f24c80240d1f02dd9f036b9bc801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea3d7563121267410575262a53f209e" id="r_acea3d7563121267410575262a53f209e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acea3d7563121267410575262a53f209e">EnumNetworkEvents</a> (WSANETWORKEVENTS *networkEvents, HANDLE eventHandle=0) const</td></tr>
<tr class="memdesc:acea3d7563121267410575262a53f209e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discovers occurrences of network events for the socket, clears internal network event records, and, optionally, reset the event object.  <br /></td></tr>
<tr class="separator:acea3d7563121267410575262a53f209e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67852d3632795b130a45599e9d27770" id="r_ae67852d3632795b130a45599e9d27770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae67852d3632795b130a45599e9d27770">EventSelect</a> (HANDLE eventHandle, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#ab376983270b3970dadc0da1ab35deac8">EventFlags</a> networkEvents) const</td></tr>
<tr class="separator:ae67852d3632795b130a45599e9d27770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875a37eb479b40a5caec19b2e5911736" id="r_a875a37eb479b40a5caec19b2e5911736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a875a37eb479b40a5caec19b2e5911736">Listen</a> (int backlog=SOMAXCONN) const</td></tr>
<tr class="separator:a875a37eb479b40a5caec19b2e5911736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0b07cb8ee5ce027a8057b4de210af" id="r_ac1d0b07cb8ee5ce027a8057b4de210af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1d0b07cb8ee5ce027a8057b4de210af">Shutdown</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a598b7c0e2b0e2e532909ac8dc0e05d5c">ShutdownFlag</a> flag) const</td></tr>
<tr class="separator:ac1d0b07cb8ee5ce027a8057b4de210af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa71297f6f0d7f2321388b4ea946eff" id="r_abfa71297f6f0d7f2321388b4ea946eff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfa71297f6f0d7f2321388b4ea946eff">JoinLeaf</a> (const sockaddr *name, int namelen, WSABUF *callerData, WSABUF *calleeData, QOS *SQOS, QOS *GQOS, DWORD flags, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;result) const</td></tr>
<tr class="separator:abfa71297f6f0d7f2321388b4ea946eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67650068454d6c813d4637ded2a8e1cb" id="r_a67650068454d6c813d4637ded2a8e1cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67650068454d6c813d4637ded2a8e1cb">JoinLeaf</a> (const sockaddr *name, int namelen, WSABUF *callerData, WSABUF *calleeData, QOS *SQOS, QOS *GQOS, DWORD flags) const</td></tr>
<tr class="separator:a67650068454d6c813d4637ded2a8e1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13075039e19f60276c7b2addf9c06388" id="r_a13075039e19f60276c7b2addf9c06388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13075039e19f60276c7b2addf9c06388">Ioctl</a> (DWORD ioControlCode, void *inBuffer, DWORD inBufferSize, void *outBuffer, DWORD outBufferSize, DWORD *bytesReturned, OVERLAPPED *overlapped=nullptr, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine=nullptr) const</td></tr>
<tr class="separator:a13075039e19f60276c7b2addf9c06388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afc10153368f5295cbebeb79e7539d5" id="r_a4afc10153368f5295cbebeb79e7539d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4afc10153368f5295cbebeb79e7539d5">Ioctl</a> (long cmd, u_long *argp) const</td></tr>
<tr class="separator:a4afc10153368f5295cbebeb79e7539d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e194c25bba8448eab3ec266ddf29a9" id="r_a69e194c25bba8448eab3ec266ddf29a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69e194c25bba8448eab3ec266ddf29a9">PeerName</a> (<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;remoteAddress) const</td></tr>
<tr class="separator:a69e194c25bba8448eab3ec266ddf29a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28af889cc3a8a7ebbf4d26931706198" id="r_aa28af889cc3a8a7ebbf4d26931706198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa28af889cc3a8a7ebbf4d26931706198">PeerName</a> () const</td></tr>
<tr class="separator:aa28af889cc3a8a7ebbf4d26931706198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7470f0cbefdd415cb61a938165ae46" id="r_acd7470f0cbefdd415cb61a938165ae46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd7470f0cbefdd415cb61a938165ae46">Name</a> (<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;localAddress) const</td></tr>
<tr class="separator:acd7470f0cbefdd415cb61a938165ae46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f477a0a7def0a3fed16fe43c140a68" id="r_ad1f477a0a7def0a3fed16fe43c140a68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1f477a0a7def0a3fed16fe43c140a68">Name</a> () const</td></tr>
<tr class="separator:ad1f477a0a7def0a3fed16fe43c140a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d01751397d936de2908ff4ba4b9532d" id="r_a9d01751397d936de2908ff4ba4b9532d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d01751397d936de2908ff4ba4b9532d">GetOverlappedResult</a> (OVERLAPPED *overlapped, DWORD *numberOfBytesTransferred, bool wait, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *flags) const</td></tr>
<tr class="separator:a9d01751397d936de2908ff4ba4b9532d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9131f4354115395b67cc535f03872cb6" id="r_a9131f4354115395b67cc535f03872cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9131f4354115395b67cc535f03872cb6">Receive</a> (LPWSABUF buffers, DWORD bufferCount, LPDWORD numberOfBytesRecvd, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *flags, OVERLAPPED *overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine) const</td></tr>
<tr class="memdesc:a9131f4354115395b67cc535f03872cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives data from a connected socket or a bound connectionless socket.  <br /></td></tr>
<tr class="separator:a9131f4354115395b67cc535f03872cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a4a44633906fc5bce089fe2569b99b" id="r_a16a4a44633906fc5bce089fe2569b99b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16a4a44633906fc5bce089fe2569b99b">Receive</a> (LPWSABUF buffers, DWORD bufferCount, LPDWORD numberOfBytesRecvd, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *flags) const</td></tr>
<tr class="separator:a16a4a44633906fc5bce089fe2569b99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33bd465c14889cc8fe03d704ccb04e5" id="r_ae33bd465c14889cc8fe03d704ccb04e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae33bd465c14889cc8fe03d704ccb04e5">Receive</a> (LPWSABUF buffers, DWORD bufferCount, OVERLAPPED *overlapped, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags=<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a>, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine=nullptr) const</td></tr>
<tr class="separator:ae33bd465c14889cc8fe03d704ccb04e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34eff52687a8ae277dad540f891d30a" id="r_ae34eff52687a8ae277dad540f891d30a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae34eff52687a8ae277dad540f891d30a">Receive</a> (void *buffer, size_t numberOfBytesToRead, size_t *numberOfBytesReceived, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags) const</td></tr>
<tr class="separator:ae34eff52687a8ae277dad540f891d30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bd53c565130a8662546ea40b4b05da" id="r_a90bd53c565130a8662546ea40b4b05da"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90bd53c565130a8662546ea40b4b05da">Receive</a> (void *buffer, size_t numberOfBytesToRead, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags) const</td></tr>
<tr class="memdesc:a90bd53c565130a8662546ea40b4b05da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Receive function receives data from a connected socket or a bound connectionless socket.  <br /></td></tr>
<tr class="separator:a90bd53c565130a8662546ea40b4b05da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ca2b3dca5a30bcc95637dd0c8ed469" id="r_ad8ca2b3dca5a30bcc95637dd0c8ed469"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8ca2b3dca5a30bcc95637dd0c8ed469">Receive</a> (void *buffer, size_t numberOfBytesToRead) const</td></tr>
<tr class="separator:ad8ca2b3dca5a30bcc95637dd0c8ed469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7f7b794b05d0f1ac325022f388f87b" id="r_a3e7f7b794b05d0f1ac325022f388f87b"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e7f7b794b05d0f1ac325022f388f87b">Receive</a> (void *buffer, size_t bufferSize, size_t minimumNumberOfBytesToRead) const</td></tr>
<tr class="separator:a3e7f7b794b05d0f1ac325022f388f87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581663117e37f9401a29e0bda59b5b4d" id="r_a581663117e37f9401a29e0bda59b5b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a581663117e37f9401a29e0bda59b5b4d">ReceiveFrom</a> (WSABUF *buffers, DWORD bufferCount, DWORD *numberOfBytesRecvd, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *flags, sockaddr *fromAddress, int *fromAddressLength, OVERLAPPED *overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine) const</td></tr>
<tr class="separator:a581663117e37f9401a29e0bda59b5b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad29d00e445a8997ea865145b292efec" id="r_aad29d00e445a8997ea865145b292efec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad29d00e445a8997ea865145b292efec">ReceiveFrom</a> (WSABUF *buffers, DWORD bufferCount, DWORD *numberOfBytesRecvd, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *flags, sockaddr *fromAddress, int *fromAddressLength) const</td></tr>
<tr class="separator:aad29d00e445a8997ea865145b292efec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627cfccbfd035091ba2aefb3d0db4726" id="r_a627cfccbfd035091ba2aefb3d0db4726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a627cfccbfd035091ba2aefb3d0db4726">ReceiveFrom</a> (WSABUF *buffers, DWORD bufferCount, DWORD *numberOfBytesRecvd, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *flags, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;fromAddress) const</td></tr>
<tr class="separator:a627cfccbfd035091ba2aefb3d0db4726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4870c22e623ef67725dbd9bbcb5b7fa8" id="r_a4870c22e623ef67725dbd9bbcb5b7fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4870c22e623ef67725dbd9bbcb5b7fa8">ReceiveFrom</a> (WSABUF *buffers, DWORD bufferCount, OVERLAPPED *overlapped, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *flags, sockaddr *fromAddress, int *fromAddressLength, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine=nullptr) const</td></tr>
<tr class="separator:a4870c22e623ef67725dbd9bbcb5b7fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6508ff098fcbaac4555f9be6a7c5341b" id="r_a6508ff098fcbaac4555f9be6a7c5341b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6508ff098fcbaac4555f9be6a7c5341b">ReceiveFrom</a> (WSABUF *buffers, DWORD bufferCount, OVERLAPPED *overlapped, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *flags, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;fromAddress, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine=nullptr) const</td></tr>
<tr class="separator:a6508ff098fcbaac4555f9be6a7c5341b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41912c908db84ac8152e25c68d3ba7b" id="r_af41912c908db84ac8152e25c68d3ba7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af41912c908db84ac8152e25c68d3ba7b">ReceiveFrom</a> (void *buffer, size_t bufferSize, size_t *numberOfBytesRecvd, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags=<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a>, sockaddr *fromAddress=nullptr, int *fromAddressLength=nullptr) const</td></tr>
<tr class="separator:af41912c908db84ac8152e25c68d3ba7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23945ef27a6c59db04145b0118092c64" id="r_a23945ef27a6c59db04145b0118092c64"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23945ef27a6c59db04145b0118092c64">ReceiveFrom</a> (void *buffer, size_t bufferSize, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags=<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a>, sockaddr *fromAddress=nullptr, int *fromAddressLength=nullptr) const</td></tr>
<tr class="separator:a23945ef27a6c59db04145b0118092c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ef718aa63e4fb03ea49a3a24b35d97" id="r_af0ef718aa63e4fb03ea49a3a24b35d97"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0ef718aa63e4fb03ea49a3a24b35d97">ReceiveFrom</a> (void *buffer, size_t bufferSize, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;from) const</td></tr>
<tr class="separator:af0ef718aa63e4fb03ea49a3a24b35d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d3b8dc443e3f846f341cd1ec4cadcd" id="r_a99d3b8dc443e3f846f341cd1ec4cadcd"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99d3b8dc443e3f846f341cd1ec4cadcd">ReceiveFrom</a> (void *buffer, size_t bufferSize, <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;from) const</td></tr>
<tr class="separator:a99d3b8dc443e3f846f341cd1ec4cadcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cdf12bc67f4faddc26aa143ca1722a" id="r_a25cdf12bc67f4faddc26aa143ca1722a"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25cdf12bc67f4faddc26aa143ca1722a">Send</a> (const void *buffer, size_t numberOfBytesToSend, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags) const</td></tr>
<tr class="separator:a25cdf12bc67f4faddc26aa143ca1722a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6c6ddcc435da602b8e54a798c695a6" id="r_a3e6c6ddcc435da602b8e54a798c695a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e6c6ddcc435da602b8e54a798c695a6">Send</a> (LPWSABUF buffers, DWORD bufferCount, LPDWORD numberOfBytesSent, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine) const</td></tr>
<tr class="separator:a3e6c6ddcc435da602b8e54a798c695a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee30e90743ccf63f3169003cc68cb5c" id="r_afee30e90743ccf63f3169003cc68cb5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afee30e90743ccf63f3169003cc68cb5c">Send</a> (LPWSABUF buffers, DWORD bufferCount, LPDWORD numberOfBytesSent, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags=<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a>) const</td></tr>
<tr class="separator:afee30e90743ccf63f3169003cc68cb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc929d757f713a01ee9326a55ceba1a" id="r_a1fc929d757f713a01ee9326a55ceba1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fc929d757f713a01ee9326a55ceba1a">Send</a> (LPWSABUF buffers, DWORD bufferCount, LPWSAOVERLAPPED overlapped, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags=<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a>, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine=nullptr) const</td></tr>
<tr class="separator:a1fc929d757f713a01ee9326a55ceba1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1d557aac132c6ad215dbe6c80fb2b2" id="r_a3b1d557aac132c6ad215dbe6c80fb2b2"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1d557aac132c6ad215dbe6c80fb2b2">SendTo</a> (const void *buffer, size_t numberOfBytesToSend, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags=<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a>, const sockaddr *destinationAddress=nullptr, int destinationAddressSize=0) const</td></tr>
<tr class="separator:a3b1d557aac132c6ad215dbe6c80fb2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36458f3e13faf23e1fbee1eb0f9354c9" id="r_a36458f3e13faf23e1fbee1eb0f9354c9"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36458f3e13faf23e1fbee1eb0f9354c9">SendTo</a> (const void *buffer, size_t numberOfBytesToSend, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags, const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;destinationAddress) const</td></tr>
<tr class="separator:a36458f3e13faf23e1fbee1eb0f9354c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313c459544cf971a93d11d11decedbe1" id="r_a313c459544cf971a93d11d11decedbe1"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a313c459544cf971a93d11d11decedbe1">SendTo</a> (const void *buffer, size_t numberOfBytesToSend, const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;destinationAddress) const</td></tr>
<tr class="separator:a313c459544cf971a93d11d11decedbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89ceb189c0e269c7f937923382ed853" id="r_ae89ceb189c0e269c7f937923382ed853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae89ceb189c0e269c7f937923382ed853">SendTo</a> (WSABUF *buffers, DWORD bufferCount, DWORD *numberOfBytesSent, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags, const sockaddr *destinationAddress, int destinationAddressLength, OVERLAPPED *overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine) const</td></tr>
<tr class="separator:ae89ceb189c0e269c7f937923382ed853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac147cc0d7412dd1c1a7ec9df75b4eb31" id="r_ac147cc0d7412dd1c1a7ec9df75b4eb31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac147cc0d7412dd1c1a7ec9df75b4eb31">SendTo</a> (WSABUF *buffers, DWORD bufferCount, DWORD *numberOfBytesSent, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags, const sockaddr *destinationAddress, int destinationAddressLength) const</td></tr>
<tr class="separator:ac147cc0d7412dd1c1a7ec9df75b4eb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2e65a0e59717e876d4418ae4e986e3" id="r_a4e2e65a0e59717e876d4418ae4e986e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e2e65a0e59717e876d4418ae4e986e3">SendTo</a> (WSABUF *buffers, DWORD bufferCount, OVERLAPPED *overlapped, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> flags, const sockaddr *destinationAddress, int destinationAddressLength, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine=nullptr) const</td></tr>
<tr class="separator:a4e2e65a0e59717e876d4418ae4e986e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8869e38501a8688d970fa073f6756564" id="r_a8869e38501a8688d970fa073f6756564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8869e38501a8688d970fa073f6756564">SetSocketOption</a> (int level, int option, const void *optionData, int optionDataLength) const</td></tr>
<tr class="memdesc:a8869e38501a8688d970fa073f6756564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a socket option.  <br /></td></tr>
<tr class="separator:a8869e38501a8688d970fa073f6756564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69439ee5c3fe9ac23589ba759350892d" id="r_a69439ee5c3fe9ac23589ba759350892d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69439ee5c3fe9ac23589ba759350892d">SetSocketOption</a> (int level, int option, <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#aa879caba763494ad2c3cd321ce4bbdda">Int32</a> value) const</td></tr>
<tr class="memdesc:a69439ee5c3fe9ac23589ba759350892d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a socket option.  <br /></td></tr>
<tr class="separator:a69439ee5c3fe9ac23589ba759350892d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1008a88aa27137cb93779f5afac0f033" id="r_a1008a88aa27137cb93779f5afac0f033"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1008a88aa27137cb93779f5afac0f033">SetSocketOption</a> (int level, int option, <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> value) const</td></tr>
<tr class="memdesc:a1008a88aa27137cb93779f5afac0f033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a socket option.  <br /></td></tr>
<tr class="separator:a1008a88aa27137cb93779f5afac0f033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0a8a5cc67ea0d08e7b630947f1768a" id="r_a2a0a8a5cc67ea0d08e7b630947f1768a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a0a8a5cc67ea0d08e7b630947f1768a">GetSocketOption</a> (int level, int option, void *optionData, int *optionDataLength) const</td></tr>
<tr class="memdesc:a2a0a8a5cc67ea0d08e7b630947f1768a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a socket option.  <br /></td></tr>
<tr class="separator:a2a0a8a5cc67ea0d08e7b630947f1768a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedf4409a1bdc9fcb4edd58ff796c10f" id="r_acedf4409a1bdc9fcb4edd58ff796c10f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acedf4409a1bdc9fcb4edd58ff796c10f">IsConnected</a> () const</td></tr>
<tr class="separator:acedf4409a1bdc9fcb4edd58ff796c10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb10903a50fa37e5fa7c18d830d07bb" id="r_afdb10903a50fa37e5fa7c18d830d07bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdb10903a50fa37e5fa7c18d830d07bb">UpdateAcceptContext</a> (const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;listenerSocket) const</td></tr>
<tr class="memdesc:afdb10903a50fa37e5fa7c18d830d07bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used with the AcceptEx function. This option updates the properties of the socket which are inherited from the listening socket. This function should be called if the PeerName, Name, GetSocketOption, or SetSocketOption functions are to be used on the accepted socket.  <br /></td></tr>
<tr class="separator:afdb10903a50fa37e5fa7c18d830d07bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98d02ec32de7375f1186d11487804b5" id="r_ad98d02ec32de7375f1186d11487804b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#aa879caba763494ad2c3cd321ce4bbdda">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad98d02ec32de7375f1186d11487804b5">GetInt32Option</a> (int level, int option) const</td></tr>
<tr class="separator:ad98d02ec32de7375f1186d11487804b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b26aa7a69eb913b80ccd5d9851735d" id="r_a41b26aa7a69eb913b80ccd5d9851735d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41b26aa7a69eb913b80ccd5d9851735d">GetUInt32Option</a> (int level, int option) const</td></tr>
<tr class="separator:a41b26aa7a69eb913b80ccd5d9851735d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f89821e6aa425a53be2b7205a3c36e" id="r_ac3f89821e6aa425a53be2b7205a3c36e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3f89821e6aa425a53be2b7205a3c36e">AcceptsConnections</a> () const</td></tr>
<tr class="separator:ac3f89821e6aa425a53be2b7205a3c36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b09c055bb877d7571ce458c0018c46" id="r_a07b09c055bb877d7571ce458c0018c46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07b09c055bb877d7571ce458c0018c46">IsListening</a> () const</td></tr>
<tr class="separator:a07b09c055bb877d7571ce458c0018c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dc8fed3258112cb48cb0fb4be046b8" id="r_a21dc8fed3258112cb48cb0fb4be046b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21dc8fed3258112cb48cb0fb4be046b8">Broadcast</a> () const</td></tr>
<tr class="separator:a21dc8fed3258112cb48cb0fb4be046b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd72b3aa2315d4ad6fe90df2f4e010d" id="r_addd72b3aa2315d4ad6fe90df2f4e010d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addd72b3aa2315d4ad6fe90df2f4e010d">SetBroadcast</a> (bool broadcast=true) const</td></tr>
<tr class="separator:addd72b3aa2315d4ad6fe90df2f4e010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fb05246aaf6441bd0eb1402dd5b554" id="r_a06fb05246aaf6441bd0eb1402dd5b554"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06fb05246aaf6441bd0eb1402dd5b554">ConditionalAccept</a> () const</td></tr>
<tr class="memdesc:a06fb05246aaf6441bd0eb1402dd5b554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the socket is configured to pass incoming connect request to the application, or let the protocol stack handle the requests.  <br /></td></tr>
<tr class="separator:a06fb05246aaf6441bd0eb1402dd5b554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e68d5fb8922ed78024ee9e8b85c783" id="r_ac3e68d5fb8922ed78024ee9e8b85c783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3e68d5fb8922ed78024ee9e8b85c783">SetConditionalAccept</a> (bool conditionalAccept) const</td></tr>
<tr class="separator:ac3e68d5fb8922ed78024ee9e8b85c783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6f18e693cc504babf357148edabe60" id="r_a1c6f18e693cc504babf357148edabe60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c6f18e693cc504babf357148edabe60">Debug</a> () const</td></tr>
<tr class="separator:a1c6f18e693cc504babf357148edabe60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd90160e7e62ae319007143f1aa0d90" id="r_aedd90160e7e62ae319007143f1aa0d90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedd90160e7e62ae319007143f1aa0d90">SetDebug</a> (bool debug) const</td></tr>
<tr class="separator:aedd90160e7e62ae319007143f1aa0d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d8a40ad47426121060b8e1520e69e6" id="r_a38d8a40ad47426121060b8e1520e69e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38d8a40ad47426121060b8e1520e69e6">ConnectTimeInSeconds</a> () const</td></tr>
<tr class="separator:a38d8a40ad47426121060b8e1520e69e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652fba6449e2d5077fec2b8cc13b161f" id="r_a652fba6449e2d5077fec2b8cc13b161f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_time_span.html">TimeSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a652fba6449e2d5077fec2b8cc13b161f">ConnectTime</a> () const</td></tr>
<tr class="separator:a652fba6449e2d5077fec2b8cc13b161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad308f243421bbfce978d17310449cad0" id="r_ad308f243421bbfce978d17310449cad0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad308f243421bbfce978d17310449cad0">DontLinger</a> () const</td></tr>
<tr class="separator:ad308f243421bbfce978d17310449cad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1824c5e365222350d80ff14ca89b74d8" id="r_a1824c5e365222350d80ff14ca89b74d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1824c5e365222350d80ff14ca89b74d8">SetDontLinger</a> (bool dontLinger) const</td></tr>
<tr class="separator:a1824c5e365222350d80ff14ca89b74d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ed1a3a1305761f34911a02bf51983c" id="r_a21ed1a3a1305761f34911a02bf51983c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_linger.html">Sockets::Linger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21ed1a3a1305761f34911a02bf51983c">Linger</a> () const</td></tr>
<tr class="separator:a21ed1a3a1305761f34911a02bf51983c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2306c62344b1e7448408971aa27ec8" id="r_a2b2306c62344b1e7448408971aa27ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b2306c62344b1e7448408971aa27ec8">SetLinger</a> (const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_linger.html">Sockets::Linger</a> &amp;linger) const</td></tr>
<tr class="separator:a2b2306c62344b1e7448408971aa27ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719521b00ba6f6054511ccdaeb0d09f2" id="r_a719521b00ba6f6054511ccdaeb0d09f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a719521b00ba6f6054511ccdaeb0d09f2">SetLinger</a> (bool linger, <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a16d9ed304994b417f1b60c1431408c7e">UInt16</a> seconds) const</td></tr>
<tr class="separator:a719521b00ba6f6054511ccdaeb0d09f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac8147f608ad62403be4943f22c130" id="r_abbac8147f608ad62403be4943f22c130"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbac8147f608ad62403be4943f22c130">ErrorCode</a> () const</td></tr>
<tr class="separator:abbac8147f608ad62403be4943f22c130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7d3789085e52d6061f7e57e2e6f2be" id="r_a2e7d3789085e52d6061f7e57e2e6f2be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e7d3789085e52d6061f7e57e2e6f2be">SetReceiveTimeout</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> timeoutInMillis) const</td></tr>
<tr class="memdesc:a2e7d3789085e52d6061f7e57e2e6f2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timeout, in milliseconds, for blocking receive calls.  <br /></td></tr>
<tr class="separator:a2e7d3789085e52d6061f7e57e2e6f2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53c992215a7b6666ffa13fbd4f0a061" id="r_aa53c992215a7b6666ffa13fbd4f0a061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa53c992215a7b6666ffa13fbd4f0a061">ReceiveTimeout</a> () const</td></tr>
<tr class="separator:aa53c992215a7b6666ffa13fbd4f0a061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7535b8d36b76dd09ce1fb2996585d4" id="r_a4e7535b8d36b76dd09ce1fb2996585d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e7535b8d36b76dd09ce1fb2996585d4">SetSendTimeout</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> timeoutInMillis) const</td></tr>
<tr class="separator:a4e7535b8d36b76dd09ce1fb2996585d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dace19700d8bc9624e4686b40056a4" id="r_a04dace19700d8bc9624e4686b40056a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04dace19700d8bc9624e4686b40056a4">SendTimeout</a> () const</td></tr>
<tr class="separator:a04dace19700d8bc9624e4686b40056a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc38098219a56aed6b2425c96f164bdb" id="r_abc38098219a56aed6b2425c96f164bdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc38098219a56aed6b2425c96f164bdb">KeepAlive</a> () const</td></tr>
<tr class="separator:abc38098219a56aed6b2425c96f164bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205f1c2fed93ea4e2bda2c2afe08cea3" id="r_a205f1c2fed93ea4e2bda2c2afe08cea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a205f1c2fed93ea4e2bda2c2afe08cea3">SetKeepAlive</a> (bool keepAlive) const</td></tr>
<tr class="separator:a205f1c2fed93ea4e2bda2c2afe08cea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a7bb851cdb65983e2a089319d108b2" id="r_ac9a7bb851cdb65983e2a089319d108b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9a7bb851cdb65983e2a089319d108b2">SetSendBufferSize</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> sendBufferSize) const</td></tr>
<tr class="separator:ac9a7bb851cdb65983e2a089319d108b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae595886cdc9fc540b367fd5ac6849081" id="r_ae595886cdc9fc540b367fd5ac6849081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae595886cdc9fc540b367fd5ac6849081">SendBufferSize</a> () const</td></tr>
<tr class="separator:ae595886cdc9fc540b367fd5ac6849081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a6311ad9d6188996d7eafad7d4ef22" id="r_a06a6311ad9d6188996d7eafad7d4ef22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06a6311ad9d6188996d7eafad7d4ef22">SetReceiveBufferSize</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> receiveBufferSize) const</td></tr>
<tr class="separator:a06a6311ad9d6188996d7eafad7d4ef22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a394907beabd7d719805136cd0360e0" id="r_a8a394907beabd7d719805136cd0360e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a394907beabd7d719805136cd0360e0">ReceiveBufferSize</a> () const</td></tr>
<tr class="separator:a8a394907beabd7d719805136cd0360e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ef45b5d8d940a514652945f70a0bd2" id="r_a68ef45b5d8d940a514652945f70a0bd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68ef45b5d8d940a514652945f70a0bd2">NoDelay</a> () const</td></tr>
<tr class="separator:a68ef45b5d8d940a514652945f70a0bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06878b2cd22f756e4ca5d114e015d279" id="r_a06878b2cd22f756e4ca5d114e015d279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06878b2cd22f756e4ca5d114e015d279">SetNoDelay</a> (bool noDelay) const</td></tr>
<tr class="separator:a06878b2cd22f756e4ca5d114e015d279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8c6abac99666341e346417fdedfcd6" id="r_afc8c6abac99666341e346417fdedfcd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc8c6abac99666341e346417fdedfcd6">MaxMessageSize</a> () const</td></tr>
<tr class="memdesc:afc8c6abac99666341e346417fdedfcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum outbound message size for message-oriented sockets supported by the protocol. Has no meaning for stream-oriented sockets.  <br /></td></tr>
<tr class="separator:afc8c6abac99666341e346417fdedfcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34b3932da42cf60dd268227a1de80e0" id="r_aa34b3932da42cf60dd268227a1de80e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa34b3932da42cf60dd268227a1de80e0">GetProtocolInfo</a> (WSAPROTOCOL_INFOW *info) const</td></tr>
<tr class="separator:aa34b3932da42cf60dd268227a1de80e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62d59cd2e5e77b908af20ddba132185" id="r_ac62d59cd2e5e77b908af20ddba132185"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac62d59cd2e5e77b908af20ddba132185">Available</a> () const</td></tr>
<tr class="separator:ac62d59cd2e5e77b908af20ddba132185"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a76637c58a841b24a4c2bc9244a206ae7" id="r_a76637c58a841b24a4c2bc9244a206ae7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76637c58a841b24a4c2bc9244a206ae7">ThrowLastSocketError</a> ()</td></tr>
<tr class="separator:a76637c58a841b24a4c2bc9244a206ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe20a76be0e292d44b10c5898941af3" id="r_aebe20a76be0e292d44b10c5898941af3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebe20a76be0e292d44b10c5898941af3">ThrowLastSocketError</a> (const wchar_t *function, const wchar_t *filename, int lineNumber)</td></tr>
<tr class="separator:aebe20a76be0e292d44b10c5898941af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6be2adb3f198211a2676568a0d5031" id="r_a0b6be2adb3f198211a2676568a0d5031"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b6be2adb3f198211a2676568a0d5031">ThrowSocketError</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> error)</td></tr>
<tr class="separator:a0b6be2adb3f198211a2676568a0d5031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2de2f6cad54d46fb4c4ae3ba3f331f" id="r_a2d2de2f6cad54d46fb4c4ae3ba3f331f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d2de2f6cad54d46fb4c4ae3ba3f331f">ThrowSocketError</a> (<a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> error, const wchar_t *function, const wchar_t *filename, int lineNumber)</td></tr>
<tr class="separator:a2d2de2f6cad54d46fb4c4ae3ba3f331f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3824ccde7a4cc9333360f65996147602" id="r_a3824ccde7a4cc9333360f65996147602"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3824ccde7a4cc9333360f65996147602">LastSocketError</a> ()</td></tr>
<tr class="memdesc:a3824ccde7a4cc9333360f65996147602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error code for the last <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html">Sockets</a> operation that failed.  <br /></td></tr>
<tr class="separator:a3824ccde7a4cc9333360f65996147602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca1b924e50caea6beddc01b29df9992" id="r_acca1b924e50caea6beddc01b29df9992"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acca1b924e50caea6beddc01b29df9992">RecvMsg</a> (SOCKET s, LPWSAMSG msg, LPDWORD numberOfBytesRecvd, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine)</td></tr>
<tr class="separator:acca1b924e50caea6beddc01b29df9992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dccd4e54c3f98318bc9c1f421bbf29" id="r_a39dccd4e54c3f98318bc9c1f421bbf29"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39dccd4e54c3f98318bc9c1f421bbf29">SendMsg</a> (SOCKET s, LPWSAMSG msg, DWORD flags, LPDWORD numberOfBytesSent, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionRoutine)</td></tr>
<tr class="separator:a39dccd4e54c3f98318bc9c1f421bbf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4b0140ae629d9acd4ace5c16a6362f" id="r_a0d4b0140ae629d9acd4ace5c16a6362f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d4b0140ae629d9acd4ace5c16a6362f">Poll</a> (LPWSAPOLLFD fdarray, ULONG nfds, INT timeout, <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#aa879caba763494ad2c3cd321ce4bbdda">Int32</a> *result)</td></tr>
<tr class="separator:a0d4b0140ae629d9acd4ace5c16a6362f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453435b4328a488f6a68f04c547a7d4b" id="r_a453435b4328a488f6a68f04c547a7d4b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a453435b4328a488f6a68f04c547a7d4b">TransmitFile</a> (SOCKET hSocket, HANDLE hFile, DWORD numberOfBytesToWrite, DWORD numberOfBytesPerSend, LPOVERLAPPED overlapped, LPTRANSMIT_FILE_BUFFERS transmitBuffers, DWORD flags)</td></tr>
<tr class="separator:a453435b4328a488f6a68f04c547a7d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94499d43606238a086914af57d500fe" id="r_ac94499d43606238a086914af57d500fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac94499d43606238a086914af57d500fe">TransmitPackets</a> (SOCKET hSocket, LPTRANSMIT_PACKETS_ELEMENT packetArray, DWORD elementCount, DWORD sendSize, LPOVERLAPPED overlapped, DWORD flags)</td></tr>
<tr class="separator:ac94499d43606238a086914af57d500fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1aacb57336c402491df4c85f929834" id="r_a5a1aacb57336c402491df4c85f929834"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a1aacb57336c402491df4c85f929834">ConnectEx</a> (SOCKET socket, const sockaddr *name, int namelen, PVOID sendBuffer, DWORD sendDataLength, LPDWORD bytesSent, OVERLAPPED *overlapped)</td></tr>
<tr class="separator:a5a1aacb57336c402491df4c85f929834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b3916b08438ec6356a0f295f0ff69b" id="r_a45b3916b08438ec6356a0f295f0ff69b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45b3916b08438ec6356a0f295f0ff69b">AcceptEx</a> (SOCKET socket, SOCKET acceptSocket, PVOID outputBuffer, DWORD receiveDataLength, DWORD localAddressLength, DWORD remoteAddressLength, DWORD *bytesReceived, OVERLAPPED *overlapped)</td></tr>
<tr class="separator:a45b3916b08438ec6356a0f295f0ff69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc40321755396d17c5113145e3d2fcbb" id="r_adc40321755396d17c5113145e3d2fcbb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc40321755396d17c5113145e3d2fcbb">GetAcceptExSockaddrs</a> (SOCKET socket, const <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#af82811a69582d9f85a78627741d07b19">Byte</a> *outputBuffer, DWORD receiveDataLength, DWORD localAddressLength, DWORD remoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength)</td></tr>
<tr class="separator:adc40321755396d17c5113145e3d2fcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4f0865e04f24125923d4c9c55e00aa" id="r_aed4f0865e04f24125923d4c9c55e00aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_h_c_c_export_8h.html#afb06ae686742fde98e6427c4a1e2206c">HCC_EXPORT</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed4f0865e04f24125923d4c9c55e00aa">DisconnectEx</a> (SOCKET socket, OVERLAPPED *overlapped, bool reuse)</td></tr>
<tr class="separator:aed4f0865e04f24125923d4c9c55e00aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf51f49082f3d14930f4d612b5b3f8b" id="r_adcf51f49082f3d14930f4d612b5b3f8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcf51f49082f3d14930f4d612b5b3f8b">Select</a> (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const timeval *timeout, int *selectResult)</td></tr>
<tr class="separator:adcf51f49082f3d14930f4d612b5b3f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2c12f59c4b2a7211fb31eb24903a75" id="r_a6f2c12f59c4b2a7211fb31eb24903a75"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f2c12f59c4b2a7211fb31eb24903a75">Select</a> (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const timeval *timeout=nullptr)</td></tr>
<tr class="separator:a6f2c12f59c4b2a7211fb31eb24903a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079cab3b6b36107cff8a7b52f002b618" id="r_a079cab3b6b36107cff8a7b52f002b618"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a079cab3b6b36107cff8a7b52f002b618">UpdateAcceptContext</a> (SOCKET listenerSocketHandle, SOCKET acceptingSocketHandle)</td></tr>
<tr class="memdesc:a079cab3b6b36107cff8a7b52f002b618"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used with the AcceptEx function. This option updates the properties of the socket which are inherited from the listening socket. This function should be called if the PeerName, Name, GetSocketOption, or SetSocketOption functions are to be used on the accepted socket.  <br /></td></tr>
<tr class="separator:a079cab3b6b36107cff8a7b52f002b618"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8f4fdd13685ed97e02e353c739302b8e" id="r_a8f4fdd13685ed97e02e353c739302b8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f4fdd13685ed97e02e353c739302b8e">Socket</a> (SOCKET socket)</td></tr>
<tr class="separator:a8f4fdd13685ed97e02e353c739302b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b7c5d38942b460381fdb65681ff89b" id="r_aa4b7c5d38942b460381fdb65681ff89b"><td class="memItemLeft" align="right" valign="top">SOCKET&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4b7c5d38942b460381fdb65681ff89b">Release</a> ()</td></tr>
<tr class="separator:aa4b7c5d38942b460381fdb65681ff89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67f3016d484dc2bdb10553c830b241c" id="r_ad67f3016d484dc2bdb10553c830b241c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad67f3016d484dc2bdb10553c830b241c">ThrowIfSocketIsValid</a> (const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;socket) const</td></tr>
<tr class="separator:ad67f3016d484dc2bdb10553c830b241c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:adf10ea0a6364c48fb8faeef6776378cb" id="r_adf10ea0a6364c48fb8faeef6776378cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf10ea0a6364c48fb8faeef6776378cb">CheckAcceptResult</a> () const</td></tr>
<tr class="separator:adf10ea0a6364c48fb8faeef6776378cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662296f1f892387a90bd232901a8ec45" id="r_a662296f1f892387a90bd232901a8ec45"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a662296f1f892387a90bd232901a8ec45">CheckReceiveError</a> () const</td></tr>
<tr class="separator:a662296f1f892387a90bd232901a8ec45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a218405d3d7679710692b170a9137c156" id="r_a218405d3d7679710692b170a9137c156"><td class="memItemLeft" align="right" valign="top">SOCKET&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a218405d3d7679710692b170a9137c156">socket_</a></td></tr>
<tr class="separator:a218405d3d7679710692b170a9137c156"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a socket descriptor that is bound to a specific transport-service provider. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4ff98a1b209fd2bf2956668183730e8a" name="a4ff98a1b209fd2bf2956668183730e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff98a1b209fd2bf2956668183730e8a">&#9670;&#160;</a></span>Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">Harlinn::Common::Core::IO::Sockets::Socket::Flags</a> = <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">SocketFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac4e63936a25c68e274e679cff60c59c3" name="ac4e63936a25c68e274e679cff60c59c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e63936a25c68e274e679cff60c59c3">&#9670;&#160;</a></span>Socket() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Harlinn::Common::Core::IO::Sockets::Socket::Socket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is not bound to a socket descriptor. </p>

</div>
</div>
<a id="a8f4fdd13685ed97e02e353c739302b8e" name="a8f4fdd13685ed97e02e353c739302b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4fdd13685ed97e02e353c739302b8e">&#9670;&#160;</a></span>Socket() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Harlinn::Common::Core::IO::Sockets::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>socket</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4b9d55dfb3163f72c8788caff1a7cf1" name="ae4b9d55dfb3163f72c8788caff1a7cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b9d55dfb3163f72c8788caff1a7cf1">&#9670;&#160;</a></span>Socket() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Harlinn::Common::Core::IO::Sockets::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#af395a3acb64247117d47181425e02e19">AddressFamily</a></td>          <td class="paramname"><span class="paramname"><em>addressFamily</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22">SocketType</a></td>          <td class="paramname"><span class="paramname"><em>socketType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a07f3d621b4627a07bc6a6e36b0d53eb5">ProtocolType</a></td>          <td class="paramname"><span class="paramname"><em>protocolType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is bound to a specific transport service provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressFamily</td><td>The address family specification. </td></tr>
    <tr><td class="paramname">socketType</td><td>The type specification for the new socket. </td></tr>
    <tr><td class="paramname">protocolType</td><td>The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a366082282f20cfb9c338ec5db35531bd" name="a366082282f20cfb9c338ec5db35531bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366082282f20cfb9c338ec5db35531bd">&#9670;&#160;</a></span>Socket() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Harlinn::Common::Core::IO::Sockets::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#af395a3acb64247117d47181425e02e19">AddressFamily</a></td>          <td class="paramname"><span class="paramname"><em>addressFamily</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22">SocketType</a></td>          <td class="paramname"><span class="paramname"><em>socketType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a07f3d621b4627a07bc6a6e36b0d53eb5">ProtocolType</a></td>          <td class="paramname"><span class="paramname"><em>protocolType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_protocol_info.html">ProtocolInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>protocolInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GROUP</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">Flags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is bound to a specific transport service provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressFamily</td><td>The address family specification </td></tr>
    <tr><td class="paramname">socketType</td><td>The type specification for the new socket. </td></tr>
    <tr><td class="paramname">protocolType</td><td>The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type specified. </td></tr>
    <tr><td class="paramname">protocolInfo</td><td>A reference to a <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_protocol_info.html" title="Used to store or retrieve complete information for a given protocol.">ProtocolInfo</a> object that defines the characteristics of the socket to be created. </td></tr>
    <tr><td class="paramname">group</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group. </p>
<p>If <code>group</code> is an existing socket group ID, join the new socket to this socket group, provided all the requirements set by this group are met. </p>
<p>If <code>group</code> is not an existing socket group ID, then the following values are possible: </p>
<table class="doxtable">
<tr>
<th>group </th><th>Meaning  </th></tr>
<tr>
<td>0  </td><td>No group operation is performed.   </td></tr>
<tr>
<td>SG_UNCONSTRAINED_GROUP  </td><td>Create an unconstrained socket group and have the new socket be the first member. For an unconstrained group, Winsock does not constrain all sockets in the socket group to have been created with the same value for the type and protocol parameters.   </td></tr>
<tr>
<td>SG_CONSTRAINED_GROUP  </td><td>Create a constrained socket group and have the new socket be the first member. For a constrained socket group, Winsock constrains all sockets in the socket group to have been created with the same value for the type and protocol parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host.   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of flags used to specify additional socket attributes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66e14334fdc70d15361ae16a2179ca54" name="a66e14334fdc70d15361ae16a2179ca54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e14334fdc70d15361ae16a2179ca54">&#9670;&#160;</a></span>Socket() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Harlinn::Common::Core::IO::Sockets::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#af395a3acb64247117d47181425e02e19">AddressFamily</a></td>          <td class="paramname"><span class="paramname"><em>addressFamily</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22">SocketType</a></td>          <td class="paramname"><span class="paramname"><em>socketType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a07f3d621b4627a07bc6a6e36b0d53eb5">ProtocolType</a></td>          <td class="paramname"><span class="paramname"><em>protocolType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">Flags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is bound to a specific transport service provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressFamily</td><td>The address family specification </td></tr>
    <tr><td class="paramname">socketType</td><td>The type specification for the new socket. </td></tr>
    <tr><td class="paramname">protocolType</td><td>The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type specified. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of flags used to specify additional socket attributes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29a44fde34388ac99b2f3d7630f73f18" name="a29a44fde34388ac99b2f3d7630f73f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a44fde34388ac99b2f3d7630f73f18">&#9670;&#160;</a></span>Socket() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Harlinn::Common::Core::IO::Sockets::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No copy constructor. </p>

</div>
</div>
<a id="a9bdf1080a5501232603eca39b02f4b49" name="a9bdf1080a5501232603eca39b02f4b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdf1080a5501232603eca39b02f4b49">&#9670;&#160;</a></span>Socket() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Harlinn::Common::Core::IO::Sockets::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object, taking ownership of the socket descriptor of the argument <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> that holds the socket descriptor that will be moved to the new <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33236c593f282a934d41e12059ef4769" name="a33236c593f282a934d41e12059ef4769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33236c593f282a934d41e12059ef4769">&#9670;&#160;</a></span>~Socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Harlinn::Common::Core::IO::Sockets::Socket::~Socket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The destructor for the <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object. </p>
<p>Will close the handle to the socket descriptor currently held by the object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a13218ff19f1642b91644d207399b1a45" name="a13218ff19f1642b91644d207399b1a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13218ff19f1642b91644d207399b1a45">&#9670;&#160;</a></span>Accept() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> Harlinn::Common::Core::IO::Sockets::Socket::Accept </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permits an incoming connection attempt on a socket. </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">If no error occurs, Accept returns a <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is a descriptor for the new socket. This descriptor is a handle for the socket on which the actual connection is made. </p>
<p class="interdd"></p>
<p class="interdd">An invalid <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object is returned if: </p>
<ul>
<li>
An incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call.  </li>
<li>
The listening socket is closed.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a98103015fedc455bef0cfc5dbbceb143" name="a98103015fedc455bef0cfc5dbbceb143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98103015fedc455bef0cfc5dbbceb143">&#9670;&#160;</a></span>Accept() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> Harlinn::Common::Core::IO::Sockets::Socket::Accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permits an incoming connection attempt on a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A reference to a <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html" title="Provides a generic mechanism for specifying a transport address.">Sockets::Address</a> object that receives the address of the connecting entity, as known to the communications layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">If no error occurs, Accept returns a <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is a descriptor for the new socket. This descriptor is a handle for the socket on which the actual connection is made. </p>
<p class="interdd"></p>
<p class="interdd">An invalid <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object is returned if an incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call. </p>
<p class="enddd"></p>
</dd></dl>

</div>
</div>
<a id="a332b190aceefc247d556df62b312665f" name="a332b190aceefc247d556df62b312665f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332b190aceefc247d556df62b312665f">&#9670;&#160;</a></span>Accept() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionSocketT &gt; <br />
requires std::is_base_of_v&lt;<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Sockets::Socket</a>, ConnectionSocketT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectionSocketT &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b136d438fc042c1e57cc69c84e51346" name="a2b136d438fc042c1e57cc69c84e51346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b136d438fc042c1e57cc69c84e51346">&#9670;&#160;</a></span>Accept() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionSocketT &gt; <br />
requires std::is_base_of_v&lt;<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Sockets::Socket</a>, ConnectionSocketT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Accept </td>
          <td>(</td>
          <td class="paramtype">ConnectionSocketT &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a227294022f3a9aa7e6bd91850151d129" name="a227294022f3a9aa7e6bd91850151d129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227294022f3a9aa7e6bd91850151d129">&#9670;&#160;</a></span>Accept() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> Harlinn::Common::Core::IO::Sockets::Socket::Accept </td>
          <td>(</td>
          <td class="paramtype">LPCONDITIONPROC</td>          <td class="paramname"><span class="paramname"><em>conditionFunction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG_PTR</td>          <td class="paramname"><span class="paramname"><em>callbackData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19369cbdf6e91dd74b3034e1cc619a45" name="a19369cbdf6e91dd74b3034e1cc619a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19369cbdf6e91dd74b3034e1cc619a45">&#9670;&#160;</a></span>Accept() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Accept </td>
          <td>(</td>
          <td class="paramtype">LPCONDITIONPROC</td>          <td class="paramname"><span class="paramname"><em>conditionFunction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG_PTR</td>          <td class="paramname"><span class="paramname"><em>callbackData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7fef1cbd9790094c58929cba5cd9d59" name="ab7fef1cbd9790094c58929cba5cd9d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fef1cbd9790094c58929cba5cd9d59">&#9670;&#160;</a></span>Accept() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> Harlinn::Common::Core::IO::Sockets::Socket::Accept </td>
          <td>(</td>
          <td class="paramtype">LPCONDITIONPROC</td>          <td class="paramname"><span class="paramname"><em>conditionFunction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG_PTR</td>          <td class="paramname"><span class="paramname"><em>callbackData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>addrlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally accepts a connection based on the return value of a condition function, provides quality of service flow specifications, and allows the transfer of connection data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conditionFunction</td><td>The address of an optional application-specified condition function that will make an accept/reject decision based on the caller information passed in as parameters, and optionally create or join a socket group by assigning an appropriate value to the result parameter g of this function. If this parameter is NULL, then no condition function is called. </td></tr>
    <tr><td class="paramname">callbackData</td><td>Callback data passed back to the application-specified condition function as the value of the dwCallbackData parameter passed to the condition function. This parameter is only applicable if the conditionFunction parameter is not nullptr. This parameter is not interpreted by <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html">Sockets</a>. </td></tr>
    <tr><td class="paramname">addr</td><td>An optional pointer to an sockaddr structure that receives the address of the connecting entity, as known to the communications layer. </td></tr>
    <tr><td class="paramname">addrlen</td><td>An optional pointer to an integer that contains the length of the sockaddr structure pointed to by the addr parameter, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">If no error occurs, Accept returns a <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is a descriptor for the new socket. This descriptor is a handle for the socket on which the actual connection is made. </p>
<p class="interdd"></p>
<p class="interdd">An invalid <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object is returned if an incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call, or if the connection was refused by the conditionFunction. </p>
<p class="enddd"></p>
</dd></dl>

</div>
</div>
<a id="a5b9681b65c77227f1eef251ae70c76d4" name="a5b9681b65c77227f1eef251ae70c76d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9681b65c77227f1eef251ae70c76d4">&#9670;&#160;</a></span>Accept() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Accept </td>
          <td>(</td>
          <td class="paramtype">LPCONDITIONPROC</td>          <td class="paramname"><span class="paramname"><em>conditionFunction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG_PTR</td>          <td class="paramname"><span class="paramname"><em>callbackData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>addressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1ef273cd75a205e1a48850c8d27dad9" name="aa1ef273cd75a205e1a48850c8d27dad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ef273cd75a205e1a48850c8d27dad9">&#9670;&#160;</a></span>Accept() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConnectionSocketT &gt; <br />
requires std::is_base_of_v&lt;<a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Sockets::Socket</a>,ConnectionSocketT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Accept </td>
          <td>(</td>
          <td class="paramtype">sockaddr *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>addressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectionSocketT &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdbe7439f72f50caa1cbc8d55131d678" name="afdbe7439f72f50caa1cbc8d55131d678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbe7439f72f50caa1cbc8d55131d678">&#9670;&#160;</a></span>AcceptEx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::AcceptEx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>acceptSocket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVOID</td>          <td class="paramname"><span class="paramname"><em>outputBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>receiveDataLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>localAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>remoteAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>bytesReceived</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45b3916b08438ec6356a0f295f0ff69b" name="a45b3916b08438ec6356a0f295f0ff69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b3916b08438ec6356a0f295f0ff69b">&#9670;&#160;</a></span>AcceptEx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::AcceptEx </td>
          <td>(</td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>acceptSocket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVOID</td>          <td class="paramname"><span class="paramname"><em>outputBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>receiveDataLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>localAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>remoteAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>bytesReceived</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3f89821e6aa425a53be2b7205a3c36e" name="ac3f89821e6aa425a53be2b7205a3c36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f89821e6aa425a53be2b7205a3c36e">&#9670;&#160;</a></span>AcceptsConnections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::AcceptsConnections </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the socket is in listening mode. </p>
<p>This function is only Valid for connection-oriented protocols. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the socket is in listening mode, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac62d59cd2e5e77b908af20ddba132185" name="ac62d59cd2e5e77b908af20ddba132185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62d59cd2e5e77b908af20ddba132185">&#9670;&#160;</a></span>Available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Harlinn::Common::Core::IO::Sockets::Socket::Available </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac32eaa76fbcd99e2c9b4daf6a3ed1afd" name="ac32eaa76fbcd99e2c9b4daf6a3ed1afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32eaa76fbcd99e2c9b4daf6a3ed1afd">&#9670;&#160;</a></span>Bind() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada0f68b4debeab98c83b5064da278a1a" name="ada0f68b4debeab98c83b5064da278a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0f68b4debeab98c83b5064da278a1a">&#9670;&#160;</a></span>Bind() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Bind </td>
          <td>(</td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>addrlen</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates a local address with a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A pointer to a sockaddr structure of the local address to assign to the bound socket . </td></tr>
    <tr><td class="paramname">addrlen</td><td>The length, in bytes, of the value pointed to by the addr parameter. </td></tr>
  </table>
  </dd>
</dl>
<p>The Bind function is required on an unconnected socket before subsequent calls to the Listen function. It is normally used to bind to either connection-oriented (stream) or connectionless (datagram) sockets. The bind function may also be used to bind to a raw socket (the socket was created by calling the socket function with the type parameter set to <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22a65e65c8ab0d8609ce12fc68a03cb8e00">SocketType::Raw</a>). The bind function may also be used on an unconnected socket before subsequent calls to any of the Connect functions before send operations. </p>
<p>When a <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> is created it exists in a namespace (address family), but it has no name assigned to it. Use the Bind function to establish the local association of the socket by assigning a local name to an unnamed socket. </p>
<p>A name consists of three parts when using the Internet address family: </p>
<ul>
<li>
The address family. </li>
<li>
A host address. </li>
<li>
A port number that identifies the application. </li>
</ul>
<p>In <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html">Sockets</a> 2, the addr parameter is not strictly interpreted as a pointer to a sockaddr structure. It is cast this way for <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html">Sockets</a> 1.1 compatibility. Service providers are free to regard it as a pointer to a block of memory of size addrlen. The first 2 bytes in this block (corresponding to the sa_family member of the sockaddr structure, the sin_family member of the sockaddr_in structure, or the sin6_family member of the sockaddr_in6 structure) must contain the address family that was used to create the socket. Otherwise, an error WinError::WsaFault occurs. </p>
<p>If an application does not care what local address is assigned, specify the constant value INADDR_ANY for an IPv4 local address or the constant value in6addr_any for an IPv6 local address in the sa_data member of the name parameter. This allows the underlying service provider to use any appropriate network address, potentially simplifying application programming in the presence of multihomed hosts (that is, hosts that have more than one network interface and address). </p>
<p>For TCP/IP, if the port is specified as zero, the service provider assigns a unique port to the application from the dynamic client port range. On <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> Vista and later, the dynamic client port range is a value between 49152 and 65535. This is a change from <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_server.html">Server</a> 2003 and earlier where the dynamic client port range was a value between 1025 and 5000. The maximum value for the client dynamic port range can be changed by setting a value under the following registry key: </p>
<p><code>HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</code> </p>
<p>The MaxUserPort registry value sets the value to use for the maximum value of the dynamic client port range. You must restart the computer for this setting to take effect. </p>
<p>On <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> Vista and later, the dynamic client port range can be viewed and changed using netsh commands. The dynamic client port range can be set differently for UDP and TCP and also for IPv4 and IPv6. </p>
<p>The application can use <a class="el" href="#acd7470f0cbefdd415cb61a938165ae46">Socket::Name( )</a> after calling Bind to learn the address and the port that has been assigned to the socket. If the Internet address is equal to INADDR_ANY or in6addr_any, <a class="el" href="#acd7470f0cbefdd415cb61a938165ae46">Socket::Name( )</a> cannot necessarily supply the address until the socket is connected, since several addresses can be valid if the host is multihomed. Binding to a specific port number other than port 0 is discouraged for client applications, since there is a danger of conflicting with another socket already using that port number on the local computer. </p>
<p>For multicast operations, the preferred method is to call the bind function to associate a socket with a local IP address and then join the multicast group. Although this order of operations is not mandatory, it is strongly recommended. So a multicast application would first select an IPv4 or IPv6 address on the local computer, the wildcard IPv4 address (INADDR_ANY), or the wildcard IPv6 address (in6addr_any). The the multicast application would then call the bind function with this address in the in the sa_data member of the name parameter to associate the local IP address with the socket. If a wildcard address was specified, then <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> will select the local IP address to use. After the Bind function completes, an application would then join the multicast group of interest. For more information on how to join a multicast group, see the section on Multicast Programming. This socket can then be used to receive multicast packets from the multicast group using the <a class="el" href="#a9131f4354115395b67cc535f03872cb6" title="Receives data from a connected socket or a bound connectionless socket.">Socket::Receive</a>, <a class="el" href="#a581663117e37f9401a29e0bda59b5b4d">Socket::ReceiveFrom</a>, or Socket::ReceiveMsg functions. </p>
<p>The Bind function is not normally required for send operations to a multicast group. The <a class="el" href="#a3b1d557aac132c6ad215dbe6c80fb2b2">Socket::SendTo</a> and <a class="el" href="#a39dccd4e54c3f98318bc9c1f421bbf29">Socket::SendMsg</a> functions implicitly bind the socket to the wildcard address if the socket is not already bound. The Bind function is required before the use of the <a class="el" href="#a25cdf12bc67f4faddc26aa143ca1722a">Socket::Send</a> functions which do not perform an implicit bind and are allowed only on connected sockets, which means the socket must have already been bound for it to be connected. The Bind function might be used before send operations using the <a class="el" href="#a3b1d557aac132c6ad215dbe6c80fb2b2">Socket::SendTo</a> and <a class="el" href="#a39dccd4e54c3f98318bc9c1f421bbf29">Socket::SendMsg</a> functions if an application wanted to select a specific local IP address on a local computer with multiple network interfaces and local IP addresses. Otherwise an implicit bind to the wildcard address using the <a class="el" href="#a3b1d557aac132c6ad215dbe6c80fb2b2">Socket::SendTo</a> and <a class="el" href="#a39dccd4e54c3f98318bc9c1f421bbf29">Socket::SendMsg</a> functions might result in a different local IP address being used for send operations. </p>

</div>
</div>
<a id="a0e51c94172ca0c3b9565e7d918df0509" name="a0e51c94172ca0c3b9565e7d918df0509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e51c94172ca0c3b9565e7d918df0509">&#9670;&#160;</a></span>Bind() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Bind </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a16d9ed304994b417f1b60c1431408c7e">UInt16</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02a08dfe8d674c1f2617269b91717832" name="a02a08dfe8d674c1f2617269b91717832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a08dfe8d674c1f2617269b91717832">&#9670;&#160;</a></span>Bind() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a16d9ed304994b417f1b60c1431408c7e">UInt16</a></td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21dc8fed3258112cb48cb0fb4be046b8" name="a21dc8fed3258112cb48cb0fb4be046b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21dc8fed3258112cb48cb0fb4be046b8">&#9670;&#160;</a></span>Broadcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::Broadcast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the socket is configured to broadcast data when sending. </p>
<p>This function is only valid for protocols that support broadcasting (IPX and UDP, for example). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the socket is configured to broadcast data, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="adf10ea0a6364c48fb8faeef6776378cb" name="adf10ea0a6364c48fb8faeef6776378cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf10ea0a6364c48fb8faeef6776378cb">&#9670;&#160;</a></span>CheckAcceptResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> Harlinn::Common::Core::IO::Sockets::Socket::CheckAcceptResult </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a662296f1f892387a90bd232901a8ec45" name="a662296f1f892387a90bd232901a8ec45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662296f1f892387a90bd232901a8ec45">&#9670;&#160;</a></span>CheckReceiveError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::CheckReceiveError </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8223e6c6f0aa2404a15d128522a1a38" name="af8223e6c6f0aa2404a15d128522a1a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8223e6c6f0aa2404a15d128522a1a38">&#9670;&#160;</a></span>Close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::Close </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the socket descriptor. </p>

</div>
</div>
<a id="a06fb05246aaf6441bd0eb1402dd5b554" name="a06fb05246aaf6441bd0eb1402dd5b554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fb05246aaf6441bd0eb1402dd5b554">&#9670;&#160;</a></span>ConditionalAccept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::ConditionalAccept </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the socket is configured to pass incoming connect request to the application, or let the protocol stack handle the requests. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the socket is configured to pass incoming connect request to the application, otherwise false. </dd></dl>

</div>
</div>
<a id="ab7ea8123e2202d772096cc6f519a50d5" name="ab7ea8123e2202d772096cc6f519a50d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ea8123e2202d772096cc6f519a50d5">&#9670;&#160;</a></span>Connect() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a771d829c9b38a2c49c69bb85b7b7da90" name="a771d829c9b38a2c49c69bb85b7b7da90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771d829c9b38a2c49c69bb85b7b7da90">&#9670;&#160;</a></span>Connect() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>callerData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>calleeData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QOS *</td>          <td class="paramname"><span class="paramname"><em>SQOS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QOS *</td>          <td class="paramname"><span class="paramname"><em>GQOS</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02720ca29ea0e5a65ba82e568a2a4606" name="a02720ca29ea0e5a65ba82e568a2a4606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02720ca29ea0e5a65ba82e568a2a4606">&#9670;&#160;</a></span>Connect() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Connect </td>
          <td>(</td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>addrLength</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>Connect</code> function establishes a connection to a specified socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A pointer to the sockaddr structure to which the connection should be established. </td></tr>
    <tr><td class="paramname">addrLength</td><td>The length, in bytes, of the sockaddr structure pointed to by the <code>addr</code> parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">If the operation completes successfully, <code>Connect</code> returns <code>true</code>. </p>
<p class="interdd"></p>
<p class="interdd">On a blocking socket, the return value indicates success or failure of the connection attempt. </p>
<p class="interdd"></p>
<p class="interdd">With a nonblocking socket, the connection attempt cannot be completed immediately. In this case, <code>Connect</code> will return <code>false</code>. In this case, there are two possible scenarios: </p>
<ul>
<li>
Use the <code><a class="el" href="#adcf51f49082f3d14930f4d612b5b3f8b">Socket::Select</a></code> function to determine the completion of the connection request by checking to see if the socket is writable.  </li>
<li>
Use the <code><a class="el" href="#ae67852d3632795b130a45599e9d27770">Socket::EventSelect</a></code> to indicate interest in connection events, and then wait for the event object to become signaled, indicating that the connect operation is complete (successfully or not).  </li>
</ul>
<p class="interdd">Until the connection attempt completes on a nonblocking socket, all subsequent calls to connect on the same socket will return <code>false</code>. </p>
<p class="enddd"></p>
</dd></dl>

</div>
</div>
<a id="a380c314e851ee965704dabb7c00e9904" name="a380c314e851ee965704dabb7c00e9904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380c314e851ee965704dabb7c00e9904">&#9670;&#160;</a></span>Connect() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Connect </td>
          <td>(</td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>addrLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>callerData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>calleeData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QOS *</td>          <td class="paramname"><span class="paramname"><em>SQOS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QOS *</td>          <td class="paramname"><span class="paramname"><em>GQOS</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establishes a connection to another socket application, exchanges connect data, and specifies required quality of service based on the specified FLOWSPEC structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A pointer to a sockaddr structure that specifies the address to which to connect. </td></tr>
    <tr><td class="paramname">addrLength</td><td>The length, in bytes, of the sockaddr structure pointed to by the <code>addr</code> parameter. </td></tr>
    <tr><td class="paramname">callerData</td><td>A pointer to the user data that is to be transferred to the other socket during connection establishment. </td></tr>
    <tr><td class="paramname">calleeData</td><td>A pointer to the user data that is to be transferred back from the other socket during connection establishment. </td></tr>
    <tr><td class="paramname">SQOS</td><td>A pointer to the FLOWSPEC structures for socket s, one for each direction. </td></tr>
    <tr><td class="paramname">GQOS</td><td>Reserved for future use with socket groups. A pointer to the FLOWSPEC structures for the socket group (if applicable). This parameter should be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">If the operation completes successfully, <code>Connect</code> returns <code>true</code>. </p>
<p class="interdd"></p>
<p class="interdd">On a blocking socket, the return value indicates success or failure of the connection attempt. </p>
<p class="interdd"></p>
<p class="interdd">With a nonblocking socket, the connection attempt cannot be completed immediately. In this case, <code>Connect</code> will return <code>false</code>. In this case, there are two possible scenarios: </p>
<ul>
<li>
Use the <code><a class="el" href="#adcf51f49082f3d14930f4d612b5b3f8b">Socket::Select</a></code> function to determine the completion of the connection request by checking to see if the socket is writable.  </li>
<li>
Use the <code><a class="el" href="#ae67852d3632795b130a45599e9d27770">Socket::EventSelect</a></code> to indicate interest in connection events, and then wait for the event object to become signaled, indicating that the connect operation is complete (successfully or not).  </li>
</ul>
<p class="interdd">Until the connection attempt completes on a nonblocking socket, all subsequent calls to connect on the same socket will return <code>false</code>. </p>
<p class="enddd"></p>
</dd></dl>
<p><code>Connect</code> is used to create a connection to the specified destination, and to perform a number of other ancillary operations that occur at connect time. If the socket is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound. </p>
<p>For connection-oriented sockets (for example, <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22aeae835e83c0494a376229f254f7d3392">SocketType::Stream</a>), an active connection is initiated to the foreign host using <code>addr</code> (an address in the namespace of the socket; for a detailed description, please see Bind). When this call completes successfully, the socket is ready to send/receive data. </p>
<p>For connection-oriented, nonblocking sockets, it is often not possible to complete the connection immediately. In such cases, this function returns <code>false</code>. However, the operation proceeds. When the success or failure outcome becomes known, it may be reported in one of several ways depending on how the client registers for notification. If the client uses select, success is reported in the <code>writefds</code> set and failure is reported in the <code>exceptfds</code> set. If the client uses <code><a class="el" href="#ae67852d3632795b130a45599e9d27770">Socket::EventSelect</a></code>, the notification is announced with <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#ab376983270b3970dadc0da1ab35deac8a49ab28040dfa07f53544970c6d147e1e" title="Wants to receive notification of completed connection or multipoint join operation.">EventFlags::Connect</a></code> and the error code associated with the <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#ab376983270b3970dadc0da1ab35deac8a49ab28040dfa07f53544970c6d147e1e" title="Wants to receive notification of completed connection or multipoint join operation.">EventFlags::Connect</a></code> indicates either success or a specific reason for failure. </p>
<p>For a connectionless socket (for example, type <code>SocketType::Dgram</code>), the operation performed by <code>Connect</code> is merely to establish a default destination address so that the socket can be used on subsequent connection-oriented send and receive operations (<code><a class="el" href="#a25cdf12bc67f4faddc26aa143ca1722a">Socket::Send</a></code> and <code><a class="el" href="#a9131f4354115395b67cc535f03872cb6" title="Receives data from a connected socket or a bound connectionless socket.">Socket::Receive</a></code>). Any datagrams received from an address other than the destination address specified will be discarded. If the entire name structure is all zeros (not just the address parameter of the name structure), then the socket will be disconnected. Then, the default remote address will be indeterminate, so <a class="el" href="#a25cdf12bc67f4faddc26aa143ca1722a">Socket::Send</a> and <a class="el" href="#a9131f4354115395b67cc535f03872cb6" title="Receives data from a connected socket or a bound connectionless socket.">Socket::Receive</a> calls will throw an exception. However, <code><a class="el" href="#a3b1d557aac132c6ad215dbe6c80fb2b2">Socket::SendTo</a></code> and <code><a class="el" href="#a581663117e37f9401a29e0bda59b5b4d">Socket::ReceiveFrom</a></code> can still be used. The default destination can be changed by simply calling <code>Connect</code> again, even if the socket is already connected. Any datagrams queued for receipt are discarded if <code>addr</code> is different from the previous call to <code>Connect</code>. </p>
<p>For connectionless sockets, <code>addr</code> can indicate any valid address, including a broadcast address. However, to connect to a broadcast address, a socket must have <code>Socket::SetSocketOption(SOL_SOCKET, SO_BROADCAST,...)</code>, or <a class="el" href="#addd72b3aa2315d4ad6fe90df2f4e010d">Socket::SetBroadcast</a>, enabled. Otherwise, Connect will throw an exception for <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88a1add0de8efe1fa5279733156401d1cd1" title="An attempt was made to access a socket in a way forbidden by its access permissions.">WinError::WsaAccess</a>. </p>

</div>
</div>
<a id="ac782bb0c802a7111f875d07875d56602" name="ac782bb0c802a7111f875d07875d56602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac782bb0c802a7111f875d07875d56602">&#9670;&#160;</a></span>ConnectByList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ConnectByList </td>
          <td>(</td>
          <td class="paramtype">SOCKET_ADDRESS_LIST *</td>          <td class="paramname"><span class="paramname"><em>socketAddresses</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>localAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOCKADDR *</td>          <td class="paramname"><span class="paramname"><em>localAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>remoteAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOCKADDR *</td>          <td class="paramname"><span class="paramname"><em>remoteAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const timeval *</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>reserved</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establishes a connection to one out of a collection of possible endpoints represented by a set of destination addresses (host names and ports). This function takes all the destination addresses passed to it and all of the local computer's source addresses, and tries connecting using all possible address combinations before giving up. </p>
<p>This function supports both IPv4and IPv6 addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socketAddresses</td><td>A pointer to a SOCKET_ADDRESS_LIST structure that represents the possible destination address and port pairs to connect to a peer. It is the application's responsibility to fill in the port number in the each SOCKET_ADDRESS structure in the SOCKET_ADDRESS_LIST. </td></tr>
    <tr><td class="paramname">localAddressLength</td><td>On input, a pointer to the size, in bytes, of the <code>localAddress</code> buffer provided by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the local address stored in the <code>localAddress</code> buffer filled in by the system. upon successful completion of the call. </td></tr>
    <tr><td class="paramname">localAddress</td><td>A pointer to the SOCKADDR structure that receives the local address of the connection. The size of the parameter is exactly the size returned in <code>localAddressLength</code>. This is the same information that would be returned by the <code><a class="el" href="#acd7470f0cbefdd415cb61a938165ae46">Socket::Name()</a></code> function. This parameter can be nullptr, in which case, the <code>localAddressLength</code> parameter is ignored. </td></tr>
    <tr><td class="paramname">remoteAddressLength</td><td>On input, a pointer to the size, in bytes, of the <code>remoteAddress</code> buffer provided by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the remote address stored in <code>remoteAddress</code> buffer filled-in by the system upon successful completion of the call. </td></tr>
    <tr><td class="paramname">remoteAddress</td><td>A pointer to the SOCKADDR structure that receives the remote address of the connection. This is the same information that would be returned by the <code><a class="el" href="#a69e194c25bba8448eab3ec266ddf29a9">Socket::PeerName()</a></code> function. This parameter can be nullptr, in which case, the <code>remoteAddressLength</code> is ignored. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time, in milliseconds, to wait for a response from the remote application before aborting the call. This parameter can be nullptr in which case Connect will complete after either the connection is successfully established or after a connection was attempted and failed on all possible local-remote address pairs. </td></tr>
    <tr><td class="paramname">reserved</td><td>Reserved for future implementation. This parameter must be set to <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd"><code>true</code> if a connection was established, or <code>false</code> if the operation timed out or none of the specified hosts were reachable. </p>
<p class="interdd"></p>
<p class="interdd">Any other error will cause this function to throw an exception. </p>
<p class="enddd"></p>
</dd></dl>

</div>
</div>
<a id="aef3517ba543f5f9569570eac64f3180d" name="aef3517ba543f5f9569570eac64f3180d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3517ba543f5f9569570eac64f3180d">&#9670;&#160;</a></span>ConnectByList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ConnectByList </td>
          <td>(</td>
          <td class="paramtype">SOCKET_ADDRESS_LIST *</td>          <td class="paramname"><span class="paramname"><em>socketAddresses</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>localAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>remoteAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const timeval *</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>reserved</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42573227572a5e90ab9ea9325d75a8f5" name="a42573227572a5e90ab9ea9325d75a8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42573227572a5e90ab9ea9325d75a8f5">&#9670;&#160;</a></span>ConnectByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ConnectByName </td>
          <td>(</td>
          <td class="paramtype">LPWSTR</td>          <td class="paramname"><span class="paramname"><em>nodeName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSTR</td>          <td class="paramname"><span class="paramname"><em>serviceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>localAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOCKADDR *</td>          <td class="paramname"><span class="paramname"><em>localAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>remoteAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOCKADDR *</td>          <td class="paramname"><span class="paramname"><em>remoteAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const timeval *</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>reserved</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadbc2dde93f66e9c9be6e440c9a404c9" name="aadbc2dde93f66e9c9be6e440c9a404c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbc2dde93f66e9c9be6e440c9a404c9">&#9670;&#160;</a></span>ConnectByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ConnectByName </td>
          <td>(</td>
          <td class="paramtype">LPWSTR</td>          <td class="paramname"><span class="paramname"><em>nodeName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSTR</td>          <td class="paramname"><span class="paramname"><em>serviceName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>localAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>remoteAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const timeval *</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>reserved</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d6700160212b044611f00803997852f" name="a8d6700160212b044611f00803997852f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6700160212b044611f00803997852f">&#9670;&#160;</a></span>ConnectEx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ConnectEx </td>
          <td>(</td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>namelen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVOID</td>          <td class="paramname"><span class="paramname"><em>sendBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>sendDataLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPDWORD</td>          <td class="paramname"><span class="paramname"><em>bytesSent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a1aacb57336c402491df4c85f929834" name="a5a1aacb57336c402491df4c85f929834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1aacb57336c402491df4c85f929834">&#9670;&#160;</a></span>ConnectEx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ConnectEx </td>
          <td>(</td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>namelen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVOID</td>          <td class="paramname"><span class="paramname"><em>sendBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>sendDataLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPDWORD</td>          <td class="paramname"><span class="paramname"><em>bytesSent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a652fba6449e2d5077fec2b8cc13b161f" name="a652fba6449e2d5077fec2b8cc13b161f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652fba6449e2d5077fec2b8cc13b161f">&#9670;&#160;</a></span>ConnectTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_time_span.html">TimeSpan</a> Harlinn::Common::Core::IO::Sockets::Socket::ConnectTime </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a38d8a40ad47426121060b8e1520e69e6" name="a38d8a40ad47426121060b8e1520e69e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d8a40ad47426121060b8e1520e69e6">&#9670;&#160;</a></span>ConnectTimeInSeconds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Common::Core::IO::Sockets::Socket::ConnectTimeInSeconds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c6f18e693cc504babf357148edabe60" name="a1c6f18e693cc504babf357148edabe60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6f18e693cc504babf357148edabe60">&#9670;&#160;</a></span>Debug()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::Debug </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc7e76db1e83362397013ffcc0662e5d" name="abc7e76db1e83362397013ffcc0662e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7e76db1e83362397013ffcc0662e5d">&#9670;&#160;</a></span>Detach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SOCKET Harlinn::Common::Core::IO::Sockets::Socket::Detach </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21fa5968bb7e499e989a397db3d1e966" name="a21fa5968bb7e499e989a397db3d1e966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fa5968bb7e499e989a397db3d1e966">&#9670;&#160;</a></span>Disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Disconnect </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reuse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29f038af72da5ef9879620cc66d9eb44" name="a29f038af72da5ef9879620cc66d9eb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f038af72da5ef9879620cc66d9eb44">&#9670;&#160;</a></span>DisconnectEx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::DisconnectEx </td>
          <td>(</td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reuse</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed4f0865e04f24125923d4c9c55e00aa" name="aed4f0865e04f24125923d4c9c55e00aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4f0865e04f24125923d4c9c55e00aa">&#9670;&#160;</a></span>DisconnectEx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::DisconnectEx </td>
          <td>(</td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reuse</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad308f243421bbfce978d17310449cad0" name="ad308f243421bbfce978d17310449cad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad308f243421bbfce978d17310449cad0">&#9670;&#160;</a></span>DontLinger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::DontLinger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af725f24c80240d1f02dd9f036b9bc801" name="af725f24c80240d1f02dd9f036b9bc801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af725f24c80240d1f02dd9f036b9bc801">&#9670;&#160;</a></span>Duplicate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Duplicate </td>
          <td>(</td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>processId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_protocol_info.html">ProtocolInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>protocolInfo</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acea3d7563121267410575262a53f209e" name="acea3d7563121267410575262a53f209e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea3d7563121267410575262a53f209e">&#9670;&#160;</a></span>EnumNetworkEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::EnumNetworkEvents </td>
          <td>(</td>
          <td class="paramtype">WSANETWORKEVENTS *</td>          <td class="paramname"><span class="paramname"><em>networkEvents</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE</td>          <td class="paramname"><span class="paramname"><em>eventHandle</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discovers occurrences of network events for the socket, clears internal network event records, and, optionally, reset the event object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">networkEvents</td><td>A pointer to a <code>WSANETWORKEVENTS</code> structure that is filled with a record of network events that occurred and any associated error codes. </td></tr>
    <tr><td class="paramname">eventHandle</td><td>An optional handle identifying an associated event object to be reset. </td></tr>
  </table>
  </dd>
</dl>
<p>The <code>EnumNetworkEvents</code> function is used to discover which network events have occurred for the <code><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a></code> since the last invocation of this function. It is intended for use in conjunction with <code><a class="el" href="#ae67852d3632795b130a45599e9d27770">Socket::EventSelect</a></code>, which associates an event object with one or more network events. The recording of network events commences when <code><a class="el" href="#ae67852d3632795b130a45599e9d27770">Socket::EventSelect</a></code> is called with a <br  />
 <code>networkEvents</code> parameter not equal to <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#ab376983270b3970dadc0da1ab35deac8a6adf97f83acf6453d4a6a4b1070f3754">EventFlags::None</a></code> and remains in effect until another call is made to <code><a class="el" href="#ae67852d3632795b130a45599e9d27770">Socket::EventSelect</a></code> with the networkEvents parameter set to <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#ab376983270b3970dadc0da1ab35deac8a6adf97f83acf6453d4a6a4b1070f3754">EventFlags::None</a></code>. </p>
<p>EnumNetworkEvents only reports network activity and errors nominated through <code><a class="el" href="#ae67852d3632795b130a45599e9d27770">Socket::EventSelect</a></code>. </p>
<p>The socket's internal record of network events is copied to the structure referenced by the <code>networkEvents</code> parameter, after which the internal network events record is cleared. If the <code>eventHandle</code> parameter is not 0, the indicated event object is also reset. The <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html">Sockets</a> provider guarantees that the operations of copying the network event record, clearing it and resetting any associated event object are atomic, such that the next occurrence of a nominated network event will cause the event object to become set. </p>
<p>If this function throws an exception, then the associated event object is not reset and the record of network events is not cleared. </p>

</div>
</div>
<a id="abbac8147f608ad62403be4943f22c130" name="abbac8147f608ad62403be4943f22c130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbac8147f608ad62403be4943f22c130">&#9670;&#160;</a></span>ErrorCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Common::Core::IO::Sockets::Socket::ErrorCode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae67852d3632795b130a45599e9d27770" name="ae67852d3632795b130a45599e9d27770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67852d3632795b130a45599e9d27770">&#9670;&#160;</a></span>EventSelect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::EventSelect </td>
          <td>(</td>
          <td class="paramtype">HANDLE</td>          <td class="paramname"><span class="paramname"><em>eventHandle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#ab376983270b3970dadc0da1ab35deac8">EventFlags</a></td>          <td class="paramname"><span class="paramname"><em>networkEvents</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4800881a438b1be24fee0dd0d612829" name="ad4800881a438b1be24fee0dd0d612829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4800881a438b1be24fee0dd0d612829">&#9670;&#160;</a></span>GetAcceptExSockaddrs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::GetAcceptExSockaddrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#af82811a69582d9f85a78627741d07b19">Byte</a> *</td>          <td class="paramname"><span class="paramname"><em>outputBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>receiveDataLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>localAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>remoteAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr **</td>          <td class="paramname"><span class="paramname"><em>LocalSockaddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPINT</td>          <td class="paramname"><span class="paramname"><em>LocalSockaddrLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr **</td>          <td class="paramname"><span class="paramname"><em>RemoteSockaddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPINT</td>          <td class="paramname"><span class="paramname"><em>RemoteSockaddrLength</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc40321755396d17c5113145e3d2fcbb" name="adc40321755396d17c5113145e3d2fcbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc40321755396d17c5113145e3d2fcbb">&#9670;&#160;</a></span>GetAcceptExSockaddrs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::GetAcceptExSockaddrs </td>
          <td>(</td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#af82811a69582d9f85a78627741d07b19">Byte</a> *</td>          <td class="paramname"><span class="paramname"><em>outputBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>receiveDataLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>localAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>remoteAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr **</td>          <td class="paramname"><span class="paramname"><em>LocalSockaddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPINT</td>          <td class="paramname"><span class="paramname"><em>LocalSockaddrLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr **</td>          <td class="paramname"><span class="paramname"><em>RemoteSockaddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPINT</td>          <td class="paramname"><span class="paramname"><em>RemoteSockaddrLength</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad98d02ec32de7375f1186d11487804b5" name="ad98d02ec32de7375f1186d11487804b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98d02ec32de7375f1186d11487804b5">&#9670;&#160;</a></span>GetInt32Option()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#aa879caba763494ad2c3cd321ce4bbdda">Int32</a> Harlinn::Common::Core::IO::Sockets::Socket::GetInt32Option </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>option</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d01751397d936de2908ff4ba4b9532d" name="a9d01751397d936de2908ff4ba4b9532d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d01751397d936de2908ff4ba4b9532d">&#9670;&#160;</a></span>GetOverlappedResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::GetOverlappedResult </td>
          <td>(</td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesTransferred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wait</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa34b3932da42cf60dd268227a1de80e0" name="aa34b3932da42cf60dd268227a1de80e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34b3932da42cf60dd268227a1de80e0">&#9670;&#160;</a></span>GetProtocolInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::GetProtocolInfo </td>
          <td>(</td>
          <td class="paramtype">WSAPROTOCOL_INFOW *</td>          <td class="paramname"><span class="paramname"><em>info</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a0a8a5cc67ea0d08e7b630947f1768a" name="a2a0a8a5cc67ea0d08e7b630947f1768a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0a8a5cc67ea0d08e7b630947f1768a">&#9670;&#160;</a></span>GetSocketOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::GetSocketOption </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>option</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>optionData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>optionDataLength</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a socket option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level at which the option is defined. Example: SOL_SOCKET. </td></tr>
    <tr><td class="paramname">option</td><td>The socket option for which the value is to be retrieved. Example: SO_ACCEPTCONN. The option value must be a socket option defined within the specified level, or behavior is undefined. </td></tr>
    <tr><td class="paramname">optionData</td><td>A pointer to the buffer in which the value for the requested option is to be returned. </td></tr>
    <tr><td class="paramname">optionDataLength</td><td>A pointer to the size, in bytes, of the optionData buffer. If the function succeeds the pointed to value holds the number of bytes retrieved for the option. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41b26aa7a69eb913b80ccd5d9851735d" name="a41b26aa7a69eb913b80ccd5d9851735d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b26aa7a69eb913b80ccd5d9851735d">&#9670;&#160;</a></span>GetUInt32Option()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> Harlinn::Common::Core::IO::Sockets::Socket::GetUInt32Option </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>option</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cd8cda5a773596eb48e294d5a638465" name="a3cd8cda5a773596eb48e294d5a638465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd8cda5a773596eb48e294d5a638465">&#9670;&#160;</a></span>Handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SOCKET Harlinn::Common::Core::IO::Sockets::Socket::Handle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the value for the socket handle/descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>The value for the socket handle/descriptor. </dd></dl>

</div>
</div>
<a id="a13075039e19f60276c7b2addf9c06388" name="a13075039e19f60276c7b2addf9c06388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13075039e19f60276c7b2addf9c06388">&#9670;&#160;</a></span>Ioctl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Ioctl </td>
          <td>(</td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>ioControlCode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>inBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>inBufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>outBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>outBufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>bytesReturned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4afc10153368f5295cbebeb79e7539d5" name="a4afc10153368f5295cbebeb79e7539d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afc10153368f5295cbebeb79e7539d5">&#9670;&#160;</a></span>Ioctl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Ioctl </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>cmd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_long *</td>          <td class="paramname"><span class="paramname"><em>argp</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acedf4409a1bdc9fcb4edd58ff796c10f" name="acedf4409a1bdc9fcb4edd58ff796c10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedf4409a1bdc9fcb4edd58ff796c10f">&#9670;&#160;</a></span>IsConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::IsConnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the socket is connected. </p>
<p>This member function is only valid for connection-oriented protocols. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the socket is connected, otherwise false. </dd></dl>

</div>
</div>
<a id="a07b09c055bb877d7571ce458c0018c46" name="a07b09c055bb877d7571ce458c0018c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b09c055bb877d7571ce458c0018c46">&#9670;&#160;</a></span>IsListening()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::IsListening </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the socket is in listening mode. </p>
<p>This function is only Valid for connection-oriented protocols. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the socket is in listening mode, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a7e41fcd09ba86f697cd5b423a24fc767" name="a7e41fcd09ba86f697cd5b423a24fc767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e41fcd09ba86f697cd5b423a24fc767">&#9670;&#160;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::IsValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that the value for the socket handle/descriptor is not INVALID_SOCKET. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value for the socket handle/descriptor is not INVALID_SOCKET, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a67650068454d6c813d4637ded2a8e1cb" name="a67650068454d6c813d4637ded2a8e1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67650068454d6c813d4637ded2a8e1cb">&#9670;&#160;</a></span>JoinLeaf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> Harlinn::Common::Core::IO::Sockets::Socket::JoinLeaf </td>
          <td>(</td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>namelen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>callerData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>calleeData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QOS *</td>          <td class="paramname"><span class="paramname"><em>SQOS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QOS *</td>          <td class="paramname"><span class="paramname"><em>GQOS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abfa71297f6f0d7f2321388b4ea946eff" name="abfa71297f6f0d7f2321388b4ea946eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa71297f6f0d7f2321388b4ea946eff">&#9670;&#160;</a></span>JoinLeaf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::JoinLeaf </td>
          <td>(</td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>namelen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>callerData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>calleeData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QOS *</td>          <td class="paramname"><span class="paramname"><em>SQOS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QOS *</td>          <td class="paramname"><span class="paramname"><em>GQOS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc38098219a56aed6b2425c96f164bdb" name="abc38098219a56aed6b2425c96f164bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc38098219a56aed6b2425c96f164bdb">&#9670;&#160;</a></span>KeepAlive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::KeepAlive </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3824ccde7a4cc9333360f65996147602" name="a3824ccde7a4cc9333360f65996147602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3824ccde7a4cc9333360f65996147602">&#9670;&#160;</a></span>LastSocketError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::LastSocketError </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error code for the last <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html">Sockets</a> operation that failed. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a21ed1a3a1305761f34911a02bf51983c" name="a21ed1a3a1305761f34911a02bf51983c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ed1a3a1305761f34911a02bf51983c">&#9670;&#160;</a></span>Linger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_linger.html">Sockets::Linger</a> Harlinn::Common::Core::IO::Sockets::Socket::Linger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a875a37eb479b40a5caec19b2e5911736" name="a875a37eb479b40a5caec19b2e5911736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875a37eb479b40a5caec19b2e5911736">&#9670;&#160;</a></span>Listen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Listen </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>backlog</em></span><span class="paramdefsep"> = </span><span class="paramdefval">SOMAXCONN</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc8c6abac99666341e346417fdedfcd6" name="afc8c6abac99666341e346417fdedfcd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8c6abac99666341e346417fdedfcd6">&#9670;&#160;</a></span>MaxMessageSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> Harlinn::Common::Core::IO::Sockets::Socket::MaxMessageSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum outbound message size for message-oriented sockets supported by the protocol. Has no meaning for stream-oriented sockets. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum outbound message size. </dd></dl>

</div>
</div>
<a id="ad1f477a0a7def0a3fed16fe43c140a68" name="ad1f477a0a7def0a3fed16fe43c140a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f477a0a7def0a3fed16fe43c140a68">&#9670;&#160;</a></span>Name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> Harlinn::Common::Core::IO::Sockets::Socket::Name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd7470f0cbefdd415cb61a938165ae46" name="acd7470f0cbefdd415cb61a938165ae46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7470f0cbefdd415cb61a938165ae46">&#9670;&#160;</a></span>Name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>localAddress</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68ef45b5d8d940a514652945f70a0bd2" name="a68ef45b5d8d940a514652945f70a0bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ef45b5d8d940a514652945f70a0bd2">&#9670;&#160;</a></span>NoDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Common::Core::IO::Sockets::Socket::NoDelay </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c4abcde5558694707128b10c45bd632" name="a0c4abcde5558694707128b10c45bd632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4abcde5558694707128b10c45bd632">&#9670;&#160;</a></span>Open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#af395a3acb64247117d47181425e02e19">AddressFamily</a></td>          <td class="paramname"><span class="paramname"><em>addressFamily</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22">SocketType</a></td>          <td class="paramname"><span class="paramname"><em>socketType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a07f3d621b4627a07bc6a6e36b0d53eb5">ProtocolType</a></td>          <td class="paramname"><span class="paramname"><em>protocolType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">Flags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Flags::None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a new socket descriptor for the <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object that is bound to a specific transport service provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressFamily</td><td>The address family specification </td></tr>
    <tr><td class="paramname">socketType</td><td>The type specification for the new socket. </td></tr>
    <tr><td class="paramname">protocolType</td><td>The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type specified. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of flags used to specify additional socket attributes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d3a17c5c2324de7f37b005d0c5d53f1" name="a6d3a17c5c2324de7f37b005d0c5d53f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3a17c5c2324de7f37b005d0c5d53f1">&#9670;&#160;</a></span>Open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#af395a3acb64247117d47181425e02e19">AddressFamily</a></td>          <td class="paramname"><span class="paramname"><em>addressFamily</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22">SocketType</a></td>          <td class="paramname"><span class="paramname"><em>socketType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a07f3d621b4627a07bc6a6e36b0d53eb5">ProtocolType</a></td>          <td class="paramname"><span class="paramname"><em>protocolType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAPROTOCOL_INFOW</td>          <td class="paramname"><span class="paramname"><em>protocolInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GROUP</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a3bcd1a6c64e7d6780d16e852d1b40e34">Flags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Flags::None</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6f1dcede8edec0852f66876cd712485" name="ae6f1dcede8edec0852f66876cd712485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f1dcede8edec0852f66876cd712485">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Harlinn::Common::Core::IO::Sockets::Socket::operator bool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that the value for the socket handle/descriptor is not INVALID_SOCKET. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value for the socket handle/descriptor is not INVALID_SOCKET, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a761c899a557a94a99084c97ed1f38f03" name="a761c899a557a94a99084c97ed1f38f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761c899a557a94a99084c97ed1f38f03">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp; Harlinn::Common::Core::IO::Sockets::Socket::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No copy assignment allowed. </p>

</div>
</div>
<a id="a1870523a42e2b62abad77a06634e276e" name="a1870523a42e2b62abad77a06634e276e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1870523a42e2b62abad77a06634e276e">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp; Harlinn::Common::Core::IO::Sockets::Socket::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of the socket descriptor of the argument <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> that holds the socket descriptor that will be moved to this <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa28af889cc3a8a7ebbf4d26931706198" name="aa28af889cc3a8a7ebbf4d26931706198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28af889cc3a8a7ebbf4d26931706198">&#9670;&#160;</a></span>PeerName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> Harlinn::Common::Core::IO::Sockets::Socket::PeerName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a69e194c25bba8448eab3ec266ddf29a9" name="a69e194c25bba8448eab3ec266ddf29a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e194c25bba8448eab3ec266ddf29a9">&#9670;&#160;</a></span>PeerName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::PeerName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>remoteAddress</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d4b0140ae629d9acd4ace5c16a6362f" name="a0d4b0140ae629d9acd4ace5c16a6362f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4b0140ae629d9acd4ace5c16a6362f">&#9670;&#160;</a></span>Poll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Poll </td>
          <td>(</td>
          <td class="paramtype">LPWSAPOLLFD</td>          <td class="paramname"><span class="paramname"><em>fdarray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG</td>          <td class="paramname"><span class="paramname"><em>nfds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#aa879caba763494ad2c3cd321ce4bbdda">Int32</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16a4a44633906fc5bce089fe2569b99b" name="a16a4a44633906fc5bce089fe2569b99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a4a44633906fc5bce089fe2569b99b">&#9670;&#160;</a></span>Receive() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Receive </td>
          <td>(</td>
          <td class="paramtype">LPWSABUF</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPDWORD</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesRecvd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9131f4354115395b67cc535f03872cb6" name="a9131f4354115395b67cc535f03872cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9131f4354115395b67cc535f03872cb6">&#9670;&#160;</a></span>Receive() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Receive </td>
          <td>(</td>
          <td class="paramtype">LPWSABUF</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPDWORD</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesRecvd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives data from a connected socket or a bound connectionless socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>A pointer to an array of WSABUF structures. Each WSABUF structure contains a pointer to a buffer and the length, in bytes, of the buffer. </td></tr>
    <tr><td class="paramname">bufferCount</td><td>The number of WSABUF structures in the <code>buffers</code> array. </td></tr>
    <tr><td class="paramname">numberOfBytesRecvd</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to the number, in bytes, of data received by this call if the receive operation completes immediately. </p>
<p>Use <code>nullptr</code> for this parameter if the <code>overlapped</code> parameter is not <code>nullptr</code> to avoid potentially erroneous results. This parameter can be <code>nullptr</code> only if the <code>overlapped</code> parameter is not <code>nullptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A pointer to flags used to modify the behavior of the <code>Receive</code> function call. </td></tr>
    <tr><td class="paramname">overlapped</td><td>A pointer to an <code>OVERLAPPED</code> structure (ignored for non-overlapped sockets). </td></tr>
    <tr><td class="paramname">completionRoutine</td><td>A pointer to the completion routine called when the receive operation has been completed (ignored for non-overlapped sockets). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">If no error occurs and the receive operation has completed immediately, <code>Receive</code> returns <code>true</code>. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. </p>
<p class="interdd"></p>
<p class="interdd">A return value of <code>false</code> indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. </p>
<p class="enddd"></p>
</dd></dl>
<p>This overload of the <code>Receive</code> function provides some additional features compared to the overloads implemented using the standard <code>recv</code> function in three important areas: </p>
<ul>
<li>
It can be used in conjunction with overlapped sockets to perform overlapped receive operations.  </li>
<li>
It allows multiple receive buffers to be specified making it applicable to the scatter/gather type of I/O.  </li>
<li>
The <code>flags</code> parameter is used both on input and returned on output, allowing applications to sense the output state of the <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba44ffd38a6dea695cbe2b34efdcc6cf27">MessageFlags::Partial</a> flag bit. The <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba44ffd38a6dea695cbe2b34efdcc6cf27">MessageFlags::Partial</a> flag is, however, not supported by all protocols.  </li>
</ul>
<p>This overload works with connected sockets or bound connectionless sockets and is used to read incoming data. The socket's local address must be known. For server applications, this is usually done explicitly through <code><a class="el" href="#ada0f68b4debeab98c83b5064da278a1a" title="Associates a local address with a socket.">Socket::Bind</a></code> or implicitly through <code><a class="el" href="#aa1ef273cd75a205e1a48850c8d27dad9">Socket::Accept</a></code>. Explicit binding is discouraged for client applications. For client applications the socket can become bound implicitly to a local address through <code><a class="el" href="#a02720ca29ea0e5a65ba82e568a2a4606" title="The Connect function establishes a connection to a specified socket.">Socket::Connect</a></code>, <code><a class="el" href="#a3b1d557aac132c6ad215dbe6c80fb2b2">Socket::SendTo</a></code>, or <code><a class="el" href="#abfa71297f6f0d7f2321388b4ea946eff">Socket::JoinLeaf</a></code>. </p>
<p>For connected, connectionless sockets, this overload restricts the addresses from which received messages are accepted. This overload only returns messages from the remote address specified in the connection. Messages from other addresses are silently discarded. </p>
<p>For overlapped sockets, this overload is used to post one or more buffers into which incoming data will be placed as it becomes available, after which the application-specified completion indication (invocation of the completion routine or setting of an event object) occurs. If the operation does not complete immediately, the final completion status is retrieved through the completion routine, <br  />
 or <code><a class="el" href="#a9d01751397d936de2908ff4ba4b9532d">Socket::GetOverlappedResult</a></code>. </p>
<p>If both <code>overlapped</code> and <code>completionRoutine</code> are <code>nullptr</code>, the socket will be treated as a non-overlapped socket. </p>
<p>For non-overlapped sockets, the blocking semantics are identical to that of the standard recv function and the <code>overlapped</code> and <code>completionRoutine</code> parameters are ignored. Any data that has already been received and buffered by the transport will be copied into the specified user buffers. In the case of a blocking socket with no data currently having been received and buffered by the transport, the call will block until data is received. <a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a> <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html">Sockets</a> 2 does not define any standard blocking time-out mechanism for this function. For protocols acting as byte-stream protocols the stack tries to return as much data as possible subject to the available buffer space and amount of received data available. However, receipt of a single byte is sufficient to unblock the caller. There is no guarantee that more than a single byte will be returned. For protocols acting as message-oriented, a full message is required to unblock the caller. </p>
<p>Whether or not a protocol is acting as byte stream is determined by the setting of <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a9c5e107a7ef19d3e220621a076c8b33aa236f39dc6b3976c03626d1df57391934" title="Honors message boundariesas opposed to a stream-oriented protocol where there is no concept of messa...">ServiceFlags1::MessageOriented</a></code> and <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a9c5e107a7ef19d3e220621a076c8b33aa66575df0dc27356e775f77a4235d4ce1" title="A message-oriented protocol, but message boundaries are ignored for all receipts. This is convenient ...">ServiceFlags1::PseudoStream</a></code> in the value returned by <code><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_protocol_info.html#aaecc9dfbfb2d790bee697e00beb06181" title="Returns a bit-mask that describes the services provided by the protocol.">ProtocolInfo::ServiceFlags1( )</a></code> for the <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_protocol_info.html" title="Used to store or retrieve complete information for a given protocol.">ProtocolInfo</a> object for this <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> and the setting of the <a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba44ffd38a6dea695cbe2b34efdcc6cf27">MessageFlags::Partial</a> flag passed in to this overload for protocols that support it. The following table lists relevant combinations, (an asterisk (*) indicates that the setting of this bit does not matter in this case). </p>
<table class="doxtable">
<tr>
<th><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a9c5e107a7ef19d3e220621a076c8b33aa236f39dc6b3976c03626d1df57391934" title="Honors message boundariesas opposed to a stream-oriented protocol where there is no concept of messa...">ServiceFlags1::MessageOriented</a></th><th><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a9c5e107a7ef19d3e220621a076c8b33aa66575df0dc27356e775f77a4235d4ce1" title="A message-oriented protocol, but message boundaries are ignored for all receipts. This is convenient ...">ServiceFlags1::PseudoStream</a></th><th><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba44ffd38a6dea695cbe2b34efdcc6cf27">MessageFlags::Partial</a></th><th>Act as  </th></tr>
<tr>
<td>not set</td><td>*</td><td>*</td><td>Byte stream  </td></tr>
<tr>
<td>*</td><td>Set</td><td>*</td><td>Byte stream  </td></tr>
<tr>
<td>Set</td><td>Not set</td><td>set</td><td>Byte stream  </td></tr>
<tr>
<td>set</td><td>Not set</td><td>Not set</td><td>Message oriented  </td></tr>
</table>
<p>The buffers are filled in the order in which they appear in the array pointed to by <code>buffers</code>, and the buffers are packed so that no holes are created. </p>
<p>If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the <code>WSABUF</code> structures before returning from this call. This enables applications to build stack-based <code>WSABUF</code> arrays pointed to by the <code>buffers</code> parameter. </p>
<p>For byte stream-style sockets (for example, type <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22aeae835e83c0494a376229f254f7d3392">SocketType::Stream&lt;c&gt;</a>), incoming data is placed into the buffers until the buffers are filled, the connection is closed, or the internally buffered data is exhausted. Regardless of whether or not the incoming data fills all the buffers, the completion indication occurs for overlapped sockets. </code></p>
<p><code> </code></p>
<p><code> For message-oriented sockets (for example, type <code>SocketType::Dgram</code>), an incoming message is placed into the buffers up to the total size of the buffers, and the completion indication occurs for overlapped sockets. If the message is larger than the buffers, the buffers are filled with the first part of the message. If the <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba44ffd38a6dea695cbe2b34efdcc6cf27">MessageFlags::Partial</a></code> feature is supported by the underlying service provider, the <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba44ffd38a6dea695cbe2b34efdcc6cf27">MessageFlags::Partial</a></code> flag is set in <code>flags</code> and subsequent receive operations will retrieve the rest of the message. If <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba44ffd38a6dea695cbe2b34efdcc6cf27">MessageFlags::Partial</a></code> is not supported but the protocol is reliable, <code>Receive</code> throws an exception for <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88ab072d76a82d51f57fcd56facd084084f" title="A message sent on a datagram socket was larger than the internal message buffer or some other network...">WinError::WsaMessageSize</a></code> and a subsequent receive operation with a larger buffer can be used to retrieve the entire message. Otherwise, (that is, the protocol is unreliable and does not support <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba44ffd38a6dea695cbe2b34efdcc6cf27">MessageFlags::Partial</a></code>), the excess data is lost, and <code>Receive</code> throws an exception for <code><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88ab072d76a82d51f57fcd56facd084084f" title="A message sent on a datagram socket was larger than the internal message buffer or some other network...">WinError::WsaMessageSize</a></code>. </code></p>
<p><code> </code></p>
<p><code> For connection-oriented sockets, <code>Receive</code> can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read (as indicated by a zero return value to indicate success, and <code>numberOfBytesRecvd</code> value of zero) indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a failure with an error code of <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88a9fab14150307be2a14d5a3d02540d292" title="Returned by WSARecv or WSARecvFrom to indicate the remote party has initiated a graceful shutdown seq...">WinError::WsaDisconnected</a> is used to indicate graceful closure. In any case a return error code of <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88a2a52f62ea8e985a8f4f3c7df3529b65a" title="An existing connection was forcibly closed by the remote host.">WinError::WsaConnectionReset</a> indicates an abortive close has occurred. </code></p>
<p><code> </code></p>
<p><code> </code></p>

</div>
</div>
<a id="ae33bd465c14889cc8fe03d704ccb04e5" name="ae33bd465c14889cc8fe03d704ccb04e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33bd465c14889cc8fe03d704ccb04e5">&#9670;&#160;</a></span>Receive() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Receive </td>
          <td>(</td>
          <td class="paramtype">LPWSABUF</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e7f7b794b05d0f1ac325022f388f87b" name="a3e7f7b794b05d0f1ac325022f388f87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7f7b794b05d0f1ac325022f388f87b">&#9670;&#160;</a></span>Receive() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::Receive </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>minimumNumberOfBytesToRead</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8ca2b3dca5a30bcc95637dd0c8ed469" name="ad8ca2b3dca5a30bcc95637dd0c8ed469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ca2b3dca5a30bcc95637dd0c8ed469">&#9670;&#160;</a></span>Receive() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::Receive </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesToRead</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90bd53c565130a8662546ea40b4b05da" name="a90bd53c565130a8662546ea40b4b05da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bd53c565130a8662546ea40b4b05da">&#9670;&#160;</a></span>Receive() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::Receive </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesToRead</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Receive function receives data from a connected socket or a bound connectionless socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer to receive the incoming data. </td></tr>
    <tr><td class="paramname">numberOfBytesToRead</td><td>The length, in bytes, of the buffer pointed to by the buf parameter. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of flags that influences the behavior of this function. See remarks below. See the Remarks section for details on the possible value for this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If no error occurs, the function returns the number of bytes received and the buffer pointed to by the <code>buffer</code> parameter will contain the received data. If the connection has been gracefully closed, or the operation timed out, the return value is zero. </dd></dl>
<p>The <code>Receive</code> function is used to read incoming data on connection-oriented sockets, or connectionless sockets. When using a connection-oriented protocol, the sockets must be connected before calling <code>Receive</code>. When using a connectionless protocol, the sockets must be bound before calling <code>Receive</code>. </p>
<p>The local address of the socket must be known. For server applications, use an explicit bind function or an implicit Accept. Explicit binding is discouraged for client applications. For client applications, the socket can become bound implicitly to a local address using Connect, SendTo, or JoinLeaf. </p>
<p>For connected or connectionless sockets, the <code>Receive</code> function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are (silently) discarded. </p>
<p>For connection-oriented sockets (<a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a41c18c45f9aec288e310cc192f2e0b22aeae835e83c0494a376229f254f7d3392">SocketType::Stream</a> for example), calling <code>Receive</code> will return as much data as is currently availableup to the size of the buffer specified. If the socket has been configured for in-line reception of OOB data (socket option SO_OOBINLINE) and OOB data is yet unread, only OOB data will be returned. The application can use the Ioctl functions to determine whether any more OOB data remains to be read. </p>

</div>
</div>
<a id="ae34eff52687a8ae277dad540f891d30a" name="ae34eff52687a8ae277dad540f891d30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34eff52687a8ae277dad540f891d30a">&#9670;&#160;</a></span>Receive() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Receive </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesToRead</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesReceived</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a394907beabd7d719805136cd0360e0" name="a8a394907beabd7d719805136cd0360e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a394907beabd7d719805136cd0360e0">&#9670;&#160;</a></span>ReceiveBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> Harlinn::Common::Core::IO::Sockets::Socket::ReceiveBufferSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0ef718aa63e4fb03ea49a3a24b35d97" name="af0ef718aa63e4fb03ea49a3a24b35d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ef718aa63e4fb03ea49a3a24b35d97">&#9670;&#160;</a></span>ReceiveFrom() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::ReceiveFrom </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23945ef27a6c59db04145b0118092c64" name="a23945ef27a6c59db04145b0118092c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23945ef27a6c59db04145b0118092c64">&#9670;&#160;</a></span>ReceiveFrom() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::ReceiveFrom </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *</td>          <td class="paramname"><span class="paramname"><em>fromAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>fromAddressLength</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af41912c908db84ac8152e25c68d3ba7b" name="af41912c908db84ac8152e25c68d3ba7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41912c908db84ac8152e25c68d3ba7b">&#9670;&#160;</a></span>ReceiveFrom() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ReceiveFrom </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesRecvd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *</td>          <td class="paramname"><span class="paramname"><em>fromAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>fromAddressLength</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99d3b8dc443e3f846f341cd1ec4cadcd" name="a99d3b8dc443e3f846f341cd1ec4cadcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d3b8dc443e3f846f341cd1ec4cadcd">&#9670;&#160;</a></span>ReceiveFrom() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::ReceiveFrom </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a627cfccbfd035091ba2aefb3d0db4726" name="a627cfccbfd035091ba2aefb3d0db4726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627cfccbfd035091ba2aefb3d0db4726">&#9670;&#160;</a></span>ReceiveFrom() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ReceiveFrom </td>
          <td>(</td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesRecvd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fromAddress</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad29d00e445a8997ea865145b292efec" name="aad29d00e445a8997ea865145b292efec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad29d00e445a8997ea865145b292efec">&#9670;&#160;</a></span>ReceiveFrom() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ReceiveFrom </td>
          <td>(</td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesRecvd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *</td>          <td class="paramname"><span class="paramname"><em>fromAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>fromAddressLength</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a581663117e37f9401a29e0bda59b5b4d" name="a581663117e37f9401a29e0bda59b5b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581663117e37f9401a29e0bda59b5b4d">&#9670;&#160;</a></span>ReceiveFrom() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ReceiveFrom </td>
          <td>(</td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesRecvd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *</td>          <td class="paramname"><span class="paramname"><em>fromAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>fromAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6508ff098fcbaac4555f9be6a7c5341b" name="a6508ff098fcbaac4555f9be6a7c5341b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6508ff098fcbaac4555f9be6a7c5341b">&#9670;&#160;</a></span>ReceiveFrom() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ReceiveFrom </td>
          <td>(</td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fromAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4870c22e623ef67725dbd9bbcb5b7fa8" name="a4870c22e623ef67725dbd9bbcb5b7fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4870c22e623ef67725dbd9bbcb5b7fa8">&#9670;&#160;</a></span>ReceiveFrom() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::ReceiveFrom </td>
          <td>(</td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a> *</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sockaddr *</td>          <td class="paramname"><span class="paramname"><em>fromAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>fromAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa53c992215a7b6666ffa13fbd4f0a061" name="aa53c992215a7b6666ffa13fbd4f0a061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53c992215a7b6666ffa13fbd4f0a061">&#9670;&#160;</a></span>ReceiveTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> Harlinn::Common::Core::IO::Sockets::Socket::ReceiveTimeout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acca1b924e50caea6beddc01b29df9992" name="acca1b924e50caea6beddc01b29df9992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca1b924e50caea6beddc01b29df9992">&#9670;&#160;</a></span>RecvMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::RecvMsg </td>
          <td>(</td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAMSG</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPDWORD</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesRecvd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4b7c5d38942b460381fdb65681ff89b" name="aa4b7c5d38942b460381fdb65681ff89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b7c5d38942b460381fdb65681ff89b">&#9670;&#160;</a></span>Release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SOCKET Harlinn::Common::Core::IO::Sockets::Socket::Release </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcf51f49082f3d14930f4d612b5b3f8b" name="adcf51f49082f3d14930f4d612b5b3f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf51f49082f3d14930f4d612b5b3f8b">&#9670;&#160;</a></span>Select() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Select </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *</td>          <td class="paramname"><span class="paramname"><em>readfds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *</td>          <td class="paramname"><span class="paramname"><em>writefds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *</td>          <td class="paramname"><span class="paramname"><em>exceptfds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const timeval *</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>selectResult</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f2c12f59c4b2a7211fb31eb24903a75" name="a6f2c12f59c4b2a7211fb31eb24903a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2c12f59c4b2a7211fb31eb24903a75">&#9670;&#160;</a></span>Select() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Harlinn::Common::Core::IO::Sockets::Socket::Select </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *</td>          <td class="paramname"><span class="paramname"><em>readfds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *</td>          <td class="paramname"><span class="paramname"><em>writefds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *</td>          <td class="paramname"><span class="paramname"><em>exceptfds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const timeval *</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a25cdf12bc67f4faddc26aa143ca1722a" name="a25cdf12bc67f4faddc26aa143ca1722a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cdf12bc67f4faddc26aa143ca1722a">&#9670;&#160;</a></span>Send() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::Send </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesToSend</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e6c6ddcc435da602b8e54a798c695a6" name="a3e6c6ddcc435da602b8e54a798c695a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6c6ddcc435da602b8e54a798c695a6">&#9670;&#160;</a></span>Send() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Send </td>
          <td>(</td>
          <td class="paramtype">LPWSABUF</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPDWORD</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesSent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afee30e90743ccf63f3169003cc68cb5c" name="afee30e90743ccf63f3169003cc68cb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee30e90743ccf63f3169003cc68cb5c">&#9670;&#160;</a></span>Send() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Send </td>
          <td>(</td>
          <td class="paramtype">LPWSABUF</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPDWORD</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesSent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fc929d757f713a01ee9326a55ceba1a" name="a1fc929d757f713a01ee9326a55ceba1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc929d757f713a01ee9326a55ceba1a">&#9670;&#160;</a></span>Send() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Send </td>
          <td>(</td>
          <td class="paramtype">LPWSABUF</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae595886cdc9fc540b367fd5ac6849081" name="ae595886cdc9fc540b367fd5ac6849081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae595886cdc9fc540b367fd5ac6849081">&#9670;&#160;</a></span>SendBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> Harlinn::Common::Core::IO::Sockets::Socket::SendBufferSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39dccd4e54c3f98318bc9c1f421bbf29" name="a39dccd4e54c3f98318bc9c1f421bbf29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dccd4e54c3f98318bc9c1f421bbf29">&#9670;&#160;</a></span>SendMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::SendMsg </td>
          <td>(</td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAMSG</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPDWORD</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesSent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04dace19700d8bc9624e4686b40056a4" name="a04dace19700d8bc9624e4686b40056a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dace19700d8bc9624e4686b40056a4">&#9670;&#160;</a></span>SendTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a> Harlinn::Common::Core::IO::Sockets::Socket::SendTimeout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a313c459544cf971a93d11d11decedbe1" name="a313c459544cf971a93d11d11decedbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313c459544cf971a93d11d11decedbe1">&#9670;&#160;</a></span>SendTo() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::SendTo </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesToSend</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>destinationAddress</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36458f3e13faf23e1fbee1eb0f9354c9" name="a36458f3e13faf23e1fbee1eb0f9354c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36458f3e13faf23e1fbee1eb0f9354c9">&#9670;&#160;</a></span>SendTo() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::SendTo </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesToSend</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_address.html">Sockets::Address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>destinationAddress</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b1d557aac132c6ad215dbe6c80fb2b2" name="a3b1d557aac132c6ad215dbe6c80fb2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1d557aac132c6ad215dbe6c80fb2b2">&#9670;&#160;</a></span>SendTo() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long long Harlinn::Common::Core::IO::Sockets::Socket::SendTo </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesToSend</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131baba6adf97f83acf6453d4a6a4b1070f3754">MessageFlags::None</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>destinationAddress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destinationAddressSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac147cc0d7412dd1c1a7ec9df75b4eb31" name="ac147cc0d7412dd1c1a7ec9df75b4eb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac147cc0d7412dd1c1a7ec9df75b4eb31">&#9670;&#160;</a></span>SendTo() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::SendTo </td>
          <td>(</td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesSent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>destinationAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destinationAddressLength</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae89ceb189c0e269c7f937923382ed853" name="ae89ceb189c0e269c7f937923382ed853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89ceb189c0e269c7f937923382ed853">&#9670;&#160;</a></span>SendTo() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::SendTo </td>
          <td>(</td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesSent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>destinationAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destinationAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e2e65a0e59717e876d4418ae4e986e3" name="a4e2e65a0e59717e876d4418ae4e986e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2e65a0e59717e876d4418ae4e986e3">&#9670;&#160;</a></span>SendTo() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::SendTo </td>
          <td>(</td>
          <td class="paramtype">WSABUF *</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>bufferCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OVERLAPPED *</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#aec031f800d2c8ffd77b61cc5e8131bab">MessageFlags</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sockaddr *</td>          <td class="paramname"><span class="paramname"><em>destinationAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>destinationAddressLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPWSAOVERLAPPED_COMPLETION_ROUTINE</td>          <td class="paramname"><span class="paramname"><em>completionRoutine</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="addd72b3aa2315d4ad6fe90df2f4e010d" name="addd72b3aa2315d4ad6fe90df2f4e010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd72b3aa2315d4ad6fe90df2f4e010d">&#9670;&#160;</a></span>SetBroadcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetBroadcast </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>broadcast</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Configure the socket to broadcast data when sending. </p>
<p>This function is only valid for protocols that support broadcasting (IPX and UDP, for example). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">broadcast</td><td><code>true</code> to turn broadcasting on, <code>false</code> to turn broadcasting off. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3e68d5fb8922ed78024ee9e8b85c783" name="ac3e68d5fb8922ed78024ee9e8b85c783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e68d5fb8922ed78024ee9e8b85c783">&#9670;&#160;</a></span>SetConditionalAccept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetConditionalAccept </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>conditionalAccept</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedd90160e7e62ae319007143f1aa0d90" name="aedd90160e7e62ae319007143f1aa0d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd90160e7e62ae319007143f1aa0d90">&#9670;&#160;</a></span>SetDebug()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetDebug </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>debug</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1824c5e365222350d80ff14ca89b74d8" name="a1824c5e365222350d80ff14ca89b74d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1824c5e365222350d80ff14ca89b74d8">&#9670;&#160;</a></span>SetDontLinger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetDontLinger </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>dontLinger</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a205f1c2fed93ea4e2bda2c2afe08cea3" name="a205f1c2fed93ea4e2bda2c2afe08cea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205f1c2fed93ea4e2bda2c2afe08cea3">&#9670;&#160;</a></span>SetKeepAlive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetKeepAlive </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepAlive</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a719521b00ba6f6054511ccdaeb0d09f2" name="a719521b00ba6f6054511ccdaeb0d09f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719521b00ba6f6054511ccdaeb0d09f2">&#9670;&#160;</a></span>SetLinger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetLinger </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>linger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a16d9ed304994b417f1b60c1431408c7e">UInt16</a></td>          <td class="paramname"><span class="paramname"><em>seconds</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b2306c62344b1e7448408971aa27ec8" name="a2b2306c62344b1e7448408971aa27ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2306c62344b1e7448408971aa27ec8">&#9670;&#160;</a></span>SetLinger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetLinger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_linger.html">Sockets::Linger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linger</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06878b2cd22f756e4ca5d114e015d279" name="a06878b2cd22f756e4ca5d114e015d279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06878b2cd22f756e4ca5d114e015d279">&#9670;&#160;</a></span>SetNoDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetNoDelay </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>noDelay</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06a6311ad9d6188996d7eafad7d4ef22" name="a06a6311ad9d6188996d7eafad7d4ef22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a6311ad9d6188996d7eafad7d4ef22">&#9670;&#160;</a></span>SetReceiveBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetReceiveBufferSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>receiveBufferSize</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e7d3789085e52d6061f7e57e2e6f2be" name="a2e7d3789085e52d6061f7e57e2e6f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7d3789085e52d6061f7e57e2e6f2be">&#9670;&#160;</a></span>SetReceiveTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetReceiveTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>timeoutInMillis</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the timeout, in milliseconds, for blocking receive calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeoutInMillis</td><td>the timeout value</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9a7bb851cdb65983e2a089319d108b2" name="ac9a7bb851cdb65983e2a089319d108b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a7bb851cdb65983e2a089319d108b2">&#9670;&#160;</a></span>SetSendBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetSendBufferSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>sendBufferSize</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e7535b8d36b76dd09ce1fb2996585d4" name="a4e7535b8d36b76dd09ce1fb2996585d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7535b8d36b76dd09ce1fb2996585d4">&#9670;&#160;</a></span>SetSendTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetSendTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>timeoutInMillis</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8869e38501a8688d970fa073f6756564" name="a8869e38501a8688d970fa073f6756564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8869e38501a8688d970fa073f6756564">&#9670;&#160;</a></span>SetSocketOption() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetSocketOption </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>option</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>optionData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>optionDataLength</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a socket option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level at which the option is defined (for example, SOL_SOCKET). </td></tr>
    <tr><td class="paramname">option</td><td>The socket option for which the value is to be set (for example, SO_BROADCAST). The option parameter must be a socket option defined within the specified level, or behavior is undefined. </td></tr>
    <tr><td class="paramname">optionData</td><td>A pointer to the buffer in which the value for the requested option is specified. </td></tr>
    <tr><td class="paramname">optionDataLength</td><td>The size, in bytes, of the buffer pointed to by the optionData parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69439ee5c3fe9ac23589ba759350892d" name="a69439ee5c3fe9ac23589ba759350892d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69439ee5c3fe9ac23589ba759350892d">&#9670;&#160;</a></span>SetSocketOption() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetSocketOption </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>option</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#aa879caba763494ad2c3cd321ce4bbdda">Int32</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a socket option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level at which the option is defined (for example, SOL_SOCKET). </td></tr>
    <tr><td class="paramname">option</td><td>The socket option for which the value is to be set (for example, SO_BROADCAST). The option parameter must be a socket option defined within the specified level, or behavior is undefined. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set for the option. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1008a88aa27137cb93779f5afac0f033" name="a1008a88aa27137cb93779f5afac0f033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1008a88aa27137cb93779f5afac0f033">&#9670;&#160;</a></span>SetSocketOption() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::SetSocketOption </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>option</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a9633dfa5c015d8773e20d1aa6035a966">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a socket option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level at which the option is defined (for example, SOL_SOCKET). </td></tr>
    <tr><td class="paramname">option</td><td>The socket option for which the value is to be set (for example, SO_BROADCAST). The option parameter must be a socket option defined within the specified level, or behavior is undefined. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set for the option. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1d0b07cb8ee5ce027a8057b4de210af" name="ac1d0b07cb8ee5ce027a8057b4de210af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d0b07cb8ee5ce027a8057b4de210af">&#9670;&#160;</a></span>Shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::Shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html#a598b7c0e2b0e2e532909ac8dc0e05d5c">ShutdownFlag</a></td>          <td class="paramname"><span class="paramname"><em>flag</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad67f3016d484dc2bdb10553c830b241c" name="ad67f3016d484dc2bdb10553c830b241c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67f3016d484dc2bdb10553c830b241c">&#9670;&#160;</a></span>ThrowIfSocketIsValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::ThrowIfSocketIsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>socket</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a76637c58a841b24a4c2bc9244a206ae7" name="a76637c58a841b24a4c2bc9244a206ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76637c58a841b24a4c2bc9244a206ae7">&#9670;&#160;</a></span>ThrowLastSocketError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::ThrowLastSocketError </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebe20a76be0e292d44b10c5898941af3" name="aebe20a76be0e292d44b10c5898941af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe20a76be0e292d44b10c5898941af3">&#9670;&#160;</a></span>ThrowLastSocketError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::ThrowLastSocketError </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lineNumber</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b6be2adb3f198211a2676568a0d5031" name="a0b6be2adb3f198211a2676568a0d5031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6be2adb3f198211a2676568a0d5031">&#9670;&#160;</a></span>ThrowSocketError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::ThrowSocketError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a></td>          <td class="paramname"><span class="paramname"><em>error</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d2de2f6cad54d46fb4c4ae3ba3f331f" name="a2d2de2f6cad54d46fb4c4ae3ba3f331f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2de2f6cad54d46fb4c4ae3ba3f331f">&#9670;&#160;</a></span>ThrowSocketError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::ThrowSocketError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a></td>          <td class="paramname"><span class="paramname"><em>error</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lineNumber</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a453435b4328a488f6a68f04c547a7d4b" name="a453435b4328a488f6a68f04c547a7d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453435b4328a488f6a68f04c547a7d4b">&#9670;&#160;</a></span>TransmitFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::TransmitFile </td>
          <td>(</td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>hSocket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE</td>          <td class="paramname"><span class="paramname"><em>hFile</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesToWrite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>numberOfBytesPerSend</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPOVERLAPPED</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPTRANSMIT_FILE_BUFFERS</td>          <td class="paramname"><span class="paramname"><em>transmitBuffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac94499d43606238a086914af57d500fe" name="ac94499d43606238a086914af57d500fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94499d43606238a086914af57d500fe">&#9670;&#160;</a></span>TransmitPackets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html#a7db81262edfb59ceb8618fa43cc28a88">WinError</a> Harlinn::Common::Core::IO::Sockets::Socket::TransmitPackets </td>
          <td>(</td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>hSocket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPTRANSMIT_PACKETS_ELEMENT</td>          <td class="paramname"><span class="paramname"><em>packetArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>elementCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>sendSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LPOVERLAPPED</td>          <td class="paramname"><span class="paramname"><em>overlapped</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdb10903a50fa37e5fa7c18d830d07bb" name="afdb10903a50fa37e5fa7c18d830d07bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb10903a50fa37e5fa7c18d830d07bb">&#9670;&#160;</a></span>UpdateAcceptContext() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Common::Core::IO::Sockets::Socket::UpdateAcceptContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>listenerSocket</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is used with the AcceptEx function. This option updates the properties of the socket which are inherited from the listening socket. This function should be called if the PeerName, Name, GetSocketOption, or SetSocketOption functions are to be used on the accepted socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listenerSocketHandle</td><td>The listening <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a079cab3b6b36107cff8a7b52f002b618" name="a079cab3b6b36107cff8a7b52f002b618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079cab3b6b36107cff8a7b52f002b618">&#9670;&#160;</a></span>UpdateAcceptContext() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Harlinn::Common::Core::IO::Sockets::Socket::UpdateAcceptContext </td>
          <td>(</td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>listenerSocketHandle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOCKET</td>          <td class="paramname"><span class="paramname"><em>acceptingSocketHandle</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is used with the AcceptEx function. This option updates the properties of the socket which are inherited from the listening socket. This function should be called if the PeerName, Name, GetSocketOption, or SetSocketOption functions are to be used on the accepted socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listenerSocketHandle</td><td>The listening <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> </td></tr>
    <tr><td class="paramname">acceptingSocketHandle</td><td>The <a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html" title="Represents a socket descriptor that is bound to a specific transport-service provider.">Socket</a> to update </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a218405d3d7679710692b170a9137c156" name="a218405d3d7679710692b170a9137c156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218405d3d7679710692b170a9137c156">&#9670;&#160;</a></span>socket_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SOCKET Harlinn::Common::Core::IO::Sockets::Socket::socket_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_h_c_c_socket_8h.html">HCCSocket.h</a></li>
<li><a class="el" href="_h_c_c_socket_8cpp.html">HCCSocket.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_harlinn.html">Harlinn</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_common.html">Common</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_common_1_1_core.html">Core</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o.html">IO</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets.html">Sockets</a></li><li class="navelem"><a class="el" href="class_harlinn_1_1_common_1_1_core_1_1_i_o_1_1_sockets_1_1_socket.html">Socket</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>

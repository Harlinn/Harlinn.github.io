<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Harlinn.Windows: Harlinn::Windows::Media::StreamingStreamSink Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Harlinn.Windows<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_harlinn_1_1_windows_1_1_media_1_1_streaming_stream_sink.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_harlinn_1_1_windows_1_1_media_1_1_streaming_stream_sink-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Harlinn::Windows::Media::StreamingStreamSink Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;HWStreamingMediaSink.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Harlinn::Windows::Media::StreamingStreamSink:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_harlinn_1_1_windows_1_1_media_1_1_streaming_stream_sink__inherit__graph.svg" width="491" height="80"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Harlinn::Windows::Media::StreamingStreamSink:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_harlinn_1_1_windows_1_1_media_1_1_streaming_stream_sink__coll__graph.svg" width="491" height="80"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada40535f46995ed0f347e3d912fb5ebb" id="r_ada40535f46995ed0f347e3d912fb5ebb"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada40535f46995ed0f347e3d912fb5ebb">GetEvent</a> (DWORD <a class="el" href="_h_c_c_date_time_8cpp.html#a88091f3cf7c0f5215895ddbdef078de4">dwFlags</a>, __RPC__deref_out_opt IMFMediaEvent **ppEvent) override</td></tr>
<tr class="memdesc:ada40535f46995ed0f347e3d912fb5ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the next event in the queue. This method is synchronous.  <br /></td></tr>
<tr class="separator:ada40535f46995ed0f347e3d912fb5ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950761dee87df883dd7bc3497787c02a" id="r_a950761dee87df883dd7bc3497787c02a"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a950761dee87df883dd7bc3497787c02a">BeginGetEvent</a> (IMFAsyncCallback *pCallback, IUnknown *punkState) override</td></tr>
<tr class="memdesc:a950761dee87df883dd7bc3497787c02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an asynchronous request for the next event in the queue.  <br /></td></tr>
<tr class="separator:a950761dee87df883dd7bc3497787c02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484afba9b275697a4a880eb0f587d783" id="r_a484afba9b275697a4a880eb0f587d783"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a484afba9b275697a4a880eb0f587d783">EndGetEvent</a> (IMFAsyncResult *pResult, _Out_ IMFMediaEvent **ppEvent) override</td></tr>
<tr class="memdesc:a484afba9b275697a4a880eb0f587d783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes an asynchronous request for the next event in the queue.  <br /></td></tr>
<tr class="separator:a484afba9b275697a4a880eb0f587d783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15f66553477a5095f6357d588d381c1" id="r_ad15f66553477a5095f6357d588d381c1"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad15f66553477a5095f6357d588d381c1">QueueEvent</a> (MediaEventType met, __RPC__in REFGUID guidExtendedType, HRESULT hrStatus, __RPC__in_opt const PROPVARIANT *pvValue) override</td></tr>
<tr class="memdesc:ad15f66553477a5095f6357d588d381c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a new event in the object's queue.  <br /></td></tr>
<tr class="separator:ad15f66553477a5095f6357d588d381c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01bd6ff1d7484d44ce36b8ed850dd83" id="r_ac01bd6ff1d7484d44ce36b8ed850dd83"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac01bd6ff1d7484d44ce36b8ed850dd83">GetMediaSink</a> (__RPC__deref_out_opt IMFMediaSink **ppMediaSink) override</td></tr>
<tr class="memdesc:ac01bd6ff1d7484d44ce36b8ed850dd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the media sink that owns this stream sink.  <br /></td></tr>
<tr class="separator:ac01bd6ff1d7484d44ce36b8ed850dd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcb8124e1726c2bf4663925d0753ae9" id="r_a8dcb8124e1726c2bf4663925d0753ae9"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dcb8124e1726c2bf4663925d0753ae9">GetIdentifier</a> (__RPC__out DWORD *pdwIdentifier) override</td></tr>
<tr class="memdesc:a8dcb8124e1726c2bf4663925d0753ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the stream identifier for this stream sink.  <br /></td></tr>
<tr class="separator:a8dcb8124e1726c2bf4663925d0753ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffb577ead1a35e25d94715c8b0710c4" id="r_a9ffb577ead1a35e25d94715c8b0710c4"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ffb577ead1a35e25d94715c8b0710c4">GetMediaTypeHandler</a> (__RPC__deref_out_opt IMFMediaTypeHandler **ppHandler) override</td></tr>
<tr class="memdesc:a9ffb577ead1a35e25d94715c8b0710c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the media type handler for the stream sink. You can use the media type handler to find which formats the stream supports, and to set the media type on the stream.  <br /></td></tr>
<tr class="separator:a9ffb577ead1a35e25d94715c8b0710c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2875ec9a04dfd02f8ae93c44b6bb9d" id="r_a2f2875ec9a04dfd02f8ae93c44b6bb9d"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f2875ec9a04dfd02f8ae93c44b6bb9d">ProcessSample</a> (__RPC__in_opt IMFSample *pSample) override</td></tr>
<tr class="memdesc:a2f2875ec9a04dfd02f8ae93c44b6bb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delivers a sample to the stream. The media sink processes the sample.  <br /></td></tr>
<tr class="separator:a2f2875ec9a04dfd02f8ae93c44b6bb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3c258bf98f0bc5d7df9966999279e1" id="r_acb3c258bf98f0bc5d7df9966999279e1"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb3c258bf98f0bc5d7df9966999279e1">PlaceMarker</a> (MFSTREAMSINK_MARKER_TYPE eMarkerType, __RPC__in const PROPVARIANT *pvarMarkerValue, __RPC__in const PROPVARIANT *pvarContextValue) override</td></tr>
<tr class="memdesc:acb3c258bf98f0bc5d7df9966999279e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a marker in the stream.  <br /></td></tr>
<tr class="separator:acb3c258bf98f0bc5d7df9966999279e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14b3de5d64fdec12afce1f7925d2b5f" id="r_ac14b3de5d64fdec12afce1f7925d2b5f"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac14b3de5d64fdec12afce1f7925d2b5f">Flush</a> () override</td></tr>
<tr class="memdesc:ac14b3de5d64fdec12afce1f7925d2b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the stream sink to drop any samples that it has received and has not rendered yet.  <br /></td></tr>
<tr class="separator:ac14b3de5d64fdec12afce1f7925d2b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f4a971b122a4add2015d287f5e46ac" id="r_ab3f4a971b122a4add2015d287f5e46ac"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3f4a971b122a4add2015d287f5e46ac">IsMediaTypeSupported</a> (IMFMediaType *pMediaType, _Outptr_opt_result_maybenull_ IMFMediaType **ppMediaType) override</td></tr>
<tr class="memdesc:ab3f4a971b122a4add2015d287f5e46ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether the object supports a specified media type.  <br /></td></tr>
<tr class="separator:ab3f4a971b122a4add2015d287f5e46ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988057adbc10434413560403eef82960" id="r_a988057adbc10434413560403eef82960"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a988057adbc10434413560403eef82960">GetMediaTypeCount</a> (__RPC__out DWORD *pdwTypeCount) override</td></tr>
<tr class="memdesc:a988057adbc10434413560403eef82960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of media types in the object's list of supported media types.  <br /></td></tr>
<tr class="separator:a988057adbc10434413560403eef82960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267557820c0d370641966b9ef9dd93a3" id="r_a267557820c0d370641966b9ef9dd93a3"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a267557820c0d370641966b9ef9dd93a3">GetMediaTypeByIndex</a> (DWORD dwIndex, _Outptr_ IMFMediaType **ppType) override</td></tr>
<tr class="memdesc:a267557820c0d370641966b9ef9dd93a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a media type from the object's list of supported media types.  <br /></td></tr>
<tr class="separator:a267557820c0d370641966b9ef9dd93a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac106ebfc88bf072c82abc0fb0a6c420c" id="r_ac106ebfc88bf072c82abc0fb0a6c420c"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac106ebfc88bf072c82abc0fb0a6c420c">SetCurrentMediaType</a> (IMFMediaType *pMediaType) override</td></tr>
<tr class="memdesc:ac106ebfc88bf072c82abc0fb0a6c420c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the object's media type.  <br /></td></tr>
<tr class="separator:ac106ebfc88bf072c82abc0fb0a6c420c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31803f45f87e8fced79dc399daa018d4" id="r_a31803f45f87e8fced79dc399daa018d4"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31803f45f87e8fced79dc399daa018d4">GetCurrentMediaType</a> (_Outptr_ IMFMediaType **ppMediaType) override</td></tr>
<tr class="memdesc:a31803f45f87e8fced79dc399daa018d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current media type of the object.  <br /></td></tr>
<tr class="separator:a31803f45f87e8fced79dc399daa018d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc35e399e4e2c6311fe5b14f8da7a79" id="r_aedc35e399e4e2c6311fe5b14f8da7a79"><td class="memItemLeft" align="right" valign="top">virtual HRESULT STDMETHODCALLTYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedc35e399e4e2c6311fe5b14f8da7a79">GetMajorType</a> (__RPC__out GUID *pguidMajorType) override</td></tr>
<tr class="memdesc:aedc35e399e4e2c6311fe5b14f8da7a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the major media type of the object.  <br /></td></tr>
<tr class="separator:aedc35e399e4e2c6311fe5b14f8da7a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a167fcf8c5c65f77f91fe0e80863e1ac5" id="r_a167fcf8c5c65f77f91fe0e80863e1ac5"><td class="memItemLeft" align="right" valign="top">DWORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a167fcf8c5c65f77f91fe0e80863e1ac5">streamId_</a> = 0</td></tr>
<tr class="separator:a167fcf8c5c65f77f91fe0e80863e1ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a950761dee87df883dd7bc3497787c02a" name="a950761dee87df883dd7bc3497787c02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950761dee87df883dd7bc3497787c02a">&#9670;&#160;</a></span>BeginGetEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::BeginGetEvent </td>
          <td>(</td>
          <td class="paramtype">IMFAsyncCallback *</td>          <td class="paramname"><span class="paramname"><em>pCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IUnknown *</td>          <td class="paramname"><span class="paramname"><em>punkState</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins an asynchronous request for the next event in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallback</td><td>Pointer to the IMFAsyncCallback interface of a callback object. The client must implement this interface. </td></tr>
    <tr><td class="paramname">punkState</td><td>Pointer to the IUnknown interface of a state object, defined by the caller. This parameter can be NULL. You can use this object to hold state information. The object is returned to the caller when the callback is invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
E_INVALIDARG: NULL pointer argument.  </li>
<li>
MF_E_MULTIPLE_BEGIN: There is a pending request with the same callback pointerand a different state object.  </li>
<li>
MF_E_MULTIPLE_SUBSCRIBERS: There is a pending request with a different callback pointer.  </li>
<li>
MF_E_SHUTDOWN: The object was shut down.  </li>
<li>
MF_S_MULTIPLE_BEGIN: There is a pending request with the same callback pointerand state object.  </li>
</ul>
</dd></dl>
<p>When a new event is available, the event generator calls the IMFAsyncCallback::Invoke method. The Invoke method should call IMFMediaEventGenerator::EndGetEvent to get a pointer to the IMFMediaEvent interface, and use that interface to examine the event. </p>
<p>Do not call BeginGetEvent a second time before calling EndGetEvent. While the first call is still pending, additional calls to the same object will fail. Also, the IMFMediaEventGenerator::GetEvent method fails if an asynchronous request is still pending. </p>

</div>
</div>
<a id="a484afba9b275697a4a880eb0f587d783" name="a484afba9b275697a4a880eb0f587d783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484afba9b275697a4a880eb0f587d783">&#9670;&#160;</a></span>EndGetEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::EndGetEvent </td>
          <td>(</td>
          <td class="paramtype">IMFAsyncResult *</td>          <td class="paramname"><span class="paramname"><em>pResult</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Out_ IMFMediaEvent **</td>          <td class="paramname"><span class="paramname"><em>ppEvent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes an asynchronous request for the next event in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pResult</td><td>Pointer to the IMFAsyncResult interface. Pass in the same pointer that your callback object received in the Invoke method. </td></tr>
    <tr><td class="paramname">ppEvent</td><td>Receives a pointer to the IMFMediaEvent interface. The caller must release the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_SHUTDOWN: The object was shut down.  </li>
</ul>
</dd></dl>
<p>Call this method from inside your application's IMFAsyncCallback::Invoke method. </p>

</div>
</div>
<a id="ac14b3de5d64fdec12afce1f7925d2b5f" name="ac14b3de5d64fdec12afce1f7925d2b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14b3de5d64fdec12afce1f7925d2b5f">&#9670;&#160;</a></span>Flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::Flush </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes the stream sink to drop any samples that it has received and has not rendered yet. </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_NOT_INITIALIZED: The stream sink has not been initialized yet.You might need to set a media type.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
<li>
MF_E_STREAMSINK_REMOVED: This stream was removed from the media sinkand is no longer valid.  </li>
</ul>
</dd></dl>
<p>If any samples are still queued from previous calls to the IMFStreamSink::ProcessSample method, the media sink immediately discards them, without processing them. This can cause a glitch in the rendered output. The running state of the sink (running, paused, or stopped) does not change. </p>
<p>Any pending marker events from the IMFStreamSink::PlaceMarker method are dispatched immediately, with the status code E_ABORT. </p>
<p>This method is synchronous. It does not return until the sink has discarded all pending samples. </p>

</div>
</div>
<a id="a31803f45f87e8fced79dc399daa018d4" name="a31803f45f87e8fced79dc399daa018d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31803f45f87e8fced79dc399daa018d4">&#9670;&#160;</a></span>GetCurrentMediaType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::GetCurrentMediaType </td>
          <td>(</td>
          <td class="paramtype">_Outptr_ IMFMediaType **</td>          <td class="paramname"><span class="paramname"><em>ppMediaType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the current media type of the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppMediaType</td><td>Receives a pointer to the IMFMediaType interface. The caller must release the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_NOT_INITIALIZED: No media type is set.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ada40535f46995ed0f347e3d912fb5ebb" name="ada40535f46995ed0f347e3d912fb5ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada40535f46995ed0f347e3d912fb5ebb">&#9670;&#160;</a></span>GetEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::GetEvent </td>
          <td>(</td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>dwFlags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__RPC__deref_out_opt IMFMediaEvent **</td>          <td class="paramname"><span class="paramname"><em>ppEvent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the next event in the queue. This method is synchronous. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwFlags</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Specifies one of the following values: </p>
<ul>
<li>
0: The method blocks until the event generator queues an event. </li>
<li>
MF_EVENT_FLAG_NO_WAIT: The method returns immediately. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppEvent</td><td>Receives a pointer to the IMFMediaEvent interface. The caller must release the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded. </li>
<li>
E_INVALIDARG: NULL pointer argument. </li>
<li>
MF_E_MULTIPLE_SUBSCRIBERS: There is a pending request. </li>
<li>
MF_E_NO_EVENTS_AVAILABLE: There are no events in the queue. </li>
<li>
MF_E_SHUTDOWN: The object was shut down. </li>
</ul>
</dd></dl>
<p>This method executes synchronously. </p>
<p>If the queue already contains an event, the method returns S_OK immediately. If the queue does not contain an event, the behavior depends on the value of dwFlags: </p>
<ul>
<li>
If dwFlags is 0, the method blocks indefinitely until a new event is queued, or until the event generator is shut down.  </li>
<li>
If dwFlags is MF_EVENT_FLAG_NO_WAIT, the method fails immediately with the return code MF_E_NO_EVENTS_AVAILABLE.  </li>
</ul>
<p>This method returns MF_E_MULTIPLE_SUBSCRIBERS if you previously called IMFMediaEventGenerator::BeginGetEvent and have not yet called IMFMediaEventGenerator::EndGetEvent. </p>

</div>
</div>
<a id="a8dcb8124e1726c2bf4663925d0753ae9" name="a8dcb8124e1726c2bf4663925d0753ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcb8124e1726c2bf4663925d0753ae9">&#9670;&#160;</a></span>GetIdentifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::GetIdentifier </td>
          <td>(</td>
          <td class="paramtype">__RPC__out DWORD *</td>          <td class="paramname"><span class="paramname"><em>pdwIdentifier</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the stream identifier for this stream sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdwIdentifier</td><td>Receives the stream identifier. If this stream sink was added by calling IMFMediaSink::AddStreamSink, the stream identifier is in the dwStreamSinkIdentifier parameter of that method. Otherwise, the media sink defines the identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
<li>
MF_E_STREAMSINK_REMOVED: This stream was removed from the media sinkand is no longer valid.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aedc35e399e4e2c6311fe5b14f8da7a79" name="aedc35e399e4e2c6311fe5b14f8da7a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc35e399e4e2c6311fe5b14f8da7a79">&#9670;&#160;</a></span>GetMajorType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::GetMajorType </td>
          <td>(</td>
          <td class="paramtype">__RPC__out GUID *</td>          <td class="paramname"><span class="paramname"><em>pguidMajorType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the major media type of the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pguidMajorType</td><td>Receives a GUID that identifies the major type. For a list of possible values, see <a href="https://docs.microsoft.com/en-us/windows/desktop/medfound/media-type-guids">Major Media Types</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </dd></dl>
<p>The major type identifies what kind of data is in the stream, such as audio or video. To get the specific details of the format, call IMFMediaTypeHandler::GetCurrentMediaType. </p>

</div>
</div>
<a id="ac01bd6ff1d7484d44ce36b8ed850dd83" name="ac01bd6ff1d7484d44ce36b8ed850dd83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01bd6ff1d7484d44ce36b8ed850dd83">&#9670;&#160;</a></span>GetMediaSink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::GetMediaSink </td>
          <td>(</td>
          <td class="paramtype">__RPC__deref_out_opt IMFMediaSink **</td>          <td class="paramname"><span class="paramname"><em>ppMediaSink</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the media sink that owns this stream sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppMediaSink</td><td>Receives a pointer to the media sink's IMFMediaSink interface. The caller must release the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
<li>
MF_E_STREAMSINK_REMOVED: This stream was removed from the media sinkand is no longer valid.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a267557820c0d370641966b9ef9dd93a3" name="a267557820c0d370641966b9ef9dd93a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267557820c0d370641966b9ef9dd93a3">&#9670;&#160;</a></span>GetMediaTypeByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::GetMediaTypeByIndex </td>
          <td>(</td>
          <td class="paramtype">DWORD</td>          <td class="paramname"><span class="paramname"><em>dwIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Outptr_ IMFMediaType **</td>          <td class="paramname"><span class="paramname"><em>ppType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a media type from the object's list of supported media types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwIndex</td><td>Zero-based index of the media type to retrieve. To get the number of media types in the list, call IMFMediaTypeHandler::GetMediaTypeCount. </td></tr>
    <tr><td class="paramname">ppType</td><td>Receives a pointer to the IMFMediaType interface. The caller must release the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_NO_MORE_TYPES: The dwIndex parameter is out of range.  </li>
</ul>
</dd></dl>
<p><a class="el" href="namespace_harlinn_1_1_windows_1_1_media.html">Media</a> types are returned in the approximate order of preference. The list of supported types is not guaranteed to be complete. To test whether a particular media type is supported, call IMFMediaTypeHandler::IsMediaTypeSupported. </p>

</div>
</div>
<a id="a988057adbc10434413560403eef82960" name="a988057adbc10434413560403eef82960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988057adbc10434413560403eef82960">&#9670;&#160;</a></span>GetMediaTypeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::GetMediaTypeCount </td>
          <td>(</td>
          <td class="paramtype">__RPC__out DWORD *</td>          <td class="paramname"><span class="paramname"><em>pdwTypeCount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of media types in the object's list of supported media types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdwTypeCount</td><td>Receives the number of media types in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If this method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. </dd></dl>
<p>To get the supported media types, call IMFMediaTypeHandler::GetMediaTypeByIndex. </p>
<p>For a media source, the media type handler for each stream must contain at least one supported media type. For media sinks, the media type handler for each stream might contain zero media types. In that case, the application must provide the media type. To test whether a particular media type is supported, call IMFMediaTypeHandler::IsMediaTypeSupported. </p>

</div>
</div>
<a id="a9ffb577ead1a35e25d94715c8b0710c4" name="a9ffb577ead1a35e25d94715c8b0710c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffb577ead1a35e25d94715c8b0710c4">&#9670;&#160;</a></span>GetMediaTypeHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::GetMediaTypeHandler </td>
          <td>(</td>
          <td class="paramtype">__RPC__deref_out_opt IMFMediaTypeHandler **</td>          <td class="paramname"><span class="paramname"><em>ppHandler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the media type handler for the stream sink. You can use the media type handler to find which formats the stream supports, and to set the media type on the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppHandler</td><td>Receives a pointer to the IMFMediaTypeHandler interface. The caller must release the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
<li>
MF_E_STREAMSINK_REMOVED: This stream was removed from the media sinkand is no longer valid.  </li>
</ul>
</dd></dl>
<p>If the stream sink currently does not support any media types, this method returns a media type handler that fails any calls to IMFMediaTypeHandler::GetCurrentMediaType and IMFMediaTypeHandler::IsMediaTypeSupported. </p>

</div>
</div>
<a id="ab3f4a971b122a4add2015d287f5e46ac" name="ab3f4a971b122a4add2015d287f5e46ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f4a971b122a4add2015d287f5e46ac">&#9670;&#160;</a></span>IsMediaTypeSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::IsMediaTypeSupported </td>
          <td>(</td>
          <td class="paramtype">IMFMediaType *</td>          <td class="paramname"><span class="paramname"><em>pMediaType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Outptr_opt_result_maybenull_ IMFMediaType **</td>          <td class="paramname"><span class="paramname"><em>ppMediaType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries whether the object supports a specified media type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaType</td><td>Pointer to the IMFMediaType interface of the media type to check. </td></tr>
    <tr><td class="paramname">ppMediaType</td><td>Receives a pointer to the IMFMediaType interface of the closest matching media type, or receives the value NULL. If non-NULL, the caller must release the interface. This parameter can be NULL. See Remarks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_INVALIDMEDIATYPE: The object does not support this media type.  </li>
</ul>
</dd></dl>
<p>If the object supports the media type given in pMediaType, the method returns S_OK. For a media source, it means the source can generate data that conforms to that media type. For a media sink, it means the sink can receive data that conforms to that media type. If the object does not support the media type, the method fails. </p>
<p>The ppMediaType parameter is optional. If the method fails, the object might use ppMediaType to return a media type that the object does support, and which closely matches the one given in pMediaType. The method is not guaranteed to return a media type in ppMediaType. If no type is returned, this parameter receives a NULL pointer. If the method succeeds, this parameter receives a NULL pointer. If the caller sets ppMediaType to NULL, this parameter is ignored. </p>

</div>
</div>
<a id="acb3c258bf98f0bc5d7df9966999279e1" name="acb3c258bf98f0bc5d7df9966999279e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3c258bf98f0bc5d7df9966999279e1">&#9670;&#160;</a></span>PlaceMarker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::PlaceMarker </td>
          <td>(</td>
          <td class="paramtype">MFSTREAMSINK_MARKER_TYPE</td>          <td class="paramname"><span class="paramname"><em>eMarkerType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__RPC__in const PROPVARIANT *</td>          <td class="paramname"><span class="paramname"><em>pvarMarkerValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__RPC__in const PROPVARIANT *</td>          <td class="paramname"><span class="paramname"><em>pvarContextValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places a marker in the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eMarkerType</td><td>Specifies the marker type, as a member of the MFSTREAMSINK_MARKER_TYPE enumeration. </td></tr>
    <tr><td class="paramname">pvarMarkerValue</td><td>Optional pointer to a PROPVARIANT that contains additional information related to the marker. The meaning of this value depends on the marker type. This parameter can be NULL. </td></tr>
    <tr><td class="paramname">pvarContextValue</td><td>Optional pointer to a PROPVARIANT that is attached to the MEStreamSinkMarker event. Call IMFMediaEvent::GetValue to get this value from the event. The caller can use this information for any purpose. This parameter can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
<li>
MF_E_STREAMSINK_REMOVED: This stream was removed from the media sinkand is no longer valid.  </li>
</ul>
</dd></dl>
<p>This method causes the stream sink to send an MEStreamSinkMarker event after the stream sink consumes all of the samples that were delivered up to this point (before the call to PlaceMarker). </p>

</div>
</div>
<a id="a2f2875ec9a04dfd02f8ae93c44b6bb9d" name="a2f2875ec9a04dfd02f8ae93c44b6bb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2875ec9a04dfd02f8ae93c44b6bb9d">&#9670;&#160;</a></span>ProcessSample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::ProcessSample </td>
          <td>(</td>
          <td class="paramtype">__RPC__in_opt IMFSample *</td>          <td class="paramname"><span class="paramname"><em>pSample</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delivers a sample to the stream. The media sink processes the sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSample</td><td>Pointer to the IMFSample interface of a sample that contains valid data for the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The method returns an HRESULT. Possible values include, but are not limited to, the following: <ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_INVALID_STATE_TRANSITION: The media sink is in the wrong state to receive a sample. For example, preroll is complete but the presentation clock has not started yet.  </li>
<li>
MF_E_INVALID_TIMESTAMP: The sample has an invalid time stamp.See Remarks.  </li>
<li>
MF_E_INVALIDREQUEST: The media sink is paused or stopped and cannot process the sample.  </li>
<li>
MF_E_NO_CLOCK: The presentation clock was not set.Call IMFMediaSink::SetPresentationClock.  </li>
<li>
MF_E_NO_SAMPLE_TIMESTAMP: The sample does not have a time stamp.  </li>
<li>
MF_E_NOT_INITIALIZED: The stream sink has not been initialized.  </li>
<li>
MF_E_SHUTDOWN: The media sink's Shutdown method has been called.  </li>
<li>
MF_E_STREAMSINK_REMOVED: This stream was removed from the media sinkand is no longer valid.  </li>
</ul>
</dd></dl>
<p>Call this method when the stream sink sends an MEStreamSinkRequestSample event. </p>
<p>This method can return MF_E_INVALID_TIMESTAMP for various reasons, depending on the implementation of the media sink: </p>
<ul>
<li>
Negative time stamps.  </li>
<li>
Time stamps that jump backward (within the same stream).  </li>
<li>
The time stamps for one stream have drifted too far from the time stamps on another stream within the same media sink (for example, an archive sink that multiplexes the streams).  </li>
</ul>
<p>Not every media sink returns an error code in these situations. </p>

</div>
</div>
<a id="ad15f66553477a5095f6357d588d381c1" name="ad15f66553477a5095f6357d588d381c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15f66553477a5095f6357d588d381c1">&#9670;&#160;</a></span>QueueEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::QueueEvent </td>
          <td>(</td>
          <td class="paramtype">MediaEventType</td>          <td class="paramname"><span class="paramname"><em>met</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__RPC__in REFGUID</td>          <td class="paramname"><span class="paramname"><em>guidExtendedType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HRESULT</td>          <td class="paramname"><span class="paramname"><em>hrStatus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__RPC__in_opt const PROPVARIANT *</td>          <td class="paramname"><span class="paramname"><em>pvValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts a new event in the object's queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">met</td><td>Specifies the event type. The event type is returned by the event's IMFMediaEvent::GetType method. For a list of event types, see <a href="https://docs.microsoft.com/en-us/windows/desktop/medfound/media-foundation-events">Media Foundation Events.   The extended type. If the event does not have an extended type, use the value GUID_NULL. The extended type is returned by the event's IMFMediaEvent::GetExtendedType method.   A success or failure code indicating the status of the event. This value is returned by the event's IMFMediaEvent::GetStatus method.   Pointer to a PROPVARIANT that contains the event value. This parameter can be NULL. This value is returned by the event's IMFMediaEvent::GetValue method.   </a></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac106ebfc88bf072c82abc0fb0a6c420c" name="ac106ebfc88bf072c82abc0fb0a6c420c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac106ebfc88bf072c82abc0fb0a6c420c">&#9670;&#160;</a></span>SetCurrentMediaType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT STDMETHODCALLTYPE Harlinn::Windows::Media::StreamingStreamSink::SetCurrentMediaType </td>
          <td>(</td>
          <td class="paramtype">IMFMediaType *</td>          <td class="paramname"><span class="paramname"><em>pMediaType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the object's media type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMediaType</td><td>Pointer to the IMFMediaType interface of the new media type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"></p>
<p class="interdd">The method returns an HRESULT. Possible values include, but are not limited to, the following: </p>
<ul>
<li>
S_OK: The method succeeded.  </li>
<li>
MF_E_INVALIDREQUEST: Invalid request.  </li>
</ul>
</dd></dl>
<p>For media sources, setting the media type means the source will generate data that conforms to that media type. For media sinks, setting the media type means the sink can receive data that conforms to that media type. </p>
<p>Any implementation of this method should check whether pMediaType differs from the object's current media type. If the types are identical, the method should return S_OK but avoid releasing and recreating resources unnecessarily. If the types are not identical, the method should validate the new type. </p>
<p>&lt;/remakrs&gt; </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a167fcf8c5c65f77f91fe0e80863e1ac5" name="a167fcf8c5c65f77f91fe0e80863e1ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167fcf8c5c65f77f91fe0e80863e1ac5">&#9670;&#160;</a></span>streamId_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DWORD Harlinn::Windows::Media::StreamingStreamSink::streamId_ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_h_w_streaming_media_sink_8h.html">HWStreamingMediaSink.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_harlinn.html">Harlinn</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_windows.html">Windows</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_windows_1_1_media.html">Media</a></li><li class="navelem"><a class="el" href="class_harlinn_1_1_windows_1_1_media_1_1_streaming_stream_sink.html">StreamingStreamSink</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>

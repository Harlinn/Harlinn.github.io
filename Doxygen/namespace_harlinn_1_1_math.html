<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Harlinn.Windows: Harlinn::Math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Harlinn.Windows<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespace_harlinn_1_1_math.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Harlinn::Math Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html">Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_harlinn_1_1_math_1_1_s_i_m_d.html">SIMD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_affine_transformation.html">AffineTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_compensated_float.html">CompensatedFloat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_compensated_sum.html">CompensatedSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_constants.html">Constants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_constants_3_01double_01_4.html">Constants&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_constants_3_01float_01_4.html">Constants&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_half.html">Half</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_line.html">Line</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An infinite line passing through <code>origin&lt;c&gt; with direction given by the unit vector <code>direction&lt;c&gt;. </code></code> <a href="struct_harlinn_1_1_math_1_1_line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_line_simd.html">LineSimd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An infinite line passing through <code>origin&lt;c&gt; with direction given by the unit vector <code>direction&lt;c&gt;. </code></code> <a href="struct_harlinn_1_1_math_1_1_line_simd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_normal.html">Normal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_normal_3_01float_00_013_01_4.html">Normal&lt; float, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_plane.html">Plane</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_plane_simd.html">PlaneSimd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_point.html">Point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_point_3_01float_00_012_01_4.html">Point&lt; float, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_point_3_01float_00_013_01_4.html">Point&lt; float, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_point_3_01_int32_00_012_01_4.html">Point&lt; Int32, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_point_3_01_int32_00_013_01_4.html">Point&lt; Int32, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_quaternion_simd.html">QuaternionSimd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_scalar.html">Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_scalar_3_01double_00_012_01_4.html">Scalar&lt; double, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_scalar_3_01double_00_013_01_4.html">Scalar&lt; double, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_scalar_3_01double_00_014_01_4.html">Scalar&lt; double, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_scalar_3_01float_00_012_01_4.html">Scalar&lt; float, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_scalar_3_01float_00_013_01_4.html">Scalar&lt; float, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_scalar_3_01float_00_014_01_4.html">Scalar&lt; float, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_segment.html">Segment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_segment_simd.html">SegmentSimd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_square_matrix_simd.html">SquareMatrixSimd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_square_matrix_simd_3_01_matrix_t_00_011_01_4.html">SquareMatrixSimd&lt; MatrixT, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_square_matrix_simd_3_01_matrix_t_00_012_01_4.html">SquareMatrixSimd&lt; MatrixT, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_square_matrix_simd_3_01_matrix_t_00_013_01_4.html">SquareMatrixSimd&lt; MatrixT, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_harlinn_1_1_math_1_1_square_matrix_simd_3_01_matrix_t_00_014_01_4.html">SquareMatrixSimd&lt; MatrixT, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_tuple2.html">Tuple2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple holding two numbers.  <a href="class_harlinn_1_1_math_1_1_tuple2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_tuple4.html">Tuple4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_tuple_simd.html">TupleSimd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01double_00_012_01_4.html">Vector&lt; double, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01double_00_013_01_4.html">Vector&lt; double, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01double_00_014_01_4.html">Vector&lt; double, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01float_00_012_01_4.html">Vector&lt; float, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01float_00_013_01_4.html">Vector&lt; float, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01float_00_014_01_4.html">Vector&lt; float, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01_int32_00_012_01_4.html">Vector&lt; Int32, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01_int32_00_013_01_4.html">Vector&lt; Int32, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01_int32_00_014_01_4.html">Vector&lt; Int32, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01_u_int32_00_012_01_4.html">Vector&lt; UInt32, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01_u_int32_00_013_01_4.html">Vector&lt; UInt32, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_harlinn_1_1_math_1_1_vector_3_01_u_int32_00_014_01_4.html">Vector&lt; UInt32, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_vector_type.html">VectorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_vector_simd_type.html">VectorSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_vector_or_vector_simd_type.html">VectorOrVectorSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_scalar_type.html">ScalarType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_scalar_simd_type.html">ScalarSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_scalar_or_scalar_simd_type.html">ScalarOrScalarSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_simd_type.html">SimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_tuple_type.html">TupleType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_simd_or_tuple_type.html">SimdOrTupleType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_simd_tuple_or_arithmetic_type.html">SimdTupleOrArithmeticType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_point_type.html">PointType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_point_simd_type.html">PointSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_point_or_point_simd_type.html">PointOrPointSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_normal_type.html">NormalType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_normal_simd_type.html">NormalSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_normal_or_normal_simd_type.html">NormalOrNormalSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_quaternion_simd_type.html">QuaternionSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_quaternion_type.html">QuaternionType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_quaternion_or_quaternion_simd_type.html">QuaternionOrQuaternionSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_square_matrix_simd_type.html">SquareMatrixSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_square_matrix_type.html">SquareMatrixType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_square_matrix_or_square_matrix_simd_type.html">SquareMatrixOrSquareMatrixSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_plane_simd_type.html">PlaneSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_plane_type.html">PlaneType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_harlinn_1_1_math_1_1_plane_or_plane_simd_type.html">PlaneOrPlaneSimdType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a906fd8ff6cbc5920af294d742c031071" id="r_a906fd8ff6cbc5920af294d742c031071"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a906fd8ff6cbc5920af294d742c031071"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a906fd8ff6cbc5920af294d742c031071">Line2</a> = <a class="el" href="struct_harlinn_1_1_math_1_1_line.html">Line</a>&lt;T, 2&gt;</td></tr>
<tr class="separator:a906fd8ff6cbc5920af294d742c031071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b5d72ac584ecb9fc511618355214dd" id="r_a64b5d72ac584ecb9fc511618355214dd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64b5d72ac584ecb9fc511618355214dd">Line2f</a> = <a class="el" href="#a906fd8ff6cbc5920af294d742c031071">Line2</a>&lt;float&gt;</td></tr>
<tr class="separator:a64b5d72ac584ecb9fc511618355214dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5a636c49265909a8893c4f7016d75b" id="r_a5b5a636c49265909a8893c4f7016d75b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b5a636c49265909a8893c4f7016d75b">Line2d</a> = <a class="el" href="#a906fd8ff6cbc5920af294d742c031071">Line2</a>&lt;double&gt;</td></tr>
<tr class="separator:a5b5a636c49265909a8893c4f7016d75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a306d4b18029ab8d02ced8135e7aa7a" id="r_a9a306d4b18029ab8d02ced8135e7aa7a"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a9a306d4b18029ab8d02ced8135e7aa7a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a306d4b18029ab8d02ced8135e7aa7a">Line3</a> = <a class="el" href="struct_harlinn_1_1_math_1_1_line.html">Line</a>&lt;T, 3&gt;</td></tr>
<tr class="separator:a9a306d4b18029ab8d02ced8135e7aa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7104d8ce3d358f968d96ffe84242d864" id="r_a7104d8ce3d358f968d96ffe84242d864"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7104d8ce3d358f968d96ffe84242d864">Line3f</a> = <a class="el" href="#a9a306d4b18029ab8d02ced8135e7aa7a">Line3</a>&lt;float&gt;</td></tr>
<tr class="separator:a7104d8ce3d358f968d96ffe84242d864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106fd971fe491b702c9e6a57f1ef8af6" id="r_a106fd971fe491b702c9e6a57f1ef8af6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a106fd971fe491b702c9e6a57f1ef8af6">Line3d</a> = <a class="el" href="#a9a306d4b18029ab8d02ced8135e7aa7a">Line3</a>&lt;double&gt;</td></tr>
<tr class="separator:a106fd971fe491b702c9e6a57f1ef8af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a0c4e3a80e5024216032a7c46231c9" id="r_ab1a0c4e3a80e5024216032a7c46231c9"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ab1a0c4e3a80e5024216032a7c46231c9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1a0c4e3a80e5024216032a7c46231c9">Segment2</a> = <a class="el" href="struct_harlinn_1_1_math_1_1_segment.html">Segment</a>&lt;T, 2&gt;</td></tr>
<tr class="separator:ab1a0c4e3a80e5024216032a7c46231c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c3a96481febfc8ea4aa0e69d45f341" id="r_a19c3a96481febfc8ea4aa0e69d45f341"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19c3a96481febfc8ea4aa0e69d45f341">Segment2f</a> = <a class="el" href="#ab1a0c4e3a80e5024216032a7c46231c9">Segment2</a>&lt;float&gt;</td></tr>
<tr class="separator:a19c3a96481febfc8ea4aa0e69d45f341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b7513b64d4f88490581352422f22d5" id="r_ac8b7513b64d4f88490581352422f22d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8b7513b64d4f88490581352422f22d5">Segment2d</a> = <a class="el" href="#ab1a0c4e3a80e5024216032a7c46231c9">Segment2</a>&lt;double&gt;</td></tr>
<tr class="separator:ac8b7513b64d4f88490581352422f22d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0925b6dc26d6be4b4fd33e5a69bba3" id="r_a0e0925b6dc26d6be4b4fd33e5a69bba3"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a0e0925b6dc26d6be4b4fd33e5a69bba3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e0925b6dc26d6be4b4fd33e5a69bba3">Segment3</a> = <a class="el" href="struct_harlinn_1_1_math_1_1_segment.html">Segment</a>&lt;T, 3&gt;</td></tr>
<tr class="separator:a0e0925b6dc26d6be4b4fd33e5a69bba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c669d52535837f83ac6f1f780858890" id="r_a3c669d52535837f83ac6f1f780858890"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c669d52535837f83ac6f1f780858890">Segment3f</a> = <a class="el" href="#a0e0925b6dc26d6be4b4fd33e5a69bba3">Segment3</a>&lt;float&gt;</td></tr>
<tr class="separator:a3c669d52535837f83ac6f1f780858890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b32810cc322dd1e5efaf1cc9684817" id="r_a45b32810cc322dd1e5efaf1cc9684817"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45b32810cc322dd1e5efaf1cc9684817">Segment3d</a> = <a class="el" href="#a0e0925b6dc26d6be4b4fd33e5a69bba3">Segment3</a>&lt;double&gt;</td></tr>
<tr class="separator:a45b32810cc322dd1e5efaf1cc9684817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ce90da94510f0e2ede5d7968a05bbe" id="r_a82ce90da94510f0e2ede5d7968a05bbe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82ce90da94510f0e2ede5d7968a05bbe">Vector2f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;float, 2&gt;</td></tr>
<tr class="separator:a82ce90da94510f0e2ede5d7968a05bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56153f60040dd948ae3ca936cb6d9c9" id="r_ae56153f60040dd948ae3ca936cb6d9c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae56153f60040dd948ae3ca936cb6d9c9">Vector2d</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;double, 2&gt;</td></tr>
<tr class="separator:ae56153f60040dd948ae3ca936cb6d9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4fcb05bbc5bf7a6ba71960d5436cf9" id="r_a7f4fcb05bbc5bf7a6ba71960d5436cf9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f4fcb05bbc5bf7a6ba71960d5436cf9">Vector2i</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;int, 2&gt;</td></tr>
<tr class="separator:a7f4fcb05bbc5bf7a6ba71960d5436cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f636c112afae492b0c6354badc3cf73" id="r_a2f636c112afae492b0c6354badc3cf73"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f636c112afae492b0c6354badc3cf73">Vector3f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;float, 3&gt;</td></tr>
<tr class="separator:a2f636c112afae492b0c6354badc3cf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3759c6917a7be994d53e0e90622a7c1d" id="r_a3759c6917a7be994d53e0e90622a7c1d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3759c6917a7be994d53e0e90622a7c1d">Vector3d</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;double, 3&gt;</td></tr>
<tr class="separator:a3759c6917a7be994d53e0e90622a7c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea76ac78b5bc5432ac4598540c03873e" id="r_aea76ac78b5bc5432ac4598540c03873e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea76ac78b5bc5432ac4598540c03873e">Vector3i</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;int, 3&gt;</td></tr>
<tr class="separator:aea76ac78b5bc5432ac4598540c03873e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05e5ab93d92035d4287e44a528b30ef" id="r_ab05e5ab93d92035d4287e44a528b30ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab05e5ab93d92035d4287e44a528b30ef">Vector4f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;float, 4&gt;</td></tr>
<tr class="separator:ab05e5ab93d92035d4287e44a528b30ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37ef7a1d9b6a1eeb76916b6fbffd0b5" id="r_ae37ef7a1d9b6a1eeb76916b6fbffd0b5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae37ef7a1d9b6a1eeb76916b6fbffd0b5">Vector4d</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;double, 4&gt;</td></tr>
<tr class="separator:ae37ef7a1d9b6a1eeb76916b6fbffd0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef59117700c1f463a437b502d5173b1e" id="r_aef59117700c1f463a437b502d5173b1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef59117700c1f463a437b502d5173b1e">Vector4i</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;int, 4&gt;</td></tr>
<tr class="separator:aef59117700c1f463a437b502d5173b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1450880d4a39dfc0d03aefb442c1dc9" id="r_ab1450880d4a39dfc0d03aefb442c1dc9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1450880d4a39dfc0d03aefb442c1dc9">Point2i</a> = <a class="el" href="class_harlinn_1_1_math_1_1_point.html">Point</a>&lt;<a class="el" href="namespace_harlinn_1_1_common.html#a77b0045551d73ca9f4fb32769fa84426">Int32</a>, 2&gt;</td></tr>
<tr class="separator:ab1450880d4a39dfc0d03aefb442c1dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e93e5118ab44e76e75ff4538ed5515" id="r_a68e93e5118ab44e76e75ff4538ed5515"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e93e5118ab44e76e75ff4538ed5515">Point3i</a> = <a class="el" href="class_harlinn_1_1_math_1_1_point.html">Point</a>&lt;<a class="el" href="namespace_harlinn_1_1_common.html#a77b0045551d73ca9f4fb32769fa84426">Int32</a>, 3&gt;</td></tr>
<tr class="separator:a68e93e5118ab44e76e75ff4538ed5515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639cabf2f826e7b0876ba10529ea9d06" id="r_a639cabf2f826e7b0876ba10529ea9d06"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a639cabf2f826e7b0876ba10529ea9d06">Point2f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_point.html">Point</a>&lt;float, 2&gt;</td></tr>
<tr class="separator:a639cabf2f826e7b0876ba10529ea9d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e227c35130c9e7e322ead53eeff7b6e" id="r_a3e227c35130c9e7e322ead53eeff7b6e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e227c35130c9e7e322ead53eeff7b6e">Point3f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_point.html">Point</a>&lt;float, 3&gt;</td></tr>
<tr class="separator:a3e227c35130c9e7e322ead53eeff7b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e3e7d66212411e17fb90bdadba1354" id="r_a43e3e7d66212411e17fb90bdadba1354"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43e3e7d66212411e17fb90bdadba1354">Normal3f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_normal.html">Normal</a>&lt;float, 3&gt;</td></tr>
<tr class="separator:a43e3e7d66212411e17fb90bdadba1354"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6851f9f03a800224c7551b42347ef2f8" id="r_a6851f9f03a800224c7551b42347ef2f8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6851f9f03a800224c7551b42347ef2f8">MatrixType</a> : UInt32 { <br />
&#160;&#160;<a class="el" href="#a6851f9f03a800224c7551b42347ef2f8ad7ed4ee1df437474d005188535f74875">Zero</a>
, <br />
&#160;&#160;<a class="el" href="#a6851f9f03a800224c7551b42347ef2f8ac9c5c65fb4af9cf90eb99b3b84424189">Identity</a>
<br />
 }</td></tr>
<tr class="separator:a6851f9f03a800224c7551b42347ef2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a237a95b355d0276165d0a5a4d858296a" id="r_a237a95b355d0276165d0a5a4d858296a"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a237a95b355d0276165d0a5a4d858296a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a237a95b355d0276165d0a5a4d858296a">IsSameValue</a> (T first, T second) noexcept</td></tr>
<tr class="memdesc:a237a95b355d0276165d0a5a4d858296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether two floating point values holds the same value. This function returns true if both hold the same NaN value.  <br /></td></tr>
<tr class="separator:a237a95b355d0276165d0a5a4d858296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0502341914c9f34101f1a20e366e3799" id="r_a0502341914c9f34101f1a20e366e3799"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a0502341914c9f34101f1a20e366e3799"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0502341914c9f34101f1a20e366e3799">IsZero</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a0502341914c9f34101f1a20e366e3799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a floating point value is zero.  <br /></td></tr>
<tr class="separator:a0502341914c9f34101f1a20e366e3799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fca65484972bed23f0608446920cd2" id="r_af7fca65484972bed23f0608446920cd2"><td class="memTemplParams" colspan="2">template&lt;UnsignedIntegerOrBooleanType T&gt; </td></tr>
<tr class="memitem:af7fca65484972bed23f0608446920cd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af7fca65484972bed23f0608446920cd2">signum</a> (T val) noexcept</td></tr>
<tr class="memdesc:af7fca65484972bed23f0608446920cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sign of a value for a signed integer type.  <br /></td></tr>
<tr class="separator:af7fca65484972bed23f0608446920cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287eb5f21fefd281a70f0477f9913256" id="r_a287eb5f21fefd281a70f0477f9913256"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a287eb5f21fefd281a70f0477f9913256"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a287eb5f21fefd281a70f0477f9913256">Deg2Rad</a> (T angleInDegrees) noexcept</td></tr>
<tr class="memdesc:a287eb5f21fefd281a70f0477f9913256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle in degrees into the corresponding angle in radians.  <br /></td></tr>
<tr class="separator:a287eb5f21fefd281a70f0477f9913256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbd57c7f8e57182db9e1032ea95b378" id="r_a9fbd57c7f8e57182db9e1032ea95b378"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a9fbd57c7f8e57182db9e1032ea95b378"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9fbd57c7f8e57182db9e1032ea95b378">Rad2Deg</a> (T angleInRadians) noexcept</td></tr>
<tr class="memdesc:a9fbd57c7f8e57182db9e1032ea95b378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an angle in radians into the corresponding angle in degrees.  <br /></td></tr>
<tr class="separator:a9fbd57c7f8e57182db9e1032ea95b378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8d31268db3285ea02c6ae7bd376410" id="r_a1b8d31268db3285ea02c6ae7bd376410"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b8d31268db3285ea02c6ae7bd376410">NextAfter</a> (double <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, double <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="separator:a1b8d31268db3285ea02c6ae7bd376410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6ce9b75eaa5934febe7f16e55a117e" id="r_a4c6ce9b75eaa5934febe7f16e55a117e"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c6ce9b75eaa5934febe7f16e55a117e">NextAfter</a> (float <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, float <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="separator:a4c6ce9b75eaa5934febe7f16e55a117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3f8fdcb1da1e0e79143bd71f1e128d" id="r_a0e3f8fdcb1da1e0e79143bd71f1e128d"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a0e3f8fdcb1da1e0e79143bd71f1e128d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e3f8fdcb1da1e0e79143bd71f1e128d">Sqrt</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a0e3f8fdcb1da1e0e79143bd71f1e128d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828c285223f0bbac53ee3c0e44ccbcc3" id="r_a828c285223f0bbac53ee3c0e44ccbcc3"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a828c285223f0bbac53ee3c0e44ccbcc3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a828c285223f0bbac53ee3c0e44ccbcc3">ReciprocalSqrt</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a828c285223f0bbac53ee3c0e44ccbcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90927c2206380b934e2d0e412275031c" id="r_a90927c2206380b934e2d0e412275031c"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a90927c2206380b934e2d0e412275031c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90927c2206380b934e2d0e412275031c">Cbrt</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a90927c2206380b934e2d0e412275031c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ac49db5a05c270cde3e4d6ec52ef7d" id="r_a01ac49db5a05c270cde3e4d6ec52ef7d"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a01ac49db5a05c270cde3e4d6ec52ef7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a01ac49db5a05c270cde3e4d6ec52ef7d">NextDown</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a01ac49db5a05c270cde3e4d6ec52ef7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d55f4aa51cc5dd0b27597015b85732" id="r_ac9d55f4aa51cc5dd0b27597015b85732"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ac9d55f4aa51cc5dd0b27597015b85732"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac9d55f4aa51cc5dd0b27597015b85732">NextUp</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:ac9d55f4aa51cc5dd0b27597015b85732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aca46f17a1f86c6d38dee21a3849f5c" id="r_a9aca46f17a1f86c6d38dee21a3849f5c"><td class="memTemplParams" colspan="2">template&lt;IntegerType T&gt; </td></tr>
<tr class="memitem:a9aca46f17a1f86c6d38dee21a3849f5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9aca46f17a1f86c6d38dee21a3849f5c">IsNaN</a> (T val) noexcept</td></tr>
<tr class="memdesc:a9aca46f17a1f86c6d38dee21a3849f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsNaN for integer types, always returns false.  <br /></td></tr>
<tr class="separator:a9aca46f17a1f86c6d38dee21a3849f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2891fba8823c2abd1d3c9d91cc596655" id="r_a2891fba8823c2abd1d3c9d91cc596655"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, ArithmeticType ... Args&gt; </td></tr>
<tr class="memitem:a2891fba8823c2abd1d3c9d91cc596655"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2891fba8823c2abd1d3c9d91cc596655">IsNaN</a> (T val, Args ... args) noexcept</td></tr>
<tr class="memdesc:a2891fba8823c2abd1d3c9d91cc596655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if any of the given integral or floating point values are a not-a-number (NaN) value.  <br /></td></tr>
<tr class="separator:a2891fba8823c2abd1d3c9d91cc596655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae14fc0c5bab83be58a8081a3658ebe" id="r_aeae14fc0c5bab83be58a8081a3658ebe"><td class="memTemplParams" colspan="2">template&lt;IntegerType T&gt; </td></tr>
<tr class="memitem:aeae14fc0c5bab83be58a8081a3658ebe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeae14fc0c5bab83be58a8081a3658ebe">IsInf</a> (T val) noexcept</td></tr>
<tr class="memdesc:aeae14fc0c5bab83be58a8081a3658ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integers cannot represent infinite, so this function always returns false.  <br /></td></tr>
<tr class="separator:aeae14fc0c5bab83be58a8081a3658ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95eee7648b97c1a35561fbd02a943b4b" id="r_a95eee7648b97c1a35561fbd02a943b4b"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, ArithmeticType ... Args&gt; </td></tr>
<tr class="memitem:a95eee7648b97c1a35561fbd02a943b4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a95eee7648b97c1a35561fbd02a943b4b">IsInf</a> (T val, Args ... args) noexcept</td></tr>
<tr class="memdesc:a95eee7648b97c1a35561fbd02a943b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if any of the given integral or floating point numbers is positive or negative infinity.  <br /></td></tr>
<tr class="separator:a95eee7648b97c1a35561fbd02a943b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58ad15cfd89f14fe84fdf1d8cf5902d" id="r_ad58ad15cfd89f14fe84fdf1d8cf5902d"><td class="memTemplParams" colspan="2">template&lt;IntegerType T&gt; </td></tr>
<tr class="memitem:ad58ad15cfd89f14fe84fdf1d8cf5902d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad58ad15cfd89f14fe84fdf1d8cf5902d">IsFinite</a> (T val) noexcept</td></tr>
<tr class="memdesc:ad58ad15cfd89f14fe84fdf1d8cf5902d"><td class="mdescLeft">&#160;</td><td class="mdescRight">All integers have finite values.  <br /></td></tr>
<tr class="separator:ad58ad15cfd89f14fe84fdf1d8cf5902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7192253e7c89dcb7f00e94e68636d12b" id="r_a7192253e7c89dcb7f00e94e68636d12b"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, ArithmeticType ... Args&gt; </td></tr>
<tr class="memitem:a7192253e7c89dcb7f00e94e68636d12b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7192253e7c89dcb7f00e94e68636d12b">IsFinite</a> (T val, Args ... args) noexcept</td></tr>
<tr class="memdesc:a7192253e7c89dcb7f00e94e68636d12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if all the arguments are finite.  <br /></td></tr>
<tr class="separator:a7192253e7c89dcb7f00e94e68636d12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13993e9f81df05382d918ab9d6864cfd" id="r_a13993e9f81df05382d918ab9d6864cfd"><td class="memTemplParams" colspan="2">template&lt;IntegerType T&gt; </td></tr>
<tr class="memitem:a13993e9f81df05382d918ab9d6864cfd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13993e9f81df05382d918ab9d6864cfd">IsNormal</a> (T val) noexcept</td></tr>
<tr class="memdesc:a13993e9f81df05382d918ab9d6864cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">All integers, except 0, are &lt;q&gt;normal&lt;/q&gt;.  <br /></td></tr>
<tr class="separator:a13993e9f81df05382d918ab9d6864cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0826cff83589dd4b86faf50fd889b6c5" id="r_a0826cff83589dd4b86faf50fd889b6c5"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, ArithmeticType ... Args&gt; </td></tr>
<tr class="memitem:a0826cff83589dd4b86faf50fd889b6c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0826cff83589dd4b86faf50fd889b6c5">IsNormal</a> (T val, Args ... args) noexcept</td></tr>
<tr class="memdesc:a0826cff83589dd4b86faf50fd889b6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if all the arguments are normal.  <br /></td></tr>
<tr class="separator:a0826cff83589dd4b86faf50fd889b6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a4bfa28ef8b8b47b2e42a18925a8ce" id="r_ab4a4bfa28ef8b8b47b2e42a18925a8ce"><td class="memTemplParams" colspan="2">template&lt;SignedIntegerType T&gt; </td></tr>
<tr class="memitem:ab4a4bfa28ef8b8b47b2e42a18925a8ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4a4bfa28ef8b8b47b2e42a18925a8ce">Abs</a> (T val) noexcept</td></tr>
<tr class="memdesc:ab4a4bfa28ef8b8b47b2e42a18925a8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The absolute value of any unsigned integer is the same as its value.  <br /></td></tr>
<tr class="separator:ab4a4bfa28ef8b8b47b2e42a18925a8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e3e2ceb3d61d3caba576478f914b18" id="r_af0e3e2ceb3d61d3caba576478f914b18"><td class="memTemplParams" colspan="2">template&lt;UnsignedIntegerType T&gt; </td></tr>
<tr class="memitem:af0e3e2ceb3d61d3caba576478f914b18"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0e3e2ceb3d61d3caba576478f914b18">FastAbs</a> (T val) noexcept</td></tr>
<tr class="separator:af0e3e2ceb3d61d3caba576478f914b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7363afb76b6078844e9e73225f9e73" id="r_a8a7363afb76b6078844e9e73225f9e73"><td class="memTemplParams" colspan="2">template&lt;SignedIntegerType T&gt; </td></tr>
<tr class="memitem:a8a7363afb76b6078844e9e73225f9e73"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a7363afb76b6078844e9e73225f9e73">SignBit</a> (T val) noexcept</td></tr>
<tr class="memdesc:a8a7363afb76b6078844e9e73225f9e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given signed integer value is negative.  <br /></td></tr>
<tr class="separator:a8a7363afb76b6078844e9e73225f9e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1b449cb003cb62aa480994c172b55b" id="r_a5e1b449cb003cb62aa480994c172b55b"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a5e1b449cb003cb62aa480994c172b55b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; T, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e1b449cb003cb62aa480994c172b55b">FRExp</a> (T val) noexcept</td></tr>
<tr class="separator:a5e1b449cb003cb62aa480994c172b55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c98610c8fa54047fca2f3c9175bda0" id="r_a10c98610c8fa54047fca2f3c9175bda0"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a10c98610c8fa54047fca2f3c9175bda0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10c98610c8fa54047fca2f3c9175bda0">FRExp</a> (T val, int *exp) noexcept</td></tr>
<tr class="separator:a10c98610c8fa54047fca2f3c9175bda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c01122e0f442201ff460957b24c1db" id="r_a19c01122e0f442201ff460957b24c1db"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a19c01122e0f442201ff460957b24c1db"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19c01122e0f442201ff460957b24c1db">FRExp</a> (T val, int &amp;exp) noexcept</td></tr>
<tr class="separator:a19c01122e0f442201ff460957b24c1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab396b56264fa6d74e80f149358c321c6" id="r_ab396b56264fa6d74e80f149358c321c6"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ab396b56264fa6d74e80f149358c321c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::pair&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab396b56264fa6d74e80f149358c321c6">ModF</a> (T val) noexcept</td></tr>
<tr class="separator:ab396b56264fa6d74e80f149358c321c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ac718ba3e3255c9123ec96d6ad4b30" id="r_a61ac718ba3e3255c9123ec96d6ad4b30"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a61ac718ba3e3255c9123ec96d6ad4b30"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a61ac718ba3e3255c9123ec96d6ad4b30">ModF</a> (T val, T *integerPart) noexcept</td></tr>
<tr class="separator:a61ac718ba3e3255c9123ec96d6ad4b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ce2b213fa59b2fc14b7d7a6142d421" id="r_ac7ce2b213fa59b2fc14b7d7a6142d421"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ac7ce2b213fa59b2fc14b7d7a6142d421"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac7ce2b213fa59b2fc14b7d7a6142d421">ModF</a> (T val, T &amp;integerPart) noexcept</td></tr>
<tr class="separator:ac7ce2b213fa59b2fc14b7d7a6142d421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83de7c527b5116ccb856eaaf3d6aeeb" id="r_ae83de7c527b5116ccb856eaaf3d6aeeb"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ae83de7c527b5116ccb856eaaf3d6aeeb"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae83de7c527b5116ccb856eaaf3d6aeeb">Min</a> (T first, T second) noexcept</td></tr>
<tr class="memdesc:ae83de7c527b5116ccb856eaaf3d6aeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of the given values.  <br /></td></tr>
<tr class="separator:ae83de7c527b5116ccb856eaaf3d6aeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf5f42de91c1412b43ab27f9ed71e35" id="r_a9bf5f42de91c1412b43ab27f9ed71e35"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T, FloatingPointType ... Args&gt; </td></tr>
<tr class="memitem:a9bf5f42de91c1412b43ab27f9ed71e35"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9bf5f42de91c1412b43ab27f9ed71e35">Min</a> (T first, T second, Args... remaining) noexcept</td></tr>
<tr class="separator:a9bf5f42de91c1412b43ab27f9ed71e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf04d08d7e21956153df4683e43e1ec6" id="r_abf04d08d7e21956153df4683e43e1ec6"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:abf04d08d7e21956153df4683e43e1ec6"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf04d08d7e21956153df4683e43e1ec6">Max</a> (T first, T second) noexcept</td></tr>
<tr class="memdesc:abf04d08d7e21956153df4683e43e1ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of the given values.  <br /></td></tr>
<tr class="separator:abf04d08d7e21956153df4683e43e1ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bedec25a886855135109e10405e969f" id="r_a1bedec25a886855135109e10405e969f"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T, FloatingPointType ... Args&gt; </td></tr>
<tr class="memitem:a1bedec25a886855135109e10405e969f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1bedec25a886855135109e10405e969f">Max</a> (T first, T second, Args... remaining) noexcept</td></tr>
<tr class="separator:a1bedec25a886855135109e10405e969f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ba5d43d7b7958445997a610993dfbf" id="r_ae7ba5d43d7b7958445997a610993dfbf"><td class="memTemplParams" colspan="2">template&lt;SimpleSpanLike T&gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad60f420a7f44c2b0e9ce86950287dbad">IsArithmetic</a>&lt;typename T::value_type&gt;</td></tr>
<tr class="memitem:ae7ba5d43d7b7958445997a610993dfbf"><td class="memTemplItemLeft" align="right" valign="top">constexpr T::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7ba5d43d7b7958445997a610993dfbf">Multiply</a> (const T &amp;values)</td></tr>
<tr class="separator:ae7ba5d43d7b7958445997a610993dfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b30f7526b7049bb02d78f55f91cdfc6" id="r_a0b30f7526b7049bb02d78f55f91cdfc6"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a0b30f7526b7049bb02d78f55f91cdfc6"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0b30f7526b7049bb02d78f55f91cdfc6">Trunc</a> (T value) noexcept</td></tr>
<tr class="memdesc:a0b30f7526b7049bb02d78f55f91cdfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just returns value.  <br /></td></tr>
<tr class="separator:a0b30f7526b7049bb02d78f55f91cdfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca557701706f3bde4dbbc1a9fa9e582" id="r_a4ca557701706f3bde4dbbc1a9fa9e582"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a4ca557701706f3bde4dbbc1a9fa9e582"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ca557701706f3bde4dbbc1a9fa9e582">Floor</a> (T value) noexcept</td></tr>
<tr class="memdesc:a4ca557701706f3bde4dbbc1a9fa9e582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just returns value.  <br /></td></tr>
<tr class="separator:a4ca557701706f3bde4dbbc1a9fa9e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b801a8dc102a4a4e380837e432551d6" id="r_a5b801a8dc102a4a4e380837e432551d6"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a5b801a8dc102a4a4e380837e432551d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5b801a8dc102a4a4e380837e432551d6">Ceil</a> (T value) noexcept</td></tr>
<tr class="memdesc:a5b801a8dc102a4a4e380837e432551d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just returns value.  <br /></td></tr>
<tr class="separator:a5b801a8dc102a4a4e380837e432551d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b03b2cb6214d5450c019fbc6296e7b" id="r_a20b03b2cb6214d5450c019fbc6296e7b"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a20b03b2cb6214d5450c019fbc6296e7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a20b03b2cb6214d5450c019fbc6296e7b">Round</a> (T value) noexcept</td></tr>
<tr class="memdesc:a20b03b2cb6214d5450c019fbc6296e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just returns value.  <br /></td></tr>
<tr class="separator:a20b03b2cb6214d5450c019fbc6296e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4d0862351f0a2917902fc35e4da876" id="r_a2b4d0862351f0a2917902fc35e4da876"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T1, ArithmeticType T2, ArithmeticType T3&gt; </td></tr>
<tr class="memitem:a2b4d0862351f0a2917902fc35e4da876"><td class="memTemplItemLeft" align="right" valign="top">constexpr T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b4d0862351f0a2917902fc35e4da876">Clamp</a> (T1 value, T2 minimumValue, T3 maximumValue) noexcept</td></tr>
<tr class="separator:a2b4d0862351f0a2917902fc35e4da876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c0aa22d6e25b08bae0a587fd16aa0f" id="r_a15c0aa22d6e25b08bae0a587fd16aa0f"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a15c0aa22d6e25b08bae0a587fd16aa0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15c0aa22d6e25b08bae0a587fd16aa0f">Lerp</a> (T a, T b, U t) noexcept</td></tr>
<tr class="separator:a15c0aa22d6e25b08bae0a587fd16aa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e5e7d3d8874ca6e89a9049fdbe3e86" id="r_a38e5e7d3d8874ca6e89a9049fdbe3e86"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a38e5e7d3d8874ca6e89a9049fdbe3e86"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38e5e7d3d8874ca6e89a9049fdbe3e86">Lerp2</a> (U t, T a, T b) noexcept</td></tr>
<tr class="separator:a38e5e7d3d8874ca6e89a9049fdbe3e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944e35714a357dc8f3e38474c106b36a" id="r_a944e35714a357dc8f3e38474c106b36a"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a944e35714a357dc8f3e38474c106b36a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a944e35714a357dc8f3e38474c106b36a">CopySign</a> (T magnitude, T signValue) noexcept</td></tr>
<tr class="separator:a944e35714a357dc8f3e38474c106b36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add198978b31fa2f9b124057521d6bb07" id="r_add198978b31fa2f9b124057521d6bb07"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add198978b31fa2f9b124057521d6bb07">ScaleBN</a> (double <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, int n) noexcept</td></tr>
<tr class="separator:add198978b31fa2f9b124057521d6bb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1117ad0a3fb50451d847edb702f0096e" id="r_a1117ad0a3fb50451d847edb702f0096e"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1117ad0a3fb50451d847edb702f0096e">ScaleBN</a> (float <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, int n) noexcept</td></tr>
<tr class="separator:a1117ad0a3fb50451d847edb702f0096e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af900bfc00f653db100dc034d29ff1210" id="r_af900bfc00f653db100dc034d29ff1210"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:af900bfc00f653db100dc034d29ff1210"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af900bfc00f653db100dc034d29ff1210">FMod</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="separator:af900bfc00f653db100dc034d29ff1210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6428494411c1e568a42260a6fff1a039" id="r_a6428494411c1e568a42260a6fff1a039"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a6428494411c1e568a42260a6fff1a039"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6428494411c1e568a42260a6fff1a039">Exp</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a6428494411c1e568a42260a6fff1a039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110386df7e88bc94c563e0a14aee5874" id="r_a110386df7e88bc94c563e0a14aee5874"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a110386df7e88bc94c563e0a14aee5874"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a110386df7e88bc94c563e0a14aee5874">ExpM1</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a110386df7e88bc94c563e0a14aee5874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166010e3997ade67ad719863effd4ee2" id="r_a166010e3997ade67ad719863effd4ee2"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a166010e3997ade67ad719863effd4ee2"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a166010e3997ade67ad719863effd4ee2">Exp2</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a166010e3997ade67ad719863effd4ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb84f068c23042c9c463b712f33dede" id="r_acbb84f068c23042c9c463b712f33dede"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:acbb84f068c23042c9c463b712f33dede"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acbb84f068c23042c9c463b712f33dede">Exp10</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:acbb84f068c23042c9c463b712f33dede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57af8022b91c4680a4ea068730f4e762" id="r_a57af8022b91c4680a4ea068730f4e762"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a57af8022b91c4680a4ea068730f4e762"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57af8022b91c4680a4ea068730f4e762">Hypot</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="separator:a57af8022b91c4680a4ea068730f4e762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c87903d0bada5562ba3704f627975a" id="r_a16c87903d0bada5562ba3704f627975a"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a16c87903d0bada5562ba3704f627975a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16c87903d0bada5562ba3704f627975a">Hypot</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#aa625dca7607f4d8bc7078a1ca7bc7841">z</a>) noexcept</td></tr>
<tr class="separator:a16c87903d0bada5562ba3704f627975a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383035a626dc08e038f62ba81a0733c9" id="r_a383035a626dc08e038f62ba81a0733c9"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a383035a626dc08e038f62ba81a0733c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a383035a626dc08e038f62ba81a0733c9">Log</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a383035a626dc08e038f62ba81a0733c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0becfa6a2399a8362895e28cde842cde" id="r_a0becfa6a2399a8362895e28cde842cde"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a0becfa6a2399a8362895e28cde842cde"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0becfa6a2399a8362895e28cde842cde">Log1P</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a0becfa6a2399a8362895e28cde842cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bfcf2df6a90c553b8382702d8f18e1" id="r_af9bfcf2df6a90c553b8382702d8f18e1"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:af9bfcf2df6a90c553b8382702d8f18e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9bfcf2df6a90c553b8382702d8f18e1">Log2</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:af9bfcf2df6a90c553b8382702d8f18e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae347a158854527883628eeee6216f5" id="r_acae347a158854527883628eeee6216f5"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:acae347a158854527883628eeee6216f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acae347a158854527883628eeee6216f5">Log10</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:acae347a158854527883628eeee6216f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b8da5fdeb7cdce22ff47e860552b72" id="r_aa3b8da5fdeb7cdce22ff47e860552b72"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:aa3b8da5fdeb7cdce22ff47e860552b72"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa3b8da5fdeb7cdce22ff47e860552b72">LogB</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:aa3b8da5fdeb7cdce22ff47e860552b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the value of the unbiased radix-independent exponent from the floating-point argument x, and returns it as a floating-point value.  <br /></td></tr>
<tr class="separator:aa3b8da5fdeb7cdce22ff47e860552b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f07c541f9b9d48a0c82e88b61bcebc7" id="r_a7f07c541f9b9d48a0c82e88b61bcebc7"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a7f07c541f9b9d48a0c82e88b61bcebc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7f07c541f9b9d48a0c82e88b61bcebc7">ILogB</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a7f07c541f9b9d48a0c82e88b61bcebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the value of the unbiased exponent from the floating-point argument x, and returns it as a signed integer value.  <br /></td></tr>
<tr class="separator:a7f07c541f9b9d48a0c82e88b61bcebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43fa5edb4f1f8360183f1047240d338" id="r_ae43fa5edb4f1f8360183f1047240d338"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ae43fa5edb4f1f8360183f1047240d338"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae43fa5edb4f1f8360183f1047240d338">Pow</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:ae43fa5edb4f1f8360183f1047240d338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of x raised to the power y.  <br /></td></tr>
<tr class="separator:ae43fa5edb4f1f8360183f1047240d338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cda4c9af933ba7b46204284ce8351e7" id="r_a2cda4c9af933ba7b46204284ce8351e7"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a2cda4c9af933ba7b46204284ce8351e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2cda4c9af933ba7b46204284ce8351e7">Sin</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a2cda4c9af933ba7b46204284ce8351e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799c6a9b78dcf871f193a59117673f10" id="r_a799c6a9b78dcf871f193a59117673f10"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a799c6a9b78dcf871f193a59117673f10"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a799c6a9b78dcf871f193a59117673f10">ASin</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a799c6a9b78dcf871f193a59117673f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d43da55ca38ba9238baf6a4655ec621" id="r_a0d43da55ca38ba9238baf6a4655ec621"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a0d43da55ca38ba9238baf6a4655ec621"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d43da55ca38ba9238baf6a4655ec621">Cos</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a0d43da55ca38ba9238baf6a4655ec621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25da3bc32c648dbc8ab9713872b9a62f" id="r_a25da3bc32c648dbc8ab9713872b9a62f"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a25da3bc32c648dbc8ab9713872b9a62f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a25da3bc32c648dbc8ab9713872b9a62f">ACos</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a25da3bc32c648dbc8ab9713872b9a62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c05610ff1785a8a11044eb8365c4d4" id="r_a66c05610ff1785a8a11044eb8365c4d4"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a66c05610ff1785a8a11044eb8365c4d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66c05610ff1785a8a11044eb8365c4d4">Tan</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a66c05610ff1785a8a11044eb8365c4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c753d0b4b0d0aa0944f1d0120ef0592" id="r_a3c753d0b4b0d0aa0944f1d0120ef0592"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a3c753d0b4b0d0aa0944f1d0120ef0592"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c753d0b4b0d0aa0944f1d0120ef0592">ATan</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a3c753d0b4b0d0aa0944f1d0120ef0592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104395137f9cc30ddf1244d894061c3d" id="r_a104395137f9cc30ddf1244d894061c3d"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a104395137f9cc30ddf1244d894061c3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a104395137f9cc30ddf1244d894061c3d">ATan</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:a104395137f9cc30ddf1244d894061c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11851fa0bb8220a20cf504153d6329e" id="r_aa11851fa0bb8220a20cf504153d6329e"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:aa11851fa0bb8220a20cf504153d6329e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa11851fa0bb8220a20cf504153d6329e">ATan2</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="separator:aa11851fa0bb8220a20cf504153d6329e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4951f89b4120b9fd896b8fa11587d1b8" id="r_a4951f89b4120b9fd896b8fa11587d1b8"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a4951f89b4120b9fd896b8fa11587d1b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4951f89b4120b9fd896b8fa11587d1b8">SinCos</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T &amp;sinResult, T &amp;cosResult) noexcept</td></tr>
<tr class="memdesc:a4951f89b4120b9fd896b8fa11587d1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simultaneously compute the sine and cosine of x, where x is in radians, returning the sine in the variable referenced by sinResult, and the cosine in the variable referenced by cosResult.  <br /></td></tr>
<tr class="separator:a4951f89b4120b9fd896b8fa11587d1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b40bd264eba167ec8cf689504cf762" id="r_ad2b40bd264eba167ec8cf689504cf762"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ad2b40bd264eba167ec8cf689504cf762"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2b40bd264eba167ec8cf689504cf762">SinCos</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T *sinResult, T *cosResult) noexcept</td></tr>
<tr class="memdesc:ad2b40bd264eba167ec8cf689504cf762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simultaneously compute the sine and cosine of x, where x is in radians, returning the sine in the variable referenced by sinResult, and the cosine in the variable referenced by cosResult.  <br /></td></tr>
<tr class="separator:ad2b40bd264eba167ec8cf689504cf762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca64a6a4c5815e4a1505c462998dbd7" id="r_a9ca64a6a4c5815e4a1505c462998dbd7"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a9ca64a6a4c5815e4a1505c462998dbd7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ca64a6a4c5815e4a1505c462998dbd7">SinH</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a9ca64a6a4c5815e4a1505c462998dbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the hyperbolic sine of x.  <br /></td></tr>
<tr class="separator:a9ca64a6a4c5815e4a1505c462998dbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82e83021998ad5ba22d6defdef49d48" id="r_ab82e83021998ad5ba22d6defdef49d48"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ab82e83021998ad5ba22d6defdef49d48"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab82e83021998ad5ba22d6defdef49d48">ASinH</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:ab82e83021998ad5ba22d6defdef49d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse hyperbolic sine of x.  <br /></td></tr>
<tr class="separator:ab82e83021998ad5ba22d6defdef49d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411ed8e28031836f4e01e360335d7129" id="r_a411ed8e28031836f4e01e360335d7129"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a411ed8e28031836f4e01e360335d7129"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a411ed8e28031836f4e01e360335d7129">CosH</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a411ed8e28031836f4e01e360335d7129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the hyperbolic cosine of x.  <br /></td></tr>
<tr class="separator:a411ed8e28031836f4e01e360335d7129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf7efc2ffbd402a6ee28db4e313a19d" id="r_aaaf7efc2ffbd402a6ee28db4e313a19d"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:aaaf7efc2ffbd402a6ee28db4e313a19d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaaf7efc2ffbd402a6ee28db4e313a19d">ACosH</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:aaaf7efc2ffbd402a6ee28db4e313a19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse hyperbolic cosine of x.  <br /></td></tr>
<tr class="separator:aaaf7efc2ffbd402a6ee28db4e313a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556d81635f87c44de6b739a7144f0309" id="r_a556d81635f87c44de6b739a7144f0309"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a556d81635f87c44de6b739a7144f0309"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a556d81635f87c44de6b739a7144f0309">TanH</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a556d81635f87c44de6b739a7144f0309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the hyperbolic tangent of x.  <br /></td></tr>
<tr class="separator:a556d81635f87c44de6b739a7144f0309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a29b9decaea1c4a6b36adbe1d3b6bf7" id="r_a9a29b9decaea1c4a6b36adbe1d3b6bf7"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a9a29b9decaea1c4a6b36adbe1d3b6bf7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a29b9decaea1c4a6b36adbe1d3b6bf7">ATanH</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a9a29b9decaea1c4a6b36adbe1d3b6bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse hyperbolic tangent of x.  <br /></td></tr>
<tr class="separator:a9a29b9decaea1c4a6b36adbe1d3b6bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc08dabceed2b0fe1d001e8e7fb6433" id="r_a1fc08dabceed2b0fe1d001e8e7fb6433"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a1fc08dabceed2b0fe1d001e8e7fb6433"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1fc08dabceed2b0fe1d001e8e7fb6433">J0</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a1fc08dabceed2b0fe1d001e8e7fb6433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Bessel function of the first kind of order 0 for x.  <br /></td></tr>
<tr class="separator:a1fc08dabceed2b0fe1d001e8e7fb6433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501ebd9e91fa5c2273c68aa56b78361d" id="r_a501ebd9e91fa5c2273c68aa56b78361d"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a501ebd9e91fa5c2273c68aa56b78361d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a501ebd9e91fa5c2273c68aa56b78361d">J1</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a501ebd9e91fa5c2273c68aa56b78361d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Bessel function of the first kind of order 1 for x.  <br /></td></tr>
<tr class="separator:a501ebd9e91fa5c2273c68aa56b78361d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed25e81ab58703dcec8af889c876281" id="r_a8ed25e81ab58703dcec8af889c876281"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a8ed25e81ab58703dcec8af889c876281"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ed25e81ab58703dcec8af889c876281">JN</a> (int n, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a8ed25e81ab58703dcec8af889c876281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Bessel function of the first kind of order n for x.  <br /></td></tr>
<tr class="separator:a8ed25e81ab58703dcec8af889c876281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af430cdbdcbef67455f126323b1801d26" id="r_af430cdbdcbef67455f126323b1801d26"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:af430cdbdcbef67455f126323b1801d26"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af430cdbdcbef67455f126323b1801d26">Y0</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:af430cdbdcbef67455f126323b1801d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Bessel function of the second kind of order 0 for x.  <br /></td></tr>
<tr class="separator:af430cdbdcbef67455f126323b1801d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cedf1c5b8e7a5fed78c288367779db" id="r_aa8cedf1c5b8e7a5fed78c288367779db"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:aa8cedf1c5b8e7a5fed78c288367779db"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8cedf1c5b8e7a5fed78c288367779db">Y1</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:aa8cedf1c5b8e7a5fed78c288367779db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Bessel function of the second kind of order 1 for x.  <br /></td></tr>
<tr class="separator:aa8cedf1c5b8e7a5fed78c288367779db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea91c7434d4165907c15de2a82b01383" id="r_aea91c7434d4165907c15de2a82b01383"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:aea91c7434d4165907c15de2a82b01383"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea91c7434d4165907c15de2a82b01383">YN</a> (int n, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:aea91c7434d4165907c15de2a82b01383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Bessel function of the second kind of order n for x.  <br /></td></tr>
<tr class="separator:aea91c7434d4165907c15de2a82b01383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f6c4777e84c93e44097c6ba4cad0cc" id="r_ae4f6c4777e84c93e44097c6ba4cad0cc"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ae4f6c4777e84c93e44097c6ba4cad0cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae4f6c4777e84c93e44097c6ba4cad0cc">Erf</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:ae4f6c4777e84c93e44097c6ba4cad0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the error function of x.  <br /></td></tr>
<tr class="separator:ae4f6c4777e84c93e44097c6ba4cad0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e70557966a2c5b0b4d31a700e3288d" id="r_a97e70557966a2c5b0b4d31a700e3288d"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a97e70557966a2c5b0b4d31a700e3288d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97e70557966a2c5b0b4d31a700e3288d">ErfC</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a97e70557966a2c5b0b4d31a700e3288d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complementary error function of x,.  <br /></td></tr>
<tr class="separator:a97e70557966a2c5b0b4d31a700e3288d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739d328385f050bbe3f0b7f7fe65a44a" id="r_a739d328385f050bbe3f0b7f7fe65a44a"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a739d328385f050bbe3f0b7f7fe65a44a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a739d328385f050bbe3f0b7f7fe65a44a">TGamma</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:a739d328385f050bbe3f0b7f7fe65a44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gamma function of x.  <br /></td></tr>
<tr class="separator:a739d328385f050bbe3f0b7f7fe65a44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05d7353c0a884ee1a8ed360c06d31ed" id="r_af05d7353c0a884ee1a8ed360c06d31ed"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:af05d7353c0a884ee1a8ed360c06d31ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af05d7353c0a884ee1a8ed360c06d31ed">LGamma</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>) noexcept</td></tr>
<tr class="memdesc:af05d7353c0a884ee1a8ed360c06d31ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the absolute value of the gamma function of x.  <br /></td></tr>
<tr class="separator:af05d7353c0a884ee1a8ed360c06d31ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d433eed4b8c44d932a9ba4fb70158c7" id="r_a4d433eed4b8c44d932a9ba4fb70158c7"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a4d433eed4b8c44d932a9ba4fb70158c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d433eed4b8c44d932a9ba4fb70158c7">Remainder</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:a4d433eed4b8c44d932a9ba4fb70158c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the IEEE remainder of the floating point division operation x / y.  <br /></td></tr>
<tr class="separator:a4d433eed4b8c44d932a9ba4fb70158c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940c3e3c41ec9b4f2dcb7c58d7fee037" id="r_a940c3e3c41ec9b4f2dcb7c58d7fee037"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a940c3e3c41ec9b4f2dcb7c58d7fee037"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a940c3e3c41ec9b4f2dcb7c58d7fee037">RemQuo</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>, int *quo) noexcept</td></tr>
<tr class="memdesc:a940c3e3c41ec9b4f2dcb7c58d7fee037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation x / y like Remainder. Additionally, the sign and at least the three of the last bits of x / y will be stored in quo, sufficient to determine the octant of the result within a period.  <br /></td></tr>
<tr class="separator:a940c3e3c41ec9b4f2dcb7c58d7fee037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea80d9a0e521738b3a6318b731b16a96" id="r_aea80d9a0e521738b3a6318b731b16a96"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:aea80d9a0e521738b3a6318b731b16a96"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea80d9a0e521738b3a6318b731b16a96">FDim</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:aea80d9a0e521738b3a6318b731b16a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive difference between x and y, that is, if x &gt; y, returns x - y, otherwise (i.e. if x &lt;= y) returns +0.  <br /></td></tr>
<tr class="separator:aea80d9a0e521738b3a6318b731b16a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4d3e0d3dbb72267d64dd998e7daefe" id="r_a6f4d3e0d3dbb72267d64dd998e7daefe"><td class="memTemplParams" colspan="2">template&lt;IntegerType T&gt; </td></tr>
<tr class="memitem:a6f4d3e0d3dbb72267d64dd998e7daefe"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f4d3e0d3dbb72267d64dd998e7daefe">FMA</a> (T a, T b, T c) noexcept</td></tr>
<tr class="memdesc:a6f4d3e0d3dbb72267d64dd998e7daefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes x * y + z.  <br /></td></tr>
<tr class="separator:a6f4d3e0d3dbb72267d64dd998e7daefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dae882956db203d2d86a1beb21de149" id="r_a3dae882956db203d2d86a1beb21de149"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a3dae882956db203d2d86a1beb21de149"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3dae882956db203d2d86a1beb21de149">SinXOverX</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>)</td></tr>
<tr class="separator:a3dae882956db203d2d86a1beb21de149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe47c199d5e608fe1b01ccdecd75537e" id="r_afe47c199d5e608fe1b01ccdecd75537e"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:afe47c199d5e608fe1b01ccdecd75537e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe47c199d5e608fe1b01ccdecd75537e">Sinc</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>)</td></tr>
<tr class="separator:afe47c199d5e608fe1b01ccdecd75537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe09d2dc50c41f4f228d4d17c461b94" id="r_adbe09d2dc50c41f4f228d4d17c461b94"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:adbe09d2dc50c41f4f228d4d17c461b94"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbe09d2dc50c41f4f228d4d17c461b94">WindowedSinc</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T radius, T tau)</td></tr>
<tr class="separator:adbe09d2dc50c41f4f228d4d17c461b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07509bb6ccb3ed10316ac97c6694f4f5" id="r_a07509bb6ccb3ed10316ac97c6694f4f5"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a07509bb6ccb3ed10316ac97c6694f4f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07509bb6ccb3ed10316ac97c6694f4f5">Mod</a> (T a, T b)</td></tr>
<tr class="separator:a07509bb6ccb3ed10316ac97c6694f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18052b90b8098ed23fce3a0b97483b9d" id="r_a18052b90b8098ed23fce3a0b97483b9d"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a18052b90b8098ed23fce3a0b97483b9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18052b90b8098ed23fce3a0b97483b9d">Radians</a> (T deg)</td></tr>
<tr class="separator:a18052b90b8098ed23fce3a0b97483b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f7f39bed785c1c37775de0789ca8b4" id="r_a90f7f39bed785c1c37775de0789ca8b4"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a90f7f39bed785c1c37775de0789ca8b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90f7f39bed785c1c37775de0789ca8b4">Degrees</a> (T rad)</td></tr>
<tr class="separator:a90f7f39bed785c1c37775de0789ca8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1cef4f733e6ea947b5f4ebe2d9e8c8" id="r_a5b1cef4f733e6ea947b5f4ebe2d9e8c8"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a5b1cef4f733e6ea947b5f4ebe2d9e8c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5b1cef4f733e6ea947b5f4ebe2d9e8c8">SmoothStep</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, T a, T b)</td></tr>
<tr class="separator:a5b1cef4f733e6ea947b5f4ebe2d9e8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195cd91b0542e3d22137b7ec949100c0" id="r_a195cd91b0542e3d22137b7ec949100c0"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a195cd91b0542e3d22137b7ec949100c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a195cd91b0542e3d22137b7ec949100c0">SafeSqrt</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>)</td></tr>
<tr class="separator:a195cd91b0542e3d22137b7ec949100c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d281aa4ef59aa712d1d660f3174236" id="r_aa8d281aa4ef59aa712d1d660f3174236"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad60f420a7f44c2b0e9ce86950287dbad">IsArithmetic</a>&lt;T&gt; || <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a6d561311e1d4391071493f487c17876d">Internal::IsComplex</a>&lt;T&gt;</td></tr>
<tr class="memitem:aa8d281aa4ef59aa712d1d660f3174236"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8d281aa4ef59aa712d1d660f3174236">Sqr</a> (T v)</td></tr>
<tr class="separator:aa8d281aa4ef59aa712d1d660f3174236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5df1ed760186c3526db07be164a95f" id="r_a1c5df1ed760186c3526db07be164a95f"><td class="memTemplParams" colspan="2">template&lt;int n, FloatingPointType T&gt; </td></tr>
<tr class="memitem:a1c5df1ed760186c3526db07be164a95f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c5df1ed760186c3526db07be164a95f">FastPow</a> (T v)</td></tr>
<tr class="separator:a1c5df1ed760186c3526db07be164a95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5444782bd8dc7d8a07cd7301d838779d" id="r_a5444782bd8dc7d8a07cd7301d838779d"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, ArithmeticType C&gt; </td></tr>
<tr class="memitem:a5444782bd8dc7d8a07cd7301d838779d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5444782bd8dc7d8a07cd7301d838779d">EvaluatePolynomial</a> (T t, C c)</td></tr>
<tr class="separator:a5444782bd8dc7d8a07cd7301d838779d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f960d3c2e0495e046afd61dadaa79e7" id="r_a3f960d3c2e0495e046afd61dadaa79e7"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, ArithmeticType C, ArithmeticType ... Args&gt; </td></tr>
<tr class="memitem:a3f960d3c2e0495e046afd61dadaa79e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f960d3c2e0495e046afd61dadaa79e7">EvaluatePolynomial</a> (T t, C c, Args... remaining)</td></tr>
<tr class="separator:a3f960d3c2e0495e046afd61dadaa79e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595908c27d79b6389435e1ffbb27d23f" id="r_a595908c27d79b6389435e1ffbb27d23f"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a595908c27d79b6389435e1ffbb27d23f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a595908c27d79b6389435e1ffbb27d23f">SafeASin</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>)</td></tr>
<tr class="separator:a595908c27d79b6389435e1ffbb27d23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc13a292cba2405c45b85d031b77514" id="r_a9fc13a292cba2405c45b85d031b77514"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a9fc13a292cba2405c45b85d031b77514"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9fc13a292cba2405c45b85d031b77514">SafeACos</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>)</td></tr>
<tr class="separator:a9fc13a292cba2405c45b85d031b77514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939ca8cd91bba4d403003680873c25eb" id="r_a939ca8cd91bba4d403003680873c25eb"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a939ca8cd91bba4d403003680873c25eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a939ca8cd91bba4d403003680873c25eb">NextFloatUp</a> (T v)</td></tr>
<tr class="separator:a939ca8cd91bba4d403003680873c25eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae874ad9152102733a556467751941bf5" id="r_ae874ad9152102733a556467751941bf5"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ae874ad9152102733a556467751941bf5"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae874ad9152102733a556467751941bf5">NextFloatDown</a> (T v)</td></tr>
<tr class="separator:ae874ad9152102733a556467751941bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff294e4dc26a76c07eee6516e24a63b" id="r_a2ff294e4dc26a76c07eee6516e24a63b"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a2ff294e4dc26a76c07eee6516e24a63b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ff294e4dc26a76c07eee6516e24a63b">Gamma</a> (int n)</td></tr>
<tr class="separator:a2ff294e4dc26a76c07eee6516e24a63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a4e8b02290576eda68b4a39dbc644f" id="r_af1a4e8b02290576eda68b4a39dbc644f"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:af1a4e8b02290576eda68b4a39dbc644f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1a4e8b02290576eda68b4a39dbc644f">AddAdjustUp</a> (T a, T b)</td></tr>
<tr class="separator:af1a4e8b02290576eda68b4a39dbc644f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7317afcfb2986b82fb7ee42610fc4991" id="r_a7317afcfb2986b82fb7ee42610fc4991"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a7317afcfb2986b82fb7ee42610fc4991"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7317afcfb2986b82fb7ee42610fc4991">AddAdjustDown</a> (T a, T b)</td></tr>
<tr class="separator:a7317afcfb2986b82fb7ee42610fc4991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe0d52f39ed6609f80823d4e1e13da0" id="r_aabe0d52f39ed6609f80823d4e1e13da0"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:aabe0d52f39ed6609f80823d4e1e13da0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aabe0d52f39ed6609f80823d4e1e13da0">SubAdjustUp</a> (T a, T b)</td></tr>
<tr class="separator:aabe0d52f39ed6609f80823d4e1e13da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08144ad5b613b4d2de2710a4706c99a5" id="r_a08144ad5b613b4d2de2710a4706c99a5"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a08144ad5b613b4d2de2710a4706c99a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08144ad5b613b4d2de2710a4706c99a5">SubAdjustDown</a> (T a, T b)</td></tr>
<tr class="separator:a08144ad5b613b4d2de2710a4706c99a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc183fa5b72c01ba711f24aeacc7f0c" id="r_aafc183fa5b72c01ba711f24aeacc7f0c"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:aafc183fa5b72c01ba711f24aeacc7f0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aafc183fa5b72c01ba711f24aeacc7f0c">MulAdjustUp</a> (T a, T b)</td></tr>
<tr class="separator:aafc183fa5b72c01ba711f24aeacc7f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73d72979429033d3cce706c4cd8bcaa" id="r_ae73d72979429033d3cce706c4cd8bcaa"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:ae73d72979429033d3cce706c4cd8bcaa"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae73d72979429033d3cce706c4cd8bcaa">MulAdjustDown</a> (T a, T b)</td></tr>
<tr class="separator:ae73d72979429033d3cce706c4cd8bcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c4e7d809288dbc2f8e7223b3940e3d" id="r_a18c4e7d809288dbc2f8e7223b3940e3d"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a18c4e7d809288dbc2f8e7223b3940e3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a18c4e7d809288dbc2f8e7223b3940e3d">DivAdjustUp</a> (T a, T b)</td></tr>
<tr class="separator:a18c4e7d809288dbc2f8e7223b3940e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a07d6a2a096115ebcff9fc1e8bde70" id="r_a09a07d6a2a096115ebcff9fc1e8bde70"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a09a07d6a2a096115ebcff9fc1e8bde70"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09a07d6a2a096115ebcff9fc1e8bde70">DivAdjustDown</a> (T a, T b)</td></tr>
<tr class="separator:a09a07d6a2a096115ebcff9fc1e8bde70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084d90500487f34529e59fd7e373de9e" id="r_a084d90500487f34529e59fd7e373de9e"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a084d90500487f34529e59fd7e373de9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a084d90500487f34529e59fd7e373de9e">SqrtAdjustUp</a> (T a)</td></tr>
<tr class="separator:a084d90500487f34529e59fd7e373de9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fc2a3d45bd254b655d6b90b623f78d" id="r_a32fc2a3d45bd254b655d6b90b623f78d"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a32fc2a3d45bd254b655d6b90b623f78d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32fc2a3d45bd254b655d6b90b623f78d">SqrtAdjustDown</a> (T a)</td></tr>
<tr class="separator:a32fc2a3d45bd254b655d6b90b623f78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb87270bbb9896e7916a87e0ea1847f" id="r_a8eb87270bbb9896e7916a87e0ea1847f"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a8eb87270bbb9896e7916a87e0ea1847f"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8eb87270bbb9896e7916a87e0ea1847f">FMAAdjustUp</a> (T a, T b, T c)</td></tr>
<tr class="separator:a8eb87270bbb9896e7916a87e0ea1847f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb4e84b2e36d4607c03d4d703d3c5f8" id="r_a0eb4e84b2e36d4607c03d4d703d3c5f8"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a0eb4e84b2e36d4607c03d4d703d3c5f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0eb4e84b2e36d4607c03d4d703d3c5f8">FMAAdjustDown</a> (T a, T b, T c)</td></tr>
<tr class="separator:a0eb4e84b2e36d4607c03d4d703d3c5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ebf37928155c37ee910907857d117e" id="r_a11ebf37928155c37ee910907857d117e"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T&gt; </td></tr>
<tr class="memitem:a11ebf37928155c37ee910907857d117e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a11ebf37928155c37ee910907857d117e">FastLog2</a> (T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>)</td></tr>
<tr class="separator:a11ebf37928155c37ee910907857d117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f86debde39dc16f64a157265d77700" id="r_a64f86debde39dc16f64a157265d77700"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64f86debde39dc16f64a157265d77700">Log2Int</a> (float v)</td></tr>
<tr class="separator:a64f86debde39dc16f64a157265d77700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6658c049e2f62c3d470d32a214e9c66" id="r_af6658c049e2f62c3d470d32a214e9c66"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6658c049e2f62c3d470d32a214e9c66">Log2Int</a> (double v)</td></tr>
<tr class="separator:af6658c049e2f62c3d470d32a214e9c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbf8872f8a0d4d9cc93bbda69ae249c" id="r_a3cbf8872f8a0d4d9cc93bbda69ae249c"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cbf8872f8a0d4d9cc93bbda69ae249c">Log2Int</a> (<a class="el" href="namespace_harlinn_1_1_common.html#af3ce862d19ad61e7bef7ba1566ed81ef">UInt32</a> v)</td></tr>
<tr class="separator:a3cbf8872f8a0d4d9cc93bbda69ae249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0fee20a8f86793106767abb1088385" id="r_a2d0fee20a8f86793106767abb1088385"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d0fee20a8f86793106767abb1088385">Log2Int</a> (<a class="el" href="namespace_harlinn_1_1_common.html#a77b0045551d73ca9f4fb32769fa84426">Int32</a> v)</td></tr>
<tr class="separator:a2d0fee20a8f86793106767abb1088385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7045ebdf960a71823ac55392805c93cc" id="r_a7045ebdf960a71823ac55392805c93cc"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7045ebdf960a71823ac55392805c93cc">Log2Int</a> (<a class="el" href="namespace_harlinn_1_1_common.html#aeaa56507a02c6cfabe794d1df81a442a">UInt64</a> v)</td></tr>
<tr class="separator:a7045ebdf960a71823ac55392805c93cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420ec10538a1b01f25fc46d2b02e03a3" id="r_a420ec10538a1b01f25fc46d2b02e03a3"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a420ec10538a1b01f25fc46d2b02e03a3">Log2Int</a> (<a class="el" href="namespace_harlinn_1_1_common.html#a5a63a6a5f3e67cefd19fb0873208989d">Int64</a> v)</td></tr>
<tr class="separator:a420ec10538a1b01f25fc46d2b02e03a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37735b1dec272dc3c997e13e402c3e3" id="r_aa37735b1dec272dc3c997e13e402c3e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</td></tr>
<tr class="memitem:aa37735b1dec272dc3c997e13e402c3e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa37735b1dec272dc3c997e13e402c3e3">Log4Int</a> (T v)</td></tr>
<tr class="separator:aa37735b1dec272dc3c997e13e402c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdd066b5a9e689f03cb24b5ade46858" id="r_aacdd066b5a9e689f03cb24b5ade46858"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacdd066b5a9e689f03cb24b5ade46858">FastExp</a> (float <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>)</td></tr>
<tr class="separator:aacdd066b5a9e689f03cb24b5ade46858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00981cc6ae3f1fe8ec89bb3b0bd06cdf" id="r_a00981cc6ae3f1fe8ec89bb3b0bd06cdf"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a00981cc6ae3f1fe8ec89bb3b0bd06cdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00981cc6ae3f1fe8ec89bb3b0bd06cdf">Gaussian</a> (FloatT <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, FloatT mu=0, FloatT sigma=1)</td></tr>
<tr class="separator:a00981cc6ae3f1fe8ec89bb3b0bd06cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be9f5eccd842bad03d6eb9051903a56" id="r_a9be9f5eccd842bad03d6eb9051903a56"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a9be9f5eccd842bad03d6eb9051903a56"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9be9f5eccd842bad03d6eb9051903a56">GaussianIntegral</a> (FloatT x0, FloatT x1, FloatT mu=0, FloatT sigma=1)</td></tr>
<tr class="separator:a9be9f5eccd842bad03d6eb9051903a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aabce1f77ad6a81ff997a7d9510aa0b" id="r_a8aabce1f77ad6a81ff997a7d9510aa0b"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a8aabce1f77ad6a81ff997a7d9510aa0b"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8aabce1f77ad6a81ff997a7d9510aa0b">Logistic</a> (FloatT <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, FloatT s)</td></tr>
<tr class="separator:a8aabce1f77ad6a81ff997a7d9510aa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e80a962d96d83c3d005c65decc3b93" id="r_a89e80a962d96d83c3d005c65decc3b93"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a89e80a962d96d83c3d005c65decc3b93"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a89e80a962d96d83c3d005c65decc3b93">LogisticCDF</a> (FloatT <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, FloatT s)</td></tr>
<tr class="separator:a89e80a962d96d83c3d005c65decc3b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115d953bebc17484e40b616eab6baeae" id="r_a115d953bebc17484e40b616eab6baeae"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a115d953bebc17484e40b616eab6baeae"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a115d953bebc17484e40b616eab6baeae">TrimmedLogistic</a> (FloatT <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, FloatT s, FloatT a, FloatT b)</td></tr>
<tr class="separator:a115d953bebc17484e40b616eab6baeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44d390f796b302e52de71eaebf5c575" id="r_ab44d390f796b302e52de71eaebf5c575"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:ab44d390f796b302e52de71eaebf5c575"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab44d390f796b302e52de71eaebf5c575">ErfInv</a> (FloatT a)</td></tr>
<tr class="separator:ab44d390f796b302e52de71eaebf5c575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30f914835c0e82d5f1ab346b96dacbd" id="r_ae30f914835c0e82d5f1ab346b96dacbd"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:ae30f914835c0e82d5f1ab346b96dacbd"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae30f914835c0e82d5f1ab346b96dacbd">I0</a> (FloatT <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>)</td></tr>
<tr class="separator:ae30f914835c0e82d5f1ab346b96dacbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cf4c3f7c5688ffaddb00d62dd2de97" id="r_a91cf4c3f7c5688ffaddb00d62dd2de97"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a91cf4c3f7c5688ffaddb00d62dd2de97"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91cf4c3f7c5688ffaddb00d62dd2de97">LogI0</a> (FloatT <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>)</td></tr>
<tr class="separator:a91cf4c3f7c5688ffaddb00d62dd2de97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516b8f4a37a50a03f4fee69f43d2cd2a" id="r_a516b8f4a37a50a03f4fee69f43d2cd2a"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a516b8f4a37a50a03f4fee69f43d2cd2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a516b8f4a37a50a03f4fee69f43d2cd2a">FindInterval</a> (size_t sz, const Predicate &amp;pred)</td></tr>
<tr class="separator:a516b8f4a37a50a03f4fee69f43d2cd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5683565083500bfc43984e6866f7eb85" id="r_a5683565083500bfc43984e6866f7eb85"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5683565083500bfc43984e6866f7eb85"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5683565083500bfc43984e6866f7eb85">IsPowerOf4</a> (T v)</td></tr>
<tr class="separator:a5683565083500bfc43984e6866f7eb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab108521bc793a505b9d93d50f1db0eaf" id="r_ab108521bc793a505b9d93d50f1db0eaf"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_harlinn_1_1_common.html#a77b0045551d73ca9f4fb32769fa84426">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab108521bc793a505b9d93d50f1db0eaf">RoundUpPow2</a> (<a class="el" href="namespace_harlinn_1_1_common.html#a77b0045551d73ca9f4fb32769fa84426">Int32</a> v)</td></tr>
<tr class="separator:ab108521bc793a505b9d93d50f1db0eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e37e862367f901968ae1f0e7400176" id="r_a37e37e862367f901968ae1f0e7400176"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_harlinn_1_1_common.html#a5a63a6a5f3e67cefd19fb0873208989d">Int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37e37e862367f901968ae1f0e7400176">RoundUpPow2</a> (<a class="el" href="namespace_harlinn_1_1_common.html#a5a63a6a5f3e67cefd19fb0873208989d">Int64</a> v)</td></tr>
<tr class="separator:a37e37e862367f901968ae1f0e7400176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1ea54e3924007682ae3b77ba499e69" id="r_a7c1ea54e3924007682ae3b77ba499e69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c1ea54e3924007682ae3b77ba499e69"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c1ea54e3924007682ae3b77ba499e69">RoundUpPow4</a> (T v)</td></tr>
<tr class="separator:a7c1ea54e3924007682ae3b77ba499e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88433afa7fe7737d2f6a5d25c1f7c8e2" id="r_a88433afa7fe7737d2f6a5d25c1f7c8e2"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a88433afa7fe7737d2f6a5d25c1f7c8e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="class_harlinn_1_1_math_1_1_compensated_float.html">CompensatedFloat</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88433afa7fe7737d2f6a5d25c1f7c8e2">TwoProd</a> (FloatT a, FloatT b)</td></tr>
<tr class="separator:a88433afa7fe7737d2f6a5d25c1f7c8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad603311032dd7770227e6a71e021e0a7" id="r_ad603311032dd7770227e6a71e021e0a7"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:ad603311032dd7770227e6a71e021e0a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="class_harlinn_1_1_math_1_1_compensated_float.html">CompensatedFloat</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad603311032dd7770227e6a71e021e0a7">TwoSum</a> (FloatT a, FloatT b)</td></tr>
<tr class="separator:ad603311032dd7770227e6a71e021e0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919dbd5d34368d35dc39ae109e215816" id="r_a919dbd5d34368d35dc39ae109e215816"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tc , typename Td &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Ta&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Tb&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Tc&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Td&gt;</td></tr>
<tr class="memitem:a919dbd5d34368d35dc39ae109e215816"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a919dbd5d34368d35dc39ae109e215816">DifferenceOfProducts</a> (Ta a, Tb b, Tc c, Td d)</td></tr>
<tr class="separator:a919dbd5d34368d35dc39ae109e215816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8794de781c29b9ead14f92f70fa60a4a" id="r_a8794de781c29b9ead14f92f70fa60a4a"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tc , typename Td &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Ta&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Tb&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Tc&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Td&gt;</td></tr>
<tr class="memitem:a8794de781c29b9ead14f92f70fa60a4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8794de781c29b9ead14f92f70fa60a4a">SumOfProducts</a> (Ta a, Tb b, Tc c, Td d)</td></tr>
<tr class="separator:a8794de781c29b9ead14f92f70fa60a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cff981831af77ad2c52cfea1d466c71" id="r_a3cff981831af77ad2c52cfea1d466c71"><td class="memTemplParams" colspan="2">template&lt;typename FloatT , typename... T&gt; <br />
requires std::conjunction_v&lt;std::is_arithmetic&lt;T&gt;...&gt;</td></tr>
<tr class="memitem:a3cff981831af77ad2c52cfea1d466c71"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3cff981831af77ad2c52cfea1d466c71">InnerProduct</a> (FloatT term, T... terms)</td></tr>
<tr class="separator:a3cff981831af77ad2c52cfea1d466c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89bfa35a14bde7c41205d954259fd7e" id="r_ae89bfa35a14bde7c41205d954259fd7e"><td class="memTemplParams" colspan="2">template&lt;typename FloatT , typename... T&gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:ae89bfa35a14bde7c41205d954259fd7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae89bfa35a14bde7c41205d954259fd7e">Quadratic</a> (FloatT a, FloatT b, FloatT c, FloatT *t0, FloatT *t1)</td></tr>
<tr class="separator:ae89bfa35a14bde7c41205d954259fd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a767eb20f2828f140fa235bd4f1c3a" id="r_a92a767eb20f2828f140fa235bd4f1c3a"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename FloatT &gt; </td></tr>
<tr class="memitem:a92a767eb20f2828f140fa235bd4f1c3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92a767eb20f2828f140fa235bd4f1c3a">NewtonBisection</a> (FloatT x0, FloatT x1, Func f, FloatT xEps=static_cast&lt; FloatT &gt;(1e-6), FloatT fEps=static_cast&lt; FloatT &gt;(1e-6))</td></tr>
<tr class="separator:a92a767eb20f2828f140fa235bd4f1c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c667e872e2767792400a697b3729e5" id="r_ad8c667e872e2767792400a697b3729e5"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:ad8c667e872e2767792400a697b3729e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8c667e872e2767792400a697b3729e5">InRange</a> (FloatT value, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;interval)</td></tr>
<tr class="separator:ad8c667e872e2767792400a697b3729e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d64f9c0d4b1a1fcca98f707dbb94fcf" id="r_a0d64f9c0d4b1a1fcca98f707dbb94fcf"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a0d64f9c0d4b1a1fcca98f707dbb94fcf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d64f9c0d4b1a1fcca98f707dbb94fcf">InRange</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;first, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;second)</td></tr>
<tr class="separator:a0d64f9c0d4b1a1fcca98f707dbb94fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d758869a4905dc59b83cd1d6adbf250" id="r_a3d758869a4905dc59b83cd1d6adbf250"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a3d758869a4905dc59b83cd1d6adbf250"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d758869a4905dc59b83cd1d6adbf250">Sqr</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;interval)</td></tr>
<tr class="separator:a3d758869a4905dc59b83cd1d6adbf250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e7fe8d6be7d35f5d4cbbb2f0cddd65" id="r_ab2e7fe8d6be7d35f5d4cbbb2f0cddd65"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:ab2e7fe8d6be7d35f5d4cbbb2f0cddd65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2e7fe8d6be7d35f5d4cbbb2f0cddd65">MulPow2</a> (FloatT s, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:ab2e7fe8d6be7d35f5d4cbbb2f0cddd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d90e559811788807d0b98f0f34b452" id="r_a33d90e559811788807d0b98f0f34b452"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a33d90e559811788807d0b98f0f34b452"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a33d90e559811788807d0b98f0f34b452">MulPow2</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i, FloatT s)</td></tr>
<tr class="separator:a33d90e559811788807d0b98f0f34b452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409278e466d1ef6f3d50a79b843f8064" id="r_a409278e466d1ef6f3d50a79b843f8064"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a409278e466d1ef6f3d50a79b843f8064"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a409278e466d1ef6f3d50a79b843f8064">operator+</a> (FloatT f, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a409278e466d1ef6f3d50a79b843f8064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c836d3a9f25f6a173c5b889b020539" id="r_a21c836d3a9f25f6a173c5b889b020539"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a21c836d3a9f25f6a173c5b889b020539"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21c836d3a9f25f6a173c5b889b020539">operator-</a> (FloatT f, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a21c836d3a9f25f6a173c5b889b020539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5fc3ae8a4ad401ec839e8b0edc4fa7" id="r_aad5fc3ae8a4ad401ec839e8b0edc4fa7"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:aad5fc3ae8a4ad401ec839e8b0edc4fa7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad5fc3ae8a4ad401ec839e8b0edc4fa7">operator*</a> (FloatT f, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:aad5fc3ae8a4ad401ec839e8b0edc4fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e5e0f74f67e0adce00d8354d407ce6" id="r_a78e5e0f74f67e0adce00d8354d407ce6"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a78e5e0f74f67e0adce00d8354d407ce6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a78e5e0f74f67e0adce00d8354d407ce6">operator/</a> (FloatT f, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a78e5e0f74f67e0adce00d8354d407ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d63fa830edbf36f11d655adca722e8d" id="r_a3d63fa830edbf36f11d655adca722e8d"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a3d63fa830edbf36f11d655adca722e8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d63fa830edbf36f11d655adca722e8d">operator+</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i, FloatT f)</td></tr>
<tr class="separator:a3d63fa830edbf36f11d655adca722e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3f1550c8d3db01137c5174708107db" id="r_a7d3f1550c8d3db01137c5174708107db"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a7d3f1550c8d3db01137c5174708107db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7d3f1550c8d3db01137c5174708107db">operator-</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i, FloatT f)</td></tr>
<tr class="separator:a7d3f1550c8d3db01137c5174708107db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a49b78aeae4d390313225ae45a1d7b2" id="r_a5a49b78aeae4d390313225ae45a1d7b2"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a5a49b78aeae4d390313225ae45a1d7b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a49b78aeae4d390313225ae45a1d7b2">operator*</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i, FloatT f)</td></tr>
<tr class="separator:a5a49b78aeae4d390313225ae45a1d7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16a4fb74752628dce94403bfba49c45" id="r_aa16a4fb74752628dce94403bfba49c45"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:aa16a4fb74752628dce94403bfba49c45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa16a4fb74752628dce94403bfba49c45">operator/</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i, FloatT f)</td></tr>
<tr class="separator:aa16a4fb74752628dce94403bfba49c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538a2f0dc4ebc31bc5bb59fc1ce7c0ce" id="r_a538a2f0dc4ebc31bc5bb59fc1ce7c0ce"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a538a2f0dc4ebc31bc5bb59fc1ce7c0ce"><td class="memTemplItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a538a2f0dc4ebc31bc5bb59fc1ce7c0ce">Floor</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a538a2f0dc4ebc31bc5bb59fc1ce7c0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7714971b42c40cee6d336bb04e018904" id="r_a7714971b42c40cee6d336bb04e018904"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a7714971b42c40cee6d336bb04e018904"><td class="memTemplItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7714971b42c40cee6d336bb04e018904">Ceil</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a7714971b42c40cee6d336bb04e018904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfbe4e59af9d12e0c9afd4e321412f2" id="r_aadfbe4e59af9d12e0c9afd4e321412f2"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:aadfbe4e59af9d12e0c9afd4e321412f2"><td class="memTemplItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aadfbe4e59af9d12e0c9afd4e321412f2">floor</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:aadfbe4e59af9d12e0c9afd4e321412f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38af4120787df828c7ab2ea17a555b38" id="r_a38af4120787df828c7ab2ea17a555b38"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a38af4120787df828c7ab2ea17a555b38"><td class="memTemplItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38af4120787df828c7ab2ea17a555b38">ceil</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a38af4120787df828c7ab2ea17a555b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fe9032f5b3ca782d8676ec32e8c522" id="r_a81fe9032f5b3ca782d8676ec32e8c522"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a81fe9032f5b3ca782d8676ec32e8c522"><td class="memTemplItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81fe9032f5b3ca782d8676ec32e8c522">Min</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;a, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;b)</td></tr>
<tr class="separator:a81fe9032f5b3ca782d8676ec32e8c522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a077f0e4bc1fc55873d076bf9eb371" id="r_a31a077f0e4bc1fc55873d076bf9eb371"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a31a077f0e4bc1fc55873d076bf9eb371"><td class="memTemplItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a31a077f0e4bc1fc55873d076bf9eb371">Max</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;a, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;b)</td></tr>
<tr class="separator:a31a077f0e4bc1fc55873d076bf9eb371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b48c2bc648a9044d8d25824a37d332b" id="r_a7b48c2bc648a9044d8d25824a37d332b"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a7b48c2bc648a9044d8d25824a37d332b"><td class="memTemplItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b48c2bc648a9044d8d25824a37d332b">min</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;a, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;b)</td></tr>
<tr class="separator:a7b48c2bc648a9044d8d25824a37d332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584ff6c249acb5c9937b9c15f9af3094" id="r_a584ff6c249acb5c9937b9c15f9af3094"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a584ff6c249acb5c9937b9c15f9af3094"><td class="memTemplItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a584ff6c249acb5c9937b9c15f9af3094">max</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;a, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;b)</td></tr>
<tr class="separator:a584ff6c249acb5c9937b9c15f9af3094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae378941c4232854a169b595cac51f8b6" id="r_ae378941c4232854a169b595cac51f8b6"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:ae378941c4232854a169b595cac51f8b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae378941c4232854a169b595cac51f8b6">Sqrt</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:ae378941c4232854a169b595cac51f8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1b92832070c2e8e400e5b27076067f" id="r_a6e1b92832070c2e8e400e5b27076067f"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a6e1b92832070c2e8e400e5b27076067f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e1b92832070c2e8e400e5b27076067f">sqrt</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a6e1b92832070c2e8e400e5b27076067f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cb5da363ace69a1f680c9bb0ea2d3a" id="r_a47cb5da363ace69a1f680c9bb0ea2d3a"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a47cb5da363ace69a1f680c9bb0ea2d3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a47cb5da363ace69a1f680c9bb0ea2d3a">FMA</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;a, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;b, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;c)</td></tr>
<tr class="separator:a47cb5da363ace69a1f680c9bb0ea2d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8663d793ab630d7626d3ed9df0588185" id="r_a8663d793ab630d7626d3ed9df0588185"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a8663d793ab630d7626d3ed9df0588185"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8663d793ab630d7626d3ed9df0588185">DifferenceOfProducts</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;a, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;b, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;c, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;d)</td></tr>
<tr class="separator:a8663d793ab630d7626d3ed9df0588185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421921bcf9992b0f27dbb0a513a5f2ee" id="r_a421921bcf9992b0f27dbb0a513a5f2ee"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a421921bcf9992b0f27dbb0a513a5f2ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a421921bcf9992b0f27dbb0a513a5f2ee">SumOfProducts</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;a, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;b, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;c, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;d)</td></tr>
<tr class="separator:a421921bcf9992b0f27dbb0a513a5f2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832789d34c30752ca8c56ce1aabd4eea" id="r_a832789d34c30752ca8c56ce1aabd4eea"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a832789d34c30752ca8c56ce1aabd4eea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a832789d34c30752ca8c56ce1aabd4eea">Abs</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a832789d34c30752ca8c56ce1aabd4eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff71ab5e0388ba969d625a90c4f4ffd" id="r_a7ff71ab5e0388ba969d625a90c4f4ffd"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a7ff71ab5e0388ba969d625a90c4f4ffd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ff71ab5e0388ba969d625a90c4f4ffd">abs</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a7ff71ab5e0388ba969d625a90c4f4ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1a6cb5c100e56b0a9ab52177e51aba" id="r_aba1a6cb5c100e56b0a9ab52177e51aba"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:aba1a6cb5c100e56b0a9ab52177e51aba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba1a6cb5c100e56b0a9ab52177e51aba">ACos</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:aba1a6cb5c100e56b0a9ab52177e51aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed3ad7f508d48826bb791e737cca7b0" id="r_a5ed3ad7f508d48826bb791e737cca7b0"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a5ed3ad7f508d48826bb791e737cca7b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ed3ad7f508d48826bb791e737cca7b0">Sin</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a5ed3ad7f508d48826bb791e737cca7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551e47906438fa3a4da84c967fbff320" id="r_a551e47906438fa3a4da84c967fbff320"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a551e47906438fa3a4da84c967fbff320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a551e47906438fa3a4da84c967fbff320">Cos</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a551e47906438fa3a4da84c967fbff320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71849e3814aba993a77ffc5186e9164c" id="r_a71849e3814aba993a77ffc5186e9164c"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a71849e3814aba993a77ffc5186e9164c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71849e3814aba993a77ffc5186e9164c">SinCos</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i, <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; *sine, <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; *cosine)</td></tr>
<tr class="separator:a71849e3814aba993a77ffc5186e9164c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8dc8ddc9e5ec45310f4757a2c792ff" id="r_a1d8dc8ddc9e5ec45310f4757a2c792ff"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a1d8dc8ddc9e5ec45310f4757a2c792ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d8dc8ddc9e5ec45310f4757a2c792ff">Quadratic</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;a, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;b, const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;c, <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; *t0, <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; *t1)</td></tr>
<tr class="separator:a1d8dc8ddc9e5ec45310f4757a2c792ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62868ab4274547369265ecd49fb53c48" id="r_a62868ab4274547369265ecd49fb53c48"><td class="memTemplParams" colspan="2">template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:a62868ab4274547369265ecd49fb53c48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62868ab4274547369265ecd49fb53c48">SumSquares</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i)</td></tr>
<tr class="separator:a62868ab4274547369265ecd49fb53c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af987177f961161198080296c3753949d" id="r_af987177f961161198080296c3753949d"><td class="memTemplParams" colspan="2">template&lt;typename FloatT , typename... Args&gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</td></tr>
<tr class="memitem:af987177f961161198080296c3753949d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af987177f961161198080296c3753949d">SumSquares</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;i, Args... args)</td></tr>
<tr class="separator:af987177f961161198080296c3753949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ae646ff1e802e9701420136bd99355" id="r_af6ae646ff1e802e9701420136bd99355"><td class="memTemplParams" colspan="2">template&lt;FloatingPointType T, size_t N&gt; </td></tr>
<tr class="memitem:af6ae646ff1e802e9701420136bd99355"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6ae646ff1e802e9701420136bd99355">Length</a> (const <a class="el" href="struct_harlinn_1_1_math_1_1_segment_simd.html">SegmentSimd</a>&lt; T, N &gt; &amp;segment) noexcept</td></tr>
<tr class="separator:af6ae646ff1e802e9701420136bd99355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726582658d819e2fe9058a29585a1d01" id="r_a726582658d819e2fe9058a29585a1d01"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a726582658d819e2fe9058a29585a1d01"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a726582658d819e2fe9058a29585a1d01">operator+</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a726582658d819e2fe9058a29585a1d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61df58af6d114274fa4e6f58e8d32dee" id="r_a61df58af6d114274fa4e6f58e8d32dee"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a61df58af6d114274fa4e6f58e8d32dee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a61df58af6d114274fa4e6f58e8d32dee">operator+</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a61df58af6d114274fa4e6f58e8d32dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a0e2d9c465eaed946fa1ba63188357" id="r_ae8a0e2d9c465eaed946fa1ba63188357"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdType U&gt; </td></tr>
<tr class="memitem:ae8a0e2d9c465eaed946fa1ba63188357"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8a0e2d9c465eaed946fa1ba63188357">operator+</a> (const T lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:ae8a0e2d9c465eaed946fa1ba63188357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f8064476de8b0b807097abeee2c069" id="r_ab2f8064476de8b0b807097abeee2c069"><td class="memTemplParams" colspan="2">template&lt;SimdType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:ab2f8064476de8b0b807097abeee2c069"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab2f8064476de8b0b807097abeee2c069">operator+</a> (const T &amp;lhs, const U rhs) noexcept</td></tr>
<tr class="separator:ab2f8064476de8b0b807097abeee2c069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0934259447700358bac589f28321b16" id="r_af0934259447700358bac589f28321b16"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:af0934259447700358bac589f28321b16"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0934259447700358bac589f28321b16">operator-</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:af0934259447700358bac589f28321b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f77eb3a070c947954a5fa9c7244f104" id="r_a4f77eb3a070c947954a5fa9c7244f104"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a4f77eb3a070c947954a5fa9c7244f104"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f77eb3a070c947954a5fa9c7244f104">operator-</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a4f77eb3a070c947954a5fa9c7244f104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ac4e94c4b95ab8f35d7d581403624d" id="r_ab7ac4e94c4b95ab8f35d7d581403624d"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdType U&gt; </td></tr>
<tr class="memitem:ab7ac4e94c4b95ab8f35d7d581403624d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7ac4e94c4b95ab8f35d7d581403624d">operator-</a> (const T lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:ab7ac4e94c4b95ab8f35d7d581403624d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5c4266a6a4b1b74522d2eb5b28327c" id="r_a4e5c4266a6a4b1b74522d2eb5b28327c"><td class="memTemplParams" colspan="2">template&lt;SimdType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a4e5c4266a6a4b1b74522d2eb5b28327c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e5c4266a6a4b1b74522d2eb5b28327c">operator-</a> (const T &amp;lhs, const U rhs) noexcept</td></tr>
<tr class="separator:a4e5c4266a6a4b1b74522d2eb5b28327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693f28aa5d9d036abf1009bc4676c05c" id="r_a693f28aa5d9d036abf1009bc4676c05c"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a693f28aa5d9d036abf1009bc4676c05c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a693f28aa5d9d036abf1009bc4676c05c">operator*</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a693f28aa5d9d036abf1009bc4676c05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d636e6dd4e1f567716d110933253392" id="r_a0d636e6dd4e1f567716d110933253392"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a0d636e6dd4e1f567716d110933253392"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d636e6dd4e1f567716d110933253392">operator*</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a0d636e6dd4e1f567716d110933253392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4813d8bf729860f3143562f695770d" id="r_afe4813d8bf729860f3143562f695770d"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdType U&gt; </td></tr>
<tr class="memitem:afe4813d8bf729860f3143562f695770d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe4813d8bf729860f3143562f695770d">operator*</a> (const T lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:afe4813d8bf729860f3143562f695770d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae053ddb366ca16ded34b11d8c9ffc68c" id="r_ae053ddb366ca16ded34b11d8c9ffc68c"><td class="memTemplParams" colspan="2">template&lt;SimdType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:ae053ddb366ca16ded34b11d8c9ffc68c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae053ddb366ca16ded34b11d8c9ffc68c">operator*</a> (const T &amp;lhs, const U rhs) noexcept</td></tr>
<tr class="separator:ae053ddb366ca16ded34b11d8c9ffc68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c7218a4b3feea511862264078294f9" id="r_ab5c7218a4b3feea511862264078294f9"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ab5c7218a4b3feea511862264078294f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab5c7218a4b3feea511862264078294f9">operator/</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:ab5c7218a4b3feea511862264078294f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d36583ca6c26c073b51f79c97df27cd" id="r_a1d36583ca6c26c073b51f79c97df27cd"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a1d36583ca6c26c073b51f79c97df27cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d36583ca6c26c073b51f79c97df27cd">operator/</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a1d36583ca6c26c073b51f79c97df27cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774ebaa0c8da50338c8fb89c745b63e1" id="r_a774ebaa0c8da50338c8fb89c745b63e1"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdType U&gt; </td></tr>
<tr class="memitem:a774ebaa0c8da50338c8fb89c745b63e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a774ebaa0c8da50338c8fb89c745b63e1">operator/</a> (const T lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="separator:a774ebaa0c8da50338c8fb89c745b63e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53260d61952353ca33ae8d09f7be8e2" id="r_ab53260d61952353ca33ae8d09f7be8e2"><td class="memTemplParams" colspan="2">template&lt;SimdType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:ab53260d61952353ca33ae8d09f7be8e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab53260d61952353ca33ae8d09f7be8e2">operator/</a> (const T &amp;lhs, const U rhs) noexcept</td></tr>
<tr class="separator:ab53260d61952353ca33ae8d09f7be8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac619a6c5d7a37ce346ac98a0e829cad5" id="r_ac619a6c5d7a37ce346ac98a0e829cad5"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:ac619a6c5d7a37ce346ac98a0e829cad5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac619a6c5d7a37ce346ac98a0e829cad5">First</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ac619a6c5d7a37ce346ac98a0e829cad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the lowest element of v.  <br /></td></tr>
<tr class="separator:ac619a6c5d7a37ce346ac98a0e829cad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae112399490f33978ac41fb28546acf33" id="r_ae112399490f33978ac41fb28546acf33"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:ae112399490f33978ac41fb28546acf33"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae112399490f33978ac41fb28546acf33">HSum</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:ae112399490f33978ac41fb28546acf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the horizontal sum of the elements in the vector.  <br /></td></tr>
<tr class="separator:ae112399490f33978ac41fb28546acf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4484fd1e7e6afea47401f08ba170db8d" id="r_a4484fd1e7e6afea47401f08ba170db8d"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a4484fd1e7e6afea47401f08ba170db8d"><td class="memTemplItemLeft" align="right" valign="top">T::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4484fd1e7e6afea47401f08ba170db8d">ScalarHSum</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a4484fd1e7e6afea47401f08ba170db8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the horizontal sum of the elements in the vector.  <br /></td></tr>
<tr class="separator:a4484fd1e7e6afea47401f08ba170db8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7a2bedd77f82781d27279c2effe863" id="r_a2c7a2bedd77f82781d27279c2effe863"><td class="memTemplParams" colspan="2">template&lt;TupleType T&gt; </td></tr>
<tr class="memitem:a2c7a2bedd77f82781d27279c2effe863"><td class="memTemplItemLeft" align="right" valign="top">T::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c7a2bedd77f82781d27279c2effe863">HSum</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a2c7a2bedd77f82781d27279c2effe863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the horizontal sum of the elements in the vector.  <br /></td></tr>
<tr class="separator:a2c7a2bedd77f82781d27279c2effe863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c2a68b9ea84fd4f019ac54f5a59b4b" id="r_a92c2a68b9ea84fd4f019ac54f5a59b4b"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a92c2a68b9ea84fd4f019ac54f5a59b4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92c2a68b9ea84fd4f019ac54f5a59b4b">Avg</a> (const T &amp;t) noexcept</td></tr>
<tr class="separator:a92c2a68b9ea84fd4f019ac54f5a59b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ff1e24f0318f885a4f0f824059b647" id="r_a98ff1e24f0318f885a4f0f824059b647"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a98ff1e24f0318f885a4f0f824059b647"><td class="memTemplItemLeft" align="right" valign="top">T::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a98ff1e24f0318f885a4f0f824059b647">ScalarAvg</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a98ff1e24f0318f885a4f0f824059b647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the average value of the elements in the argument.  <br /></td></tr>
<tr class="separator:a98ff1e24f0318f885a4f0f824059b647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732e86eee7896beaa59b9ea998db4d11" id="r_a732e86eee7896beaa59b9ea998db4d11"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a732e86eee7896beaa59b9ea998db4d11"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a732e86eee7896beaa59b9ea998db4d11">HProd</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a732e86eee7896beaa59b9ea998db4d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the horizontal product of the elements in the vector.  <br /></td></tr>
<tr class="separator:a732e86eee7896beaa59b9ea998db4d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb28e7719c078f85e0ae98290c01570" id="r_aeeb28e7719c078f85e0ae98290c01570"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:aeeb28e7719c078f85e0ae98290c01570"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeeb28e7719c078f85e0ae98290c01570">ScalarHProd</a> (const T &amp;t) noexcept</td></tr>
<tr class="separator:aeeb28e7719c078f85e0ae98290c01570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08699ba23118f73ba7ad0ae6039806d5" id="r_a08699ba23118f73ba7ad0ae6039806d5"><td class="memTemplParams" colspan="2">template&lt;TupleType T, typename ResultT  = typename T::value_type&gt; </td></tr>
<tr class="memitem:a08699ba23118f73ba7ad0ae6039806d5"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08699ba23118f73ba7ad0ae6039806d5">ScalarHProd</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a08699ba23118f73ba7ad0ae6039806d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the horizontal product of the elements in the vector.  <br /></td></tr>
<tr class="separator:a08699ba23118f73ba7ad0ae6039806d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6df72fca7fa5ed2aaa74caebb48c78" id="r_a8c6df72fca7fa5ed2aaa74caebb48c78"><td class="memTemplParams" colspan="2">template&lt;TupleType T&gt; </td></tr>
<tr class="memitem:a8c6df72fca7fa5ed2aaa74caebb48c78"><td class="memTemplItemLeft" align="right" valign="top">T::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c6df72fca7fa5ed2aaa74caebb48c78">HProd</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a8c6df72fca7fa5ed2aaa74caebb48c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the horizontal product of the elements in the vector.  <br /></td></tr>
<tr class="separator:a8c6df72fca7fa5ed2aaa74caebb48c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fade8696a5d96d8c669535131dad2c" id="r_aa0fade8696a5d96d8c669535131dad2c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:aa0fade8696a5d96d8c669535131dad2c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa0fade8696a5d96d8c669535131dad2c">AllTrue</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:aa0fade8696a5d96d8c669535131dad2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all the elements of the argument have all their bits set to 1.  <br /></td></tr>
<tr class="separator:aa0fade8696a5d96d8c669535131dad2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c998fd6e7f2cd4624c3d8edbe538f03" id="r_a2c998fd6e7f2cd4624c3d8edbe538f03"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a2c998fd6e7f2cd4624c3d8edbe538f03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c998fd6e7f2cd4624c3d8edbe538f03">AnyTrue</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a2c998fd6e7f2cd4624c3d8edbe538f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any of the elements of the argument have all their bits set to 1.  <br /></td></tr>
<tr class="separator:a2c998fd6e7f2cd4624c3d8edbe538f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45b92fd9dab20f18f6620b09983d80c" id="r_ac45b92fd9dab20f18f6620b09983d80c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ac45b92fd9dab20f18f6620b09983d80c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac45b92fd9dab20f18f6620b09983d80c">Less</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:ac45b92fd9dab20f18f6620b09983d80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are less than the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:ac45b92fd9dab20f18f6620b09983d80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564420353fd0ec267254b3406df31618" id="r_a564420353fd0ec267254b3406df31618"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a564420353fd0ec267254b3406df31618"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a564420353fd0ec267254b3406df31618">Less</a> (const T &amp;v1, U value) noexcept</td></tr>
<tr class="memdesc:a564420353fd0ec267254b3406df31618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are less than value.  <br /></td></tr>
<tr class="separator:a564420353fd0ec267254b3406df31618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe7a458441b6c1d60682968d0eb91d6" id="r_aebe7a458441b6c1d60682968d0eb91d6"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:aebe7a458441b6c1d60682968d0eb91d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aebe7a458441b6c1d60682968d0eb91d6">Less</a> (T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:aebe7a458441b6c1d60682968d0eb91d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is less than the elements of v2.  <br /></td></tr>
<tr class="separator:aebe7a458441b6c1d60682968d0eb91d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bd81dab996c9d8901bd81f80010561" id="r_a04bd81dab996c9d8901bd81f80010561"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a04bd81dab996c9d8901bd81f80010561"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04bd81dab996c9d8901bd81f80010561">AllLess</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a04bd81dab996c9d8901bd81f80010561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are less than the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:a04bd81dab996c9d8901bd81f80010561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b04e06b7ab1a58928eca11e05b8ff7" id="r_af6b04e06b7ab1a58928eca11e05b8ff7"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:af6b04e06b7ab1a58928eca11e05b8ff7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6b04e06b7ab1a58928eca11e05b8ff7">AllLess</a> (const T &amp;v1, U value) noexcept</td></tr>
<tr class="memdesc:af6b04e06b7ab1a58928eca11e05b8ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are less than value.  <br /></td></tr>
<tr class="separator:af6b04e06b7ab1a58928eca11e05b8ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3f44e66ffcb54085048be0eab37950" id="r_afe3f44e66ffcb54085048be0eab37950"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:afe3f44e66ffcb54085048be0eab37950"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe3f44e66ffcb54085048be0eab37950">AllLess</a> (T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:afe3f44e66ffcb54085048be0eab37950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is less than all of the elements of v2.  <br /></td></tr>
<tr class="separator:afe3f44e66ffcb54085048be0eab37950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44635a8ac9f6e7e58ab0bfb1d3bc11b0" id="r_a44635a8ac9f6e7e58ab0bfb1d3bc11b0"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a44635a8ac9f6e7e58ab0bfb1d3bc11b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a44635a8ac9f6e7e58ab0bfb1d3bc11b0">AnyLess</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a44635a8ac9f6e7e58ab0bfb1d3bc11b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are less than the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:a44635a8ac9f6e7e58ab0bfb1d3bc11b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e44008b9eee7bf058bf46270f40d38e" id="r_a9e44008b9eee7bf058bf46270f40d38e"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a9e44008b9eee7bf058bf46270f40d38e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e44008b9eee7bf058bf46270f40d38e">AnyLess</a> (const T &amp;v1, U value) noexcept</td></tr>
<tr class="memdesc:a9e44008b9eee7bf058bf46270f40d38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are less than value.  <br /></td></tr>
<tr class="separator:a9e44008b9eee7bf058bf46270f40d38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efb0d2f56ca8322029b509c43d2f601" id="r_a5efb0d2f56ca8322029b509c43d2f601"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a5efb0d2f56ca8322029b509c43d2f601"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5efb0d2f56ca8322029b509c43d2f601">AnyLess</a> (T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a5efb0d2f56ca8322029b509c43d2f601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is less than any of the elements of v2.  <br /></td></tr>
<tr class="separator:a5efb0d2f56ca8322029b509c43d2f601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb48c39d98d6162f742e2d9d764999f8" id="r_aeb48c39d98d6162f742e2d9d764999f8"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:aeb48c39d98d6162f742e2d9d764999f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb48c39d98d6162f742e2d9d764999f8">LessOrEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:aeb48c39d98d6162f742e2d9d764999f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are less than, or equal to, the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:aeb48c39d98d6162f742e2d9d764999f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277c424e0405a5207a8630f18cf33974" id="r_a277c424e0405a5207a8630f18cf33974"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a277c424e0405a5207a8630f18cf33974"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a277c424e0405a5207a8630f18cf33974">LessOrEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:a277c424e0405a5207a8630f18cf33974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are less than, or equal to, value.  <br /></td></tr>
<tr class="separator:a277c424e0405a5207a8630f18cf33974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7e09b58f180ada023c449fdba460e8" id="r_a3f7e09b58f180ada023c449fdba460e8"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a3f7e09b58f180ada023c449fdba460e8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f7e09b58f180ada023c449fdba460e8">LessOrEqual</a> (const T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a3f7e09b58f180ada023c449fdba460e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is less than, or equal to, the elements of v2.  <br /></td></tr>
<tr class="separator:a3f7e09b58f180ada023c449fdba460e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544ae08d9e96e999144d7c5276ff2698" id="r_a544ae08d9e96e999144d7c5276ff2698"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a544ae08d9e96e999144d7c5276ff2698"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a544ae08d9e96e999144d7c5276ff2698">AllLessOrEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a544ae08d9e96e999144d7c5276ff2698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are less than, or equal to, the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:a544ae08d9e96e999144d7c5276ff2698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610535c9789c83a740cf1e0324ad5c83" id="r_a610535c9789c83a740cf1e0324ad5c83"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a610535c9789c83a740cf1e0324ad5c83"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a610535c9789c83a740cf1e0324ad5c83">AllLessOrEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:a610535c9789c83a740cf1e0324ad5c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are less than, or equal to, value.  <br /></td></tr>
<tr class="separator:a610535c9789c83a740cf1e0324ad5c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726cc41d495bfb12b081ff74fa741506" id="r_a726cc41d495bfb12b081ff74fa741506"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a726cc41d495bfb12b081ff74fa741506"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a726cc41d495bfb12b081ff74fa741506">AllLessOrEqual</a> (const T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a726cc41d495bfb12b081ff74fa741506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is less than, or equal to, all of the elements of v2.  <br /></td></tr>
<tr class="separator:a726cc41d495bfb12b081ff74fa741506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21bf882a0c01dd485d34626f2107481" id="r_ac21bf882a0c01dd485d34626f2107481"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ac21bf882a0c01dd485d34626f2107481"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac21bf882a0c01dd485d34626f2107481">AnyLessOrEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:ac21bf882a0c01dd485d34626f2107481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are less than, or equal to, the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:ac21bf882a0c01dd485d34626f2107481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72808741a4b7b23afaf86d0c6d08c4ef" id="r_a72808741a4b7b23afaf86d0c6d08c4ef"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a72808741a4b7b23afaf86d0c6d08c4ef"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72808741a4b7b23afaf86d0c6d08c4ef">AnyLessOrEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:a72808741a4b7b23afaf86d0c6d08c4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are less than, or equal to, value.  <br /></td></tr>
<tr class="separator:a72808741a4b7b23afaf86d0c6d08c4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0887fc10b541d47ba0ab5380ed852375" id="r_a0887fc10b541d47ba0ab5380ed852375"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a0887fc10b541d47ba0ab5380ed852375"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0887fc10b541d47ba0ab5380ed852375">AnyLessOrEqual</a> (const T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a0887fc10b541d47ba0ab5380ed852375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is less than, or equal to, any of the elements of v2.  <br /></td></tr>
<tr class="separator:a0887fc10b541d47ba0ab5380ed852375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7ede4f997d25fa6322ee6ecaec82f3" id="r_a7b7ede4f997d25fa6322ee6ecaec82f3"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:a7b7ede4f997d25fa6322ee6ecaec82f3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b7ede4f997d25fa6322ee6ecaec82f3">Equal</a> (const S &amp;lhs, const T &amp;rhs, const U &amp;epsilon) noexcept</td></tr>
<tr class="memdesc:a7b7ede4f997d25fa6322ee6ecaec82f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of lhs and the corresponding elements of rhs are less or equally apart than the corresponding element of epsilon.  <br /></td></tr>
<tr class="separator:a7b7ede4f997d25fa6322ee6ecaec82f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3786da90ad366be782c78b985b6cb96c" id="r_a3786da90ad366be782c78b985b6cb96c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a3786da90ad366be782c78b985b6cb96c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3786da90ad366be782c78b985b6cb96c">Equal</a> (const S &amp;lhs, const T &amp;rhs, U epsilon) noexcept</td></tr>
<tr class="memdesc:a3786da90ad366be782c78b985b6cb96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of lhs and the corresponding elements of rhs are less or equally apart than the value of epsilon.  <br /></td></tr>
<tr class="separator:a3786da90ad366be782c78b985b6cb96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bea74c344ac67ec2ad68ef4dc31685" id="r_ab3bea74c344ac67ec2ad68ef4dc31685"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:ab3bea74c344ac67ec2ad68ef4dc31685"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab3bea74c344ac67ec2ad68ef4dc31685">AllEqual</a> (const S &amp;lhs, const T &amp;rhs, const U &amp;epsilon) noexcept</td></tr>
<tr class="memdesc:ab3bea74c344ac67ec2ad68ef4dc31685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of lhs and their corresponding element of rhs are less or equally apart than the corresponding element of epsilon.  <br /></td></tr>
<tr class="separator:ab3bea74c344ac67ec2ad68ef4dc31685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea55de9394df0e63c1bd778f94c399bf" id="r_aea55de9394df0e63c1bd778f94c399bf"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:aea55de9394df0e63c1bd778f94c399bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea55de9394df0e63c1bd778f94c399bf">AllEqual</a> (const S &amp;lhs, const T &amp;rhs, const U epsilon) noexcept</td></tr>
<tr class="memdesc:aea55de9394df0e63c1bd778f94c399bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of lhs and their corresponding element of rhs are less or equally apart than the value of epsilon.  <br /></td></tr>
<tr class="separator:aea55de9394df0e63c1bd778f94c399bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538b5121013a2626be4e22b722d26e81" id="r_a538b5121013a2626be4e22b722d26e81"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:a538b5121013a2626be4e22b722d26e81"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a538b5121013a2626be4e22b722d26e81">AnyEqual</a> (const S &amp;lhs, const T &amp;rhs, const U &amp;epsilon) noexcept</td></tr>
<tr class="memdesc:a538b5121013a2626be4e22b722d26e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of lhs and their corresponding element of rhs are less or equally apart than the corresponding element of epsilon.  <br /></td></tr>
<tr class="separator:a538b5121013a2626be4e22b722d26e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8307a2e5211ebde385cac17b7ee7082e" id="r_a8307a2e5211ebde385cac17b7ee7082e"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a8307a2e5211ebde385cac17b7ee7082e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8307a2e5211ebde385cac17b7ee7082e">AnyEqual</a> (const S &amp;lhs, const T &amp;rhs, U epsilon) noexcept</td></tr>
<tr class="memdesc:a8307a2e5211ebde385cac17b7ee7082e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of lhs and their corresponding element of rhs are less or equally apart than the value of epsilon.  <br /></td></tr>
<tr class="separator:a8307a2e5211ebde385cac17b7ee7082e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447102ec652e2402fbf88cf3d89649ab" id="r_a447102ec652e2402fbf88cf3d89649ab"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a447102ec652e2402fbf88cf3d89649ab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a447102ec652e2402fbf88cf3d89649ab">Equal</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a447102ec652e2402fbf88cf3d89649ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are equal to the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:a447102ec652e2402fbf88cf3d89649ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d983cae78dbec75ca17aeabe925632" id="r_a30d983cae78dbec75ca17aeabe925632"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a30d983cae78dbec75ca17aeabe925632"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a30d983cae78dbec75ca17aeabe925632">Equal</a> (const T &amp;v1, U value) noexcept</td></tr>
<tr class="memdesc:a30d983cae78dbec75ca17aeabe925632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are equal to value.  <br /></td></tr>
<tr class="separator:a30d983cae78dbec75ca17aeabe925632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5923e20f171808bd73077a9e97405f46" id="r_a5923e20f171808bd73077a9e97405f46"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a5923e20f171808bd73077a9e97405f46"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5923e20f171808bd73077a9e97405f46">Equal</a> (const T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a5923e20f171808bd73077a9e97405f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is equal to the elements of v2.  <br /></td></tr>
<tr class="separator:a5923e20f171808bd73077a9e97405f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d414802e1e8044328593cec83faea31" id="r_a6d414802e1e8044328593cec83faea31"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a6d414802e1e8044328593cec83faea31"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d414802e1e8044328593cec83faea31">AllEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a6d414802e1e8044328593cec83faea31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are equal to the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:a6d414802e1e8044328593cec83faea31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabb0101651196796783356658503dd0" id="r_aaabb0101651196796783356658503dd0"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:aaabb0101651196796783356658503dd0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaabb0101651196796783356658503dd0">AllEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:aaabb0101651196796783356658503dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are equal to value.  <br /></td></tr>
<tr class="separator:aaabb0101651196796783356658503dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2f5e38b089374607d675d1201ebaa8" id="r_aed2f5e38b089374607d675d1201ebaa8"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:aed2f5e38b089374607d675d1201ebaa8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed2f5e38b089374607d675d1201ebaa8">AllEqual</a> (T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:aed2f5e38b089374607d675d1201ebaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is equal to all the elements of v2.  <br /></td></tr>
<tr class="separator:aed2f5e38b089374607d675d1201ebaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2955961bbb0693a8fd10678a625cb1d" id="r_ad2955961bbb0693a8fd10678a625cb1d"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ad2955961bbb0693a8fd10678a625cb1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2955961bbb0693a8fd10678a625cb1d">AnyEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:ad2955961bbb0693a8fd10678a625cb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are equal to the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:ad2955961bbb0693a8fd10678a625cb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051ab117c341ed3303404066719d4339" id="r_a051ab117c341ed3303404066719d4339"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a051ab117c341ed3303404066719d4339"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a051ab117c341ed3303404066719d4339">AnyEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:a051ab117c341ed3303404066719d4339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are equal to value.  <br /></td></tr>
<tr class="separator:a051ab117c341ed3303404066719d4339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa49131bc680cb56347787af15bc427" id="r_a1fa49131bc680cb56347787af15bc427"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a1fa49131bc680cb56347787af15bc427"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1fa49131bc680cb56347787af15bc427">AnyEqual</a> (const T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a1fa49131bc680cb56347787af15bc427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is equal to any of the elements of v2.  <br /></td></tr>
<tr class="separator:a1fa49131bc680cb56347787af15bc427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb919ec73ee5827a6f491390c85c5f1" id="r_acbb919ec73ee5827a6f491390c85c5f1"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:acbb919ec73ee5827a6f491390c85c5f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acbb919ec73ee5827a6f491390c85c5f1">NotEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:acbb919ec73ee5827a6f491390c85c5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are not equal to the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:acbb919ec73ee5827a6f491390c85c5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefacbda0085e4ea966b45f03adebe957" id="r_aefacbda0085e4ea966b45f03adebe957"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:aefacbda0085e4ea966b45f03adebe957"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aefacbda0085e4ea966b45f03adebe957">NotEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:aefacbda0085e4ea966b45f03adebe957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are not equal to value.  <br /></td></tr>
<tr class="separator:aefacbda0085e4ea966b45f03adebe957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6853be37c269e5dee60e9d6ea322c93a" id="r_a6853be37c269e5dee60e9d6ea322c93a"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a6853be37c269e5dee60e9d6ea322c93a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6853be37c269e5dee60e9d6ea322c93a">NotEqual</a> (T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a6853be37c269e5dee60e9d6ea322c93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is not equal to the elements of v2.  <br /></td></tr>
<tr class="separator:a6853be37c269e5dee60e9d6ea322c93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197badea1790b788b573928ac545be42" id="r_a197badea1790b788b573928ac545be42"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a197badea1790b788b573928ac545be42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a197badea1790b788b573928ac545be42">AllNotEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a197badea1790b788b573928ac545be42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are not equal to the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:a197badea1790b788b573928ac545be42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0caf042dfd08740b89b0f833354a66c" id="r_ac0caf042dfd08740b89b0f833354a66c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:ac0caf042dfd08740b89b0f833354a66c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0caf042dfd08740b89b0f833354a66c">AllNotEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:ac0caf042dfd08740b89b0f833354a66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are not equal to value.  <br /></td></tr>
<tr class="separator:ac0caf042dfd08740b89b0f833354a66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042a81fe16cdd87a4ee35ff5a038d39c" id="r_a042a81fe16cdd87a4ee35ff5a038d39c"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a042a81fe16cdd87a4ee35ff5a038d39c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a042a81fe16cdd87a4ee35ff5a038d39c">AllNotEqual</a> (T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a042a81fe16cdd87a4ee35ff5a038d39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is not equal to all the elements of v2.  <br /></td></tr>
<tr class="separator:a042a81fe16cdd87a4ee35ff5a038d39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf31923a32f65e52e433db988f9a6268" id="r_acf31923a32f65e52e433db988f9a6268"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:acf31923a32f65e52e433db988f9a6268"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf31923a32f65e52e433db988f9a6268">AnyNotEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:acf31923a32f65e52e433db988f9a6268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are not equal to the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:acf31923a32f65e52e433db988f9a6268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c66c01e6eb66e82e56130c63dffc1e7" id="r_a7c66c01e6eb66e82e56130c63dffc1e7"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a7c66c01e6eb66e82e56130c63dffc1e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c66c01e6eb66e82e56130c63dffc1e7">AnyNotEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:a7c66c01e6eb66e82e56130c63dffc1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are not equal to value.  <br /></td></tr>
<tr class="separator:a7c66c01e6eb66e82e56130c63dffc1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7340089292f28ea8bbe1f8b044d3198a" id="r_a7340089292f28ea8bbe1f8b044d3198a"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a7340089292f28ea8bbe1f8b044d3198a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7340089292f28ea8bbe1f8b044d3198a">AnyNotEqual</a> (const T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a7340089292f28ea8bbe1f8b044d3198a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is not equal to any of the elements of v2.  <br /></td></tr>
<tr class="separator:a7340089292f28ea8bbe1f8b044d3198a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad231c68da490686a55e3c23d096afd25" id="r_ad231c68da490686a55e3c23d096afd25"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ad231c68da490686a55e3c23d096afd25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad231c68da490686a55e3c23d096afd25">GreaterOrEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:ad231c68da490686a55e3c23d096afd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are greater than, or equal to, the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:ad231c68da490686a55e3c23d096afd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e2b37cadb07e785ed9cb32720c937f" id="r_a64e2b37cadb07e785ed9cb32720c937f"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a64e2b37cadb07e785ed9cb32720c937f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a64e2b37cadb07e785ed9cb32720c937f">GreaterOrEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:a64e2b37cadb07e785ed9cb32720c937f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are greater than, or equal to, value.  <br /></td></tr>
<tr class="separator:a64e2b37cadb07e785ed9cb32720c937f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111ba8abb2736af5196dd201bdd82e1a" id="r_a111ba8abb2736af5196dd201bdd82e1a"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a111ba8abb2736af5196dd201bdd82e1a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a111ba8abb2736af5196dd201bdd82e1a">GreaterOrEqual</a> (const T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a111ba8abb2736af5196dd201bdd82e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is greater than, or equal to, the elements of v2.  <br /></td></tr>
<tr class="separator:a111ba8abb2736af5196dd201bdd82e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb226d267a4b487b4fecd707febd344" id="r_a6eb226d267a4b487b4fecd707febd344"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a6eb226d267a4b487b4fecd707febd344"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6eb226d267a4b487b4fecd707febd344">AllGreaterOrEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a6eb226d267a4b487b4fecd707febd344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are greater than, or equal to, the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:a6eb226d267a4b487b4fecd707febd344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9962b9e03565d763ca0d74559b6bc83b" id="r_a9962b9e03565d763ca0d74559b6bc83b"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a9962b9e03565d763ca0d74559b6bc83b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9962b9e03565d763ca0d74559b6bc83b">AllGreaterOrEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:a9962b9e03565d763ca0d74559b6bc83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are greater than, or equal to, value.  <br /></td></tr>
<tr class="separator:a9962b9e03565d763ca0d74559b6bc83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c17ac14da6636881e72d8d2c7890b3d" id="r_a8c17ac14da6636881e72d8d2c7890b3d"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a8c17ac14da6636881e72d8d2c7890b3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c17ac14da6636881e72d8d2c7890b3d">AllGreaterOrEqual</a> (const T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a8c17ac14da6636881e72d8d2c7890b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is greater than, or equal to, all of the elements of v2.  <br /></td></tr>
<tr class="separator:a8c17ac14da6636881e72d8d2c7890b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658d635179ea950b78eea98917640028" id="r_a658d635179ea950b78eea98917640028"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a658d635179ea950b78eea98917640028"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a658d635179ea950b78eea98917640028">AnyGreaterOrEqual</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a658d635179ea950b78eea98917640028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are greater than, or equal to, the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:a658d635179ea950b78eea98917640028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2214a402222e747802735a327eb054" id="r_ade2214a402222e747802735a327eb054"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:ade2214a402222e747802735a327eb054"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ade2214a402222e747802735a327eb054">AnyGreaterOrEqual</a> (const T &amp;v1, const U value) noexcept</td></tr>
<tr class="memdesc:ade2214a402222e747802735a327eb054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are greater than, or equal to, value.  <br /></td></tr>
<tr class="separator:ade2214a402222e747802735a327eb054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a1310fcca15ec5556e13537cfad726" id="r_a84a1310fcca15ec5556e13537cfad726"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a84a1310fcca15ec5556e13537cfad726"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a84a1310fcca15ec5556e13537cfad726">AnyGreaterOrEqual</a> (const T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a84a1310fcca15ec5556e13537cfad726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is greater than, or equal to, any of the elements of v2.  <br /></td></tr>
<tr class="separator:a84a1310fcca15ec5556e13537cfad726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad760fa17e2c26f6efacfb3ba4d5fdc91" id="r_ad760fa17e2c26f6efacfb3ba4d5fdc91"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ad760fa17e2c26f6efacfb3ba4d5fdc91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad760fa17e2c26f6efacfb3ba4d5fdc91">Greater</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:ad760fa17e2c26f6efacfb3ba4d5fdc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are greater than the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:ad760fa17e2c26f6efacfb3ba4d5fdc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c34e84328be30883c2b894854a4c035" id="r_a1c34e84328be30883c2b894854a4c035"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a1c34e84328be30883c2b894854a4c035"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1c34e84328be30883c2b894854a4c035">Greater</a> (const T &amp;v1, U value) noexcept</td></tr>
<tr class="memdesc:a1c34e84328be30883c2b894854a4c035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the elements of v1 are greater than value.  <br /></td></tr>
<tr class="separator:a1c34e84328be30883c2b894854a4c035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84e64e5c7ce56f14e9bfeb7843b2a7f" id="r_ad84e64e5c7ce56f14e9bfeb7843b2a7f"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:ad84e64e5c7ce56f14e9bfeb7843b2a7f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad84e64e5c7ce56f14e9bfeb7843b2a7f">Greater</a> (T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:ad84e64e5c7ce56f14e9bfeb7843b2a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is greater than the elements of v2.  <br /></td></tr>
<tr class="separator:ad84e64e5c7ce56f14e9bfeb7843b2a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e93f7e30ca213ecfbb897effab57496" id="r_a9e93f7e30ca213ecfbb897effab57496"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a9e93f7e30ca213ecfbb897effab57496"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e93f7e30ca213ecfbb897effab57496">AllGreater</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a9e93f7e30ca213ecfbb897effab57496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are greater than the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:a9e93f7e30ca213ecfbb897effab57496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e92fbbd80605ef3dc0e8f8fd1757720" id="r_a1e92fbbd80605ef3dc0e8f8fd1757720"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a1e92fbbd80605ef3dc0e8f8fd1757720"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e92fbbd80605ef3dc0e8f8fd1757720">AllGreater</a> (const T &amp;v1, U value) noexcept</td></tr>
<tr class="memdesc:a1e92fbbd80605ef3dc0e8f8fd1757720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether all the elements of v1 are greater than value.  <br /></td></tr>
<tr class="separator:a1e92fbbd80605ef3dc0e8f8fd1757720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b2a2d38f30adf32e641791040e6e2f" id="r_a91b2a2d38f30adf32e641791040e6e2f"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a91b2a2d38f30adf32e641791040e6e2f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a91b2a2d38f30adf32e641791040e6e2f">AllGreater</a> (T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a91b2a2d38f30adf32e641791040e6e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is greater than all of the elements of v2.  <br /></td></tr>
<tr class="separator:a91b2a2d38f30adf32e641791040e6e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5650716a27e2245f5fec40a1ebe6127" id="r_aa5650716a27e2245f5fec40a1ebe6127"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:aa5650716a27e2245f5fec40a1ebe6127"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5650716a27e2245f5fec40a1ebe6127">AnyGreater</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:aa5650716a27e2245f5fec40a1ebe6127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are greater than the corresponding elements of v2.  <br /></td></tr>
<tr class="separator:aa5650716a27e2245f5fec40a1ebe6127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a88831c343f6ea0d617e8cb002ca279" id="r_a5a88831c343f6ea0d617e8cb002ca279"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a5a88831c343f6ea0d617e8cb002ca279"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a88831c343f6ea0d617e8cb002ca279">AnyGreater</a> (const T &amp;v1, U value) noexcept</td></tr>
<tr class="memdesc:a5a88831c343f6ea0d617e8cb002ca279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any of the elements of v1 are greater than value.  <br /></td></tr>
<tr class="separator:a5a88831c343f6ea0d617e8cb002ca279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ce2fd86bde562781f66c7540f2935" id="r_a0f6ce2fd86bde562781f66c7540f2935"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a0f6ce2fd86bde562781f66c7540f2935"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f6ce2fd86bde562781f66c7540f2935">AnyGreater</a> (T value, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a0f6ce2fd86bde562781f66c7540f2935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether value is greater than any of the elements of v2.  <br /></td></tr>
<tr class="separator:a0f6ce2fd86bde562781f66c7540f2935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a8a0fb7499de63d548081dc4233918" id="r_aa9a8a0fb7499de63d548081dc4233918"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:aa9a8a0fb7499de63d548081dc4233918"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9a8a0fb7499de63d548081dc4233918">Select</a> (const S &amp;v1, const T &amp;v2, const U &amp;control) noexcept</td></tr>
<tr class="memdesc:aa9a8a0fb7499de63d548081dc4233918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a per-component selection between two input vectors and returns the resulting vector.  <br /></td></tr>
<tr class="separator:aa9a8a0fb7499de63d548081dc4233918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a8d79ae8bbdb3d6d4c1b99f06e84fa" id="r_ac8a8d79ae8bbdb3d6d4c1b99f06e84fa"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:ac8a8d79ae8bbdb3d6d4c1b99f06e84fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac8a8d79ae8bbdb3d6d4c1b99f06e84fa">IsNaN</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:ac8a8d79ae8bbdb3d6d4c1b99f06e84fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which of the elements of t are NaN.  <br /></td></tr>
<tr class="separator:ac8a8d79ae8bbdb3d6d4c1b99f06e84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3ff1abf25b2c73666dfa88c6b23124" id="r_a1f3ff1abf25b2c73666dfa88c6b23124"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a1f3ff1abf25b2c73666dfa88c6b23124"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f3ff1abf25b2c73666dfa88c6b23124">IsInf</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a1f3ff1abf25b2c73666dfa88c6b23124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which of the elements of t are Inf.  <br /></td></tr>
<tr class="separator:a1f3ff1abf25b2c73666dfa88c6b23124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7551b98354b140049ec9bef3343c63" id="r_a3c7551b98354b140049ec9bef3343c63"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a3c7551b98354b140049ec9bef3343c63"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c7551b98354b140049ec9bef3343c63">Abs</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a3c7551b98354b140049ec9bef3343c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of each element held by the argument.  <br /></td></tr>
<tr class="separator:a3c7551b98354b140049ec9bef3343c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2898a3e441771575e51af64629443aa2" id="r_a2898a3e441771575e51af64629443aa2"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a2898a3e441771575e51af64629443aa2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2898a3e441771575e51af64629443aa2">FastAbs</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a2898a3e441771575e51af64629443aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of each element held by the argument.  <br /></td></tr>
<tr class="separator:a2898a3e441771575e51af64629443aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cd21ee70823a7f54274949ab7c514c" id="r_a97cd21ee70823a7f54274949ab7c514c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a97cd21ee70823a7f54274949ab7c514c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97cd21ee70823a7f54274949ab7c514c">Min</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a97cd21ee70823a7f54274949ab7c514c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a comparison between the elements held by the two arguments, and returns a <a class="el" href="class_harlinn_1_1_math_1_1_tuple_simd.html">TupleSimd</a> derived object containing the smallest elements.  <br /></td></tr>
<tr class="separator:a97cd21ee70823a7f54274949ab7c514c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5f96ca6bd61ad7d54aed47dc274c7f" id="r_ace5f96ca6bd61ad7d54aed47dc274c7f"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ace5f96ca6bd61ad7d54aed47dc274c7f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace5f96ca6bd61ad7d54aed47dc274c7f">Max</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ace5f96ca6bd61ad7d54aed47dc274c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a comparison between the elements held by the two arguments, and returns a <a class="el" href="class_harlinn_1_1_math_1_1_tuple_simd.html">TupleSimd</a> containing the largest elements.  <br /></td></tr>
<tr class="separator:ace5f96ca6bd61ad7d54aed47dc274c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e536a3cb0839f61145068e8287c7c7" id="r_ae1e536a3cb0839f61145068e8287c7c7"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:ae1e536a3cb0839f61145068e8287c7c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae1e536a3cb0839f61145068e8287c7c7">Sqr</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:ae1e536a3cb0839f61145068e8287c7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square value of each element held by the argument.  <br /></td></tr>
<tr class="separator:ae1e536a3cb0839f61145068e8287c7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed75ab665c6260a589021fca37af79a1" id="r_aed75ab665c6260a589021fca37af79a1"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:aed75ab665c6260a589021fca37af79a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed75ab665c6260a589021fca37af79a1">Ceil</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:aed75ab665c6260a589021fca37af79a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ceiling of each element held by the argument.  <br /></td></tr>
<tr class="separator:aed75ab665c6260a589021fca37af79a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86191c95207f1ccf8ebeeec6d502b4ab" id="r_a86191c95207f1ccf8ebeeec6d502b4ab"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a86191c95207f1ccf8ebeeec6d502b4ab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86191c95207f1ccf8ebeeec6d502b4ab">Floor</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a86191c95207f1ccf8ebeeec6d502b4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floor of each element held by the argument.  <br /></td></tr>
<tr class="separator:a86191c95207f1ccf8ebeeec6d502b4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911600f1f74a037d060c0bbb4c790f20" id="r_a911600f1f74a037d060c0bbb4c790f20"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a911600f1f74a037d060c0bbb4c790f20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a911600f1f74a037d060c0bbb4c790f20">Round</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a911600f1f74a037d060c0bbb4c790f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds each element held by the argument towards the nearest even integer.  <br /></td></tr>
<tr class="separator:a911600f1f74a037d060c0bbb4c790f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803a32aac6d2a6ab3a6e2e29a32be563" id="r_a803a32aac6d2a6ab3a6e2e29a32be563"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a803a32aac6d2a6ab3a6e2e29a32be563"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a803a32aac6d2a6ab3a6e2e29a32be563">Trunc</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a803a32aac6d2a6ab3a6e2e29a32be563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds each element held by the argument to the nearest integer in the direction of zero.  <br /></td></tr>
<tr class="separator:a803a32aac6d2a6ab3a6e2e29a32be563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3a726e8e8a0f78639e3449d5d0a80b" id="r_a1f3a726e8e8a0f78639e3449d5d0a80b"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType U, ArithmeticType NumberT&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a1f3a726e8e8a0f78639e3449d5d0a80b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f3a726e8e8a0f78639e3449d5d0a80b">Lerp</a> (const T &amp;a, const U &amp;b, NumberT t) noexcept</td></tr>
<tr class="memdesc:a1f3a726e8e8a0f78639e3449d5d0a80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1).  <br /></td></tr>
<tr class="separator:a1f3a726e8e8a0f78639e3449d5d0a80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09eee9364af811e5092786e092894aa8" id="r_a09eee9364af811e5092786e092894aa8"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U, ArithmeticType NumberT&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a09eee9364af811e5092786e092894aa8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09eee9364af811e5092786e092894aa8">Lerp</a> (const T &amp;a, const U &amp;b, NumberT t) noexcept</td></tr>
<tr class="memdesc:a09eee9364af811e5092786e092894aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1).  <br /></td></tr>
<tr class="separator:a09eee9364af811e5092786e092894aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb8e4dcd30188f3c41547a86592804e" id="r_a7eb8e4dcd30188f3c41547a86592804e"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:a7eb8e4dcd30188f3c41547a86592804e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7eb8e4dcd30188f3c41547a86592804e">Lerp</a> (const S &amp;a, const T &amp;b, const U &amp;t) noexcept</td></tr>
<tr class="memdesc:a7eb8e4dcd30188f3c41547a86592804e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1).  <br /></td></tr>
<tr class="separator:a7eb8e4dcd30188f3c41547a86592804e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7710f85bb42fbace0dfdc824a693a278" id="r_a7710f85bb42fbace0dfdc824a693a278"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:a7710f85bb42fbace0dfdc824a693a278"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7710f85bb42fbace0dfdc824a693a278">Lerp</a> (const S &amp;a, const T &amp;b, const U &amp;t) noexcept</td></tr>
<tr class="memdesc:a7710f85bb42fbace0dfdc824a693a278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1).  <br /></td></tr>
<tr class="separator:a7710f85bb42fbace0dfdc824a693a278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1877c8a257d3484b8b084a14bf5e8838" id="r_a1877c8a257d3484b8b084a14bf5e8838"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType NumberT1, ArithmeticType NumberT2, SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a1877c8a257d3484b8b084a14bf5e8838"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1877c8a257d3484b8b084a14bf5e8838">Lerp</a> (const NumberT1 a, const NumberT2 b, const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a1877c8a257d3484b8b084a14bf5e8838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear interpolation between a and b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1).  <br /></td></tr>
<tr class="separator:a1877c8a257d3484b8b084a14bf5e8838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8c7533947f76c5aaae8300e5c534d7" id="r_a2b8c7533947f76c5aaae8300e5c534d7"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a2b8c7533947f76c5aaae8300e5c534d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b8c7533947f76c5aaae8300e5c534d7">Lerp2</a> (const S t, const T &amp;a, const U &amp;b) noexcept</td></tr>
<tr class="memdesc:a2b8c7533947f76c5aaae8300e5c534d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1).  <br /></td></tr>
<tr class="separator:a2b8c7533947f76c5aaae8300e5c534d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae10123fa318e9709049895127f3ba28" id="r_aae10123fa318e9709049895127f3ba28"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:aae10123fa318e9709049895127f3ba28"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aae10123fa318e9709049895127f3ba28">Lerp2</a> (const S t, const T &amp;a, const U &amp;b) noexcept</td></tr>
<tr class="memdesc:aae10123fa318e9709049895127f3ba28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1).  <br /></td></tr>
<tr class="separator:aae10123fa318e9709049895127f3ba28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf5114ff469a76bffa31b3a1b9d704f" id="r_addf5114ff469a76bffa31b3a1b9d704f"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:addf5114ff469a76bffa31b3a1b9d704f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#addf5114ff469a76bffa31b3a1b9d704f">Lerp2</a> (const S &amp;t, const T &amp;a, const U &amp;b) noexcept</td></tr>
<tr class="memdesc:addf5114ff469a76bffa31b3a1b9d704f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1).  <br /></td></tr>
<tr class="separator:addf5114ff469a76bffa31b3a1b9d704f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40f2c54ea569bcecca90950672a4022" id="r_af40f2c54ea569bcecca90950672a4022"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:af40f2c54ea569bcecca90950672a4022"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af40f2c54ea569bcecca90950672a4022">Lerp2</a> (const S &amp;t, const T &amp;a, const U &amp;b) noexcept</td></tr>
<tr class="memdesc:af40f2c54ea569bcecca90950672a4022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1).  <br /></td></tr>
<tr class="separator:af40f2c54ea569bcecca90950672a4022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc9adb55560176bbc914246f856b861" id="r_adfc9adb55560176bbc914246f856b861"><td class="memTemplParams" colspan="2">template&lt;SimdType S, ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:adfc9adb55560176bbc914246f856b861"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfc9adb55560176bbc914246f856b861">Lerp2</a> (const S &amp;t, const T a, const U b) noexcept</td></tr>
<tr class="memdesc:adfc9adb55560176bbc914246f856b861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the linear interpolation between a and b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1).  <br /></td></tr>
<tr class="separator:adfc9adb55560176bbc914246f856b861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e2868527464f65e7e09ce4743a8a42" id="r_a84e2868527464f65e7e09ce4743a8a42"><td class="memTemplParams" colspan="2">template&lt;int shuffleMask, SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a84e2868527464f65e7e09ce4743a8a42"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a84e2868527464f65e7e09ce4743a8a42">Permute</a> (const T &amp;t) noexcept</td></tr>
<tr class="separator:a84e2868527464f65e7e09ce4743a8a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744cd55624b73cfdfca9a0107a3ba95b" id="r_a744cd55624b73cfdfca9a0107a3ba95b"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:a744cd55624b73cfdfca9a0107a3ba95b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a744cd55624b73cfdfca9a0107a3ba95b">Clamp</a> (const S &amp;v, const T &amp;lowerBounds, const U &amp;upperBounds) noexcept</td></tr>
<tr class="memdesc:a744cd55624b73cfdfca9a0107a3ba95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of v, if the elements are between their respective boundaries specified by the elements of lowerBounds and the elements of upperBounds, otherwise the value of nearest boundary is returned.  <br /></td></tr>
<tr class="separator:a744cd55624b73cfdfca9a0107a3ba95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b5d4a61210bdf704feb47417bf92ca" id="r_a39b5d4a61210bdf704feb47417bf92ca"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:a39b5d4a61210bdf704feb47417bf92ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39b5d4a61210bdf704feb47417bf92ca">Clamp</a> (const S &amp;v, const T &amp;lowerBounds, const U &amp;upperBounds) noexcept</td></tr>
<tr class="memdesc:a39b5d4a61210bdf704feb47417bf92ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of v, if the elements are between their respective boundaries specified by the elements of lowerBounds and the elements of upperBounds, otherwise the value of nearest boundary is returned.  <br /></td></tr>
<tr class="separator:a39b5d4a61210bdf704feb47417bf92ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59669181cb9c3d42467d62701ea7a027" id="r_a59669181cb9c3d42467d62701ea7a027"><td class="memTemplParams" colspan="2">template&lt;SimdType S, ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a59669181cb9c3d42467d62701ea7a027"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59669181cb9c3d42467d62701ea7a027">Clamp</a> (const S &amp;v, const T lowerBounds, const U upperBounds) noexcept</td></tr>
<tr class="memdesc:a59669181cb9c3d42467d62701ea7a027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of v, if the elements are between their respective boundaries specified by lowerBounds and upperBounds, otherwise the value of nearest boundary is returned.  <br /></td></tr>
<tr class="separator:a59669181cb9c3d42467d62701ea7a027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f91cd56dd75160292bc6ebd97c49fc" id="r_aa7f91cd56dd75160292bc6ebd97c49fc"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:aa7f91cd56dd75160292bc6ebd97c49fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa7f91cd56dd75160292bc6ebd97c49fc">Clamp</a> (const S v, const T &amp;lowerBounds, const U &amp;upperBounds) noexcept</td></tr>
<tr class="memdesc:aa7f91cd56dd75160292bc6ebd97c49fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of v, if the elements are between their respective boundaries specified by the elements of lowerBounds and the elements of upperBounds, otherwise the value of nearest boundary is returned.  <br /></td></tr>
<tr class="separator:aa7f91cd56dd75160292bc6ebd97c49fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1bab3fb40e39e52c0505619bbe50a2" id="r_a6c1bab3fb40e39e52c0505619bbe50a2"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S&gt; </td></tr>
<tr class="memitem:a6c1bab3fb40e39e52c0505619bbe50a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c1bab3fb40e39e52c0505619bbe50a2">ClampZero</a> (const S &amp;v) noexcept</td></tr>
<tr class="separator:a6c1bab3fb40e39e52c0505619bbe50a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f7d059971c867d05c14bc274bc1143" id="r_a97f7d059971c867d05c14bc274bc1143"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a97f7d059971c867d05c14bc274bc1143"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97f7d059971c867d05c14bc274bc1143">InBounds</a> (const S &amp;v, const T &amp;bounds) noexcept</td></tr>
<tr class="memdesc:a97f7d059971c867d05c14bc274bc1143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects if the elements of a vector are within bounds.  <br /></td></tr>
<tr class="separator:a97f7d059971c867d05c14bc274bc1143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79dd2863aeb176c1b2bda7d8336de98" id="r_ae79dd2863aeb176c1b2bda7d8336de98"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:ae79dd2863aeb176c1b2bda7d8336de98"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae79dd2863aeb176c1b2bda7d8336de98">ClampLength</a> (const S &amp;v, const T &amp;lengthMin, const U &amp;lengthMax) noexcept</td></tr>
<tr class="memdesc:ae79dd2863aeb176c1b2bda7d8336de98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the length of a vector to a given range.  <br /></td></tr>
<tr class="separator:ae79dd2863aeb176c1b2bda7d8336de98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293d0e5b9d9e3e4faf4a2df5408fd359" id="r_a293d0e5b9d9e3e4faf4a2df5408fd359"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a293d0e5b9d9e3e4faf4a2df5408fd359"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a293d0e5b9d9e3e4faf4a2df5408fd359">ClampLength</a> (const S &amp;v, const T lengthMin, const U lengthMax) noexcept</td></tr>
<tr class="memdesc:a293d0e5b9d9e3e4faf4a2df5408fd359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps the length of a vector to a given range.  <br /></td></tr>
<tr class="separator:a293d0e5b9d9e3e4faf4a2df5408fd359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58046c6eca712fe150048fbecd5be33a" id="r_a58046c6eca712fe150048fbecd5be33a"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a58046c6eca712fe150048fbecd5be33a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58046c6eca712fe150048fbecd5be33a">Reflect</a> (const S &amp;incident, const T &amp;normal) noexcept</td></tr>
<tr class="memdesc:a58046c6eca712fe150048fbecd5be33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflects an incident vector across a normal vector.  <br /></td></tr>
<tr class="separator:a58046c6eca712fe150048fbecd5be33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f796b6818233e750bca755da590405" id="r_a83f796b6818233e750bca755da590405"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:a83f796b6818233e750bca755da590405"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a83f796b6818233e750bca755da590405">Refract</a> (const S &amp;incident, const T &amp;normal, const U &amp;refractionIndex) noexcept</td></tr>
<tr class="memdesc:a83f796b6818233e750bca755da590405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refracts an incident vector across a normal vector.  <br /></td></tr>
<tr class="separator:a83f796b6818233e750bca755da590405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409a32cb5df447b5bc7bcc9747f2e798" id="r_a409a32cb5df447b5bc7bcc9747f2e798"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a409a32cb5df447b5bc7bcc9747f2e798"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a409a32cb5df447b5bc7bcc9747f2e798">Refract</a> (const S &amp;incident, const T &amp;normal, const U refractionIndex) noexcept</td></tr>
<tr class="memdesc:a409a32cb5df447b5bc7bcc9747f2e798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refracts an incident vector across a normal vector.  <br /></td></tr>
<tr class="separator:a409a32cb5df447b5bc7bcc9747f2e798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143be99ef80f59c7e7df93ce159ed93d" id="r_a143be99ef80f59c7e7df93ce159ed93d"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S&gt; </td></tr>
<tr class="memitem:a143be99ef80f59c7e7df93ce159ed93d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a143be99ef80f59c7e7df93ce159ed93d">Orthogonal</a> (const S &amp;v) noexcept</td></tr>
<tr class="memdesc:a143be99ef80f59c7e7df93ce159ed93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector perpendicular to the argument vector.  <br /></td></tr>
<tr class="separator:a143be99ef80f59c7e7df93ce159ed93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4899c3646b6723f75494a142dbf805" id="r_a3c4899c3646b6723f75494a142dbf805"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a3c4899c3646b6723f75494a142dbf805"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c4899c3646b6723f75494a142dbf805">Saturate</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a3c4899c3646b6723f75494a142dbf805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saturates the elements of v to the range 0.0 to 1.0.  <br /></td></tr>
<tr class="separator:a3c4899c3646b6723f75494a142dbf805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7666b593d30618e1a95398e789f3b1c" id="r_ab7666b593d30618e1a95398e789f3b1c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:ab7666b593d30618e1a95398e789f3b1c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7666b593d30618e1a95398e789f3b1c">Sqrt</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:ab7666b593d30618e1a95398e789f3b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the square root of each element in the argument.  <br /></td></tr>
<tr class="separator:ab7666b593d30618e1a95398e789f3b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30982f405e8678c91bdbde90e0d88bbb" id="r_a30982f405e8678c91bdbde90e0d88bbb"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a30982f405e8678c91bdbde90e0d88bbb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a30982f405e8678c91bdbde90e0d88bbb">Cbrt</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a30982f405e8678c91bdbde90e0d88bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cube root of each element in the argument.  <br /></td></tr>
<tr class="separator:a30982f405e8678c91bdbde90e0d88bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9489effee421440e6b4b0351e93dab1" id="r_ad9489effee421440e6b4b0351e93dab1"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:ad9489effee421440e6b4b0351e93dab1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9489effee421440e6b4b0351e93dab1">SafeSqrt</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:ad9489effee421440e6b4b0351e93dab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the square root of each element greater or equal to 0.f in the argument. For elements less than 0.f, the result is 0.f.  <br /></td></tr>
<tr class="separator:ad9489effee421440e6b4b0351e93dab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f5da606d0092af0b5e584235bf5a31" id="r_ac3f5da606d0092af0b5e584235bf5a31"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:ac3f5da606d0092af0b5e584235bf5a31"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3f5da606d0092af0b5e584235bf5a31">ReciprocalSqrt</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:ac3f5da606d0092af0b5e584235bf5a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the reciprocal square root of each element in the argument.  <br /></td></tr>
<tr class="separator:ac3f5da606d0092af0b5e584235bf5a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfbefd30b64589dce07bb4e5beab3ed" id="r_a3cfbefd30b64589dce07bb4e5beab3ed"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a3cfbefd30b64589dce07bb4e5beab3ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3cfbefd30b64589dce07bb4e5beab3ed">Reciprocal</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a3cfbefd30b64589dce07bb4e5beab3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the reciprocal of each element in the argument.  <br /></td></tr>
<tr class="separator:a3cfbefd30b64589dce07bb4e5beab3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26ed47759c5354a0aee09bfb813a4bf" id="r_ab26ed47759c5354a0aee09bfb813a4bf"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:ab26ed47759c5354a0aee09bfb813a4bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab26ed47759c5354a0aee09bfb813a4bf">FMA</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:ab26ed47759c5354a0aee09bfb813a4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:ab26ed47759c5354a0aee09bfb813a4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281d41749c37640b9c308f5f935516f5" id="r_a281d41749c37640b9c308f5f935516f5"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:a281d41749c37640b9c308f5f935516f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a281d41749c37640b9c308f5f935516f5">FMA</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a281d41749c37640b9c308f5f935516f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a281d41749c37640b9c308f5f935516f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9094cfad7ecce58dd645c2cb26474021" id="r_a9094cfad7ecce58dd645c2cb26474021"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a9094cfad7ecce58dd645c2cb26474021"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9094cfad7ecce58dd645c2cb26474021">FMA</a> (const S &amp;a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:a9094cfad7ecce58dd645c2cb26474021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a9094cfad7ecce58dd645c2cb26474021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8af2ff67edaadc52bd7f74e654c777e" id="r_ab8af2ff67edaadc52bd7f74e654c777e"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</td></tr>
<tr class="memitem:ab8af2ff67edaadc52bd7f74e654c777e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8af2ff67edaadc52bd7f74e654c777e">FMA</a> (const S &amp;a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:ab8af2ff67edaadc52bd7f74e654c777e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:ab8af2ff67edaadc52bd7f74e654c777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4e3ad7a02f640e47366b6853cacf37" id="r_a6d4e3ad7a02f640e47366b6853cacf37"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a6d4e3ad7a02f640e47366b6853cacf37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d4e3ad7a02f640e47366b6853cacf37">FMA</a> (const S &amp;a, const T b, const U c) noexcept</td></tr>
<tr class="memdesc:a6d4e3ad7a02f640e47366b6853cacf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a6d4e3ad7a02f640e47366b6853cacf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc83459380542f5d0a206d5242845ef5" id="r_adc83459380542f5d0a206d5242845ef5"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:adc83459380542f5d0a206d5242845ef5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc83459380542f5d0a206d5242845ef5">FMA</a> (const S a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:adc83459380542f5d0a206d5242845ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:adc83459380542f5d0a206d5242845ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c89319ecc8dc904aedd0c7b30ad56a8" id="r_a6c89319ecc8dc904aedd0c7b30ad56a8"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a6c89319ecc8dc904aedd0c7b30ad56a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c89319ecc8dc904aedd0c7b30ad56a8">FMA</a> (const S a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:a6c89319ecc8dc904aedd0c7b30ad56a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a6c89319ecc8dc904aedd0c7b30ad56a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3f0ef08e5b9af0476fb7ef9d395005" id="r_a2a3f0ef08e5b9af0476fb7ef9d395005"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a2a3f0ef08e5b9af0476fb7ef9d395005"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a3f0ef08e5b9af0476fb7ef9d395005">FMA</a> (const S a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a2a3f0ef08e5b9af0476fb7ef9d395005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a2a3f0ef08e5b9af0476fb7ef9d395005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2190472cc7adb81414f6993d6b4e5bf7" id="r_a2190472cc7adb81414f6993d6b4e5bf7"><td class="memTemplParams" colspan="2">template&lt;SimdType T, typename C &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad60f420a7f44c2b0e9ce86950287dbad">IsArithmetic</a>&lt;C&gt;</td></tr>
<tr class="memitem:a2190472cc7adb81414f6993d6b4e5bf7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2190472cc7adb81414f6993d6b4e5bf7">EvaluatePolynomial</a> (const T &amp;t, C c)</td></tr>
<tr class="memdesc:a2190472cc7adb81414f6993d6b4e5bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the provided polynomial using Horners method.  <br /></td></tr>
<tr class="separator:a2190472cc7adb81414f6993d6b4e5bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e302fb6b84bde82518df179fd9d48a" id="r_a47e302fb6b84bde82518df179fd9d48a"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType C&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, C&gt;</td></tr>
<tr class="memitem:a47e302fb6b84bde82518df179fd9d48a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a47e302fb6b84bde82518df179fd9d48a">EvaluatePolynomial</a> (const T &amp;t, C c)</td></tr>
<tr class="separator:a47e302fb6b84bde82518df179fd9d48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d6211a8d07a03ef52fd3097ec3c4c2" id="r_aa4d6211a8d07a03ef52fd3097ec3c4c2"><td class="memTemplParams" colspan="2">template&lt;SimdType T, typename C , typename... Args&gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad60f420a7f44c2b0e9ce86950287dbad">IsArithmetic</a>&lt;C&gt;</td></tr>
<tr class="memitem:aa4d6211a8d07a03ef52fd3097ec3c4c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4d6211a8d07a03ef52fd3097ec3c4c2">EvaluatePolynomial</a> (const T &amp;t, C c, Args... remaining)</td></tr>
<tr class="separator:aa4d6211a8d07a03ef52fd3097ec3c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5851f79483b25f96c650e89760f0cc0" id="r_aa5851f79483b25f96c650e89760f0cc0"><td class="memTemplParams" colspan="2">template&lt;TupleType T, typename C , typename... Args&gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad60f420a7f44c2b0e9ce86950287dbad">IsArithmetic</a>&lt;C&gt;</td></tr>
<tr class="memitem:aa5851f79483b25f96c650e89760f0cc0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa5851f79483b25f96c650e89760f0cc0">EvaluatePolynomial</a> (const T &amp;t, C c, Args... remaining)</td></tr>
<tr class="separator:aa5851f79483b25f96c650e89760f0cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1d8d127f16b3f44186a7e950c432d" id="r_ac0e1d8d127f16b3f44186a7e950c432d"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType C, typename... Args&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, C&gt;</td></tr>
<tr class="memitem:ac0e1d8d127f16b3f44186a7e950c432d"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0e1d8d127f16b3f44186a7e950c432d">EvaluatePolynomial</a> (const T &amp;t, const C &amp;c, Args... remaining)</td></tr>
<tr class="separator:ac0e1d8d127f16b3f44186a7e950c432d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98e2fca6354ae2a10ba9207edad767c" id="r_ad98e2fca6354ae2a10ba9207edad767c"><td class="memTemplParams" colspan="2">template&lt;TupleType T, SimdType C, typename... Args&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, C&gt;</td></tr>
<tr class="memitem:ad98e2fca6354ae2a10ba9207edad767c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad98e2fca6354ae2a10ba9207edad767c">EvaluatePolynomial</a> (const T &amp;t, const C &amp;c, Args... remaining)</td></tr>
<tr class="separator:ad98e2fca6354ae2a10ba9207edad767c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a5225e1c7e4e18d30e8d569687fa2a" id="r_a64a5225e1c7e4e18d30e8d569687fa2a"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:a64a5225e1c7e4e18d30e8d569687fa2a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a64a5225e1c7e4e18d30e8d569687fa2a">FMSub</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a64a5225e1c7e4e18d30e8d569687fa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a64a5225e1c7e4e18d30e8d569687fa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e51e7b4b00012bbdfc03b703bc5ef8" id="r_a53e51e7b4b00012bbdfc03b703bc5ef8"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a53e51e7b4b00012bbdfc03b703bc5ef8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53e51e7b4b00012bbdfc03b703bc5ef8">FMSub</a> (const S &amp;a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:a53e51e7b4b00012bbdfc03b703bc5ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a53e51e7b4b00012bbdfc03b703bc5ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09831378edaed0491c1eaa0d82323fb" id="r_ae09831378edaed0491c1eaa0d82323fb"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</td></tr>
<tr class="memitem:ae09831378edaed0491c1eaa0d82323fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae09831378edaed0491c1eaa0d82323fb">FMSub</a> (const S &amp;a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:ae09831378edaed0491c1eaa0d82323fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:ae09831378edaed0491c1eaa0d82323fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f69e770f8935264a48c73648b0b3ac" id="r_a51f69e770f8935264a48c73648b0b3ac"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a51f69e770f8935264a48c73648b0b3ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a51f69e770f8935264a48c73648b0b3ac">FMSub</a> (const S &amp;a, const T b, const U c) noexcept</td></tr>
<tr class="memdesc:a51f69e770f8935264a48c73648b0b3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a51f69e770f8935264a48c73648b0b3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6b350c0fb47917b2e777c1911b0e66" id="r_a4b6b350c0fb47917b2e777c1911b0e66"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a4b6b350c0fb47917b2e777c1911b0e66"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b6b350c0fb47917b2e777c1911b0e66">FMSub</a> (const S a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a4b6b350c0fb47917b2e777c1911b0e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a4b6b350c0fb47917b2e777c1911b0e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4d2bbd455b44aebae1cb159013bb94" id="r_a8d4d2bbd455b44aebae1cb159013bb94"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a8d4d2bbd455b44aebae1cb159013bb94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d4d2bbd455b44aebae1cb159013bb94">FMSub</a> (const S a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:a8d4d2bbd455b44aebae1cb159013bb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a8d4d2bbd455b44aebae1cb159013bb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f448711076178ad0de3e3f917f7031" id="r_a87f448711076178ad0de3e3f917f7031"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a87f448711076178ad0de3e3f917f7031"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a87f448711076178ad0de3e3f917f7031">FMSub</a> (const S a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a87f448711076178ad0de3e3f917f7031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a87f448711076178ad0de3e3f917f7031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb45e8eaca792baeb4592644b9952ec" id="r_adbb45e8eaca792baeb4592644b9952ec"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:adbb45e8eaca792baeb4592644b9952ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbb45e8eaca792baeb4592644b9952ec">FMAddSub</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:adbb45e8eaca792baeb4592644b9952ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:adbb45e8eaca792baeb4592644b9952ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e5d5c5c0184c75d21feebab451eed3" id="r_aa3e5d5c5c0184c75d21feebab451eed3"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:aa3e5d5c5c0184c75d21feebab451eed3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa3e5d5c5c0184c75d21feebab451eed3">FMAddSub</a> (const S &amp;a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:aa3e5d5c5c0184c75d21feebab451eed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:aa3e5d5c5c0184c75d21feebab451eed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9e089112451c9b388d530770f61e6d" id="r_a2c9e089112451c9b388d530770f61e6d"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</td></tr>
<tr class="memitem:a2c9e089112451c9b388d530770f61e6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c9e089112451c9b388d530770f61e6d">FMAddSub</a> (const S &amp;a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a2c9e089112451c9b388d530770f61e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a2c9e089112451c9b388d530770f61e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ade8f9985f5536c2efc21a9a03921f" id="r_a15ade8f9985f5536c2efc21a9a03921f"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a15ade8f9985f5536c2efc21a9a03921f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15ade8f9985f5536c2efc21a9a03921f">FMAddSub</a> (const S &amp;a, const T b, const U c) noexcept</td></tr>
<tr class="memdesc:a15ade8f9985f5536c2efc21a9a03921f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a15ade8f9985f5536c2efc21a9a03921f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627eae104458501581a7a87856db3402" id="r_a627eae104458501581a7a87856db3402"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a627eae104458501581a7a87856db3402"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a627eae104458501581a7a87856db3402">FMAddSub</a> (const S a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a627eae104458501581a7a87856db3402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a627eae104458501581a7a87856db3402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184f4ddfe3f3c6e73a8038e111009d9d" id="r_a184f4ddfe3f3c6e73a8038e111009d9d"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a184f4ddfe3f3c6e73a8038e111009d9d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a184f4ddfe3f3c6e73a8038e111009d9d">FMAddSub</a> (const S a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:a184f4ddfe3f3c6e73a8038e111009d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a184f4ddfe3f3c6e73a8038e111009d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6edb3132771ea8d34312cd55bd1a2e" id="r_a7e6edb3132771ea8d34312cd55bd1a2e"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a7e6edb3132771ea8d34312cd55bd1a2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7e6edb3132771ea8d34312cd55bd1a2e">FMAddSub</a> (const S a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a7e6edb3132771ea8d34312cd55bd1a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a7e6edb3132771ea8d34312cd55bd1a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab822d2ce6b9c686ec76750d89393abcb" id="r_ab822d2ce6b9c686ec76750d89393abcb"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:ab822d2ce6b9c686ec76750d89393abcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab822d2ce6b9c686ec76750d89393abcb">FMSubAdd</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:ab822d2ce6b9c686ec76750d89393abcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:ab822d2ce6b9c686ec76750d89393abcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef65845d14791025b4830c1c1883d0f2" id="r_aef65845d14791025b4830c1c1883d0f2"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:aef65845d14791025b4830c1c1883d0f2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef65845d14791025b4830c1c1883d0f2">FMSubAdd</a> (const S &amp;a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:aef65845d14791025b4830c1c1883d0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:aef65845d14791025b4830c1c1883d0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2be679018b3ff35ca04fcb45c32d1f9" id="r_aa2be679018b3ff35ca04fcb45c32d1f9"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</td></tr>
<tr class="memitem:aa2be679018b3ff35ca04fcb45c32d1f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2be679018b3ff35ca04fcb45c32d1f9">FMSubAdd</a> (const S &amp;a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:aa2be679018b3ff35ca04fcb45c32d1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:aa2be679018b3ff35ca04fcb45c32d1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822f6c58d7b89eb84b17e3efa9350ab9" id="r_a822f6c58d7b89eb84b17e3efa9350ab9"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a822f6c58d7b89eb84b17e3efa9350ab9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a822f6c58d7b89eb84b17e3efa9350ab9">FMSubAdd</a> (const S &amp;a, const T b, const U c) noexcept</td></tr>
<tr class="memdesc:a822f6c58d7b89eb84b17e3efa9350ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a822f6c58d7b89eb84b17e3efa9350ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf32d3342e3592b61143817d17fa01e0" id="r_aaf32d3342e3592b61143817d17fa01e0"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:aaf32d3342e3592b61143817d17fa01e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf32d3342e3592b61143817d17fa01e0">FMSubAdd</a> (const S a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:aaf32d3342e3592b61143817d17fa01e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:aaf32d3342e3592b61143817d17fa01e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07bb80fd7c1af62cb74ff72b7731bc2" id="r_ac07bb80fd7c1af62cb74ff72b7731bc2"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:ac07bb80fd7c1af62cb74ff72b7731bc2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac07bb80fd7c1af62cb74ff72b7731bc2">FMSubAdd</a> (const S a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:ac07bb80fd7c1af62cb74ff72b7731bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:ac07bb80fd7c1af62cb74ff72b7731bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898ec216277e9f9dea3c60bf27f9c9cc" id="r_a898ec216277e9f9dea3c60bf27f9c9cc"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a898ec216277e9f9dea3c60bf27f9c9cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a898ec216277e9f9dea3c60bf27f9c9cc">FMSubAdd</a> (const S a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a898ec216277e9f9dea3c60bf27f9c9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a898ec216277e9f9dea3c60bf27f9c9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbacf3c8b5359ea3bc2e6a0d106e1638" id="r_adbacf3c8b5359ea3bc2e6a0d106e1638"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:adbacf3c8b5359ea3bc2e6a0d106e1638"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbacf3c8b5359ea3bc2e6a0d106e1638">FNMAdd</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:adbacf3c8b5359ea3bc2e6a0d106e1638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:adbacf3c8b5359ea3bc2e6a0d106e1638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1a58a6fa3446ad633c965415bd0f55" id="r_a6c1a58a6fa3446ad633c965415bd0f55"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a6c1a58a6fa3446ad633c965415bd0f55"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c1a58a6fa3446ad633c965415bd0f55">FNMAdd</a> (const S &amp;a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:a6c1a58a6fa3446ad633c965415bd0f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a6c1a58a6fa3446ad633c965415bd0f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6798fe5e5d19ac2b7a939263a96ddf25" id="r_a6798fe5e5d19ac2b7a939263a96ddf25"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</td></tr>
<tr class="memitem:a6798fe5e5d19ac2b7a939263a96ddf25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6798fe5e5d19ac2b7a939263a96ddf25">FNMAdd</a> (const S &amp;a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a6798fe5e5d19ac2b7a939263a96ddf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a6798fe5e5d19ac2b7a939263a96ddf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b56cbb4097d6cd7f6cb555aa62b8e5e" id="r_a7b56cbb4097d6cd7f6cb555aa62b8e5e"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a7b56cbb4097d6cd7f6cb555aa62b8e5e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b56cbb4097d6cd7f6cb555aa62b8e5e">FNMAdd</a> (const S &amp;a, const T b, const U c) noexcept</td></tr>
<tr class="memdesc:a7b56cbb4097d6cd7f6cb555aa62b8e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a7b56cbb4097d6cd7f6cb555aa62b8e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffd73b607497ae6998b78963b074ffd" id="r_a6ffd73b607497ae6998b78963b074ffd"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a6ffd73b607497ae6998b78963b074ffd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ffd73b607497ae6998b78963b074ffd">FNMAdd</a> (const S a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a6ffd73b607497ae6998b78963b074ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a6ffd73b607497ae6998b78963b074ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66111f12cf6c2119b936c8b27e8a3541" id="r_a66111f12cf6c2119b936c8b27e8a3541"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a66111f12cf6c2119b936c8b27e8a3541"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66111f12cf6c2119b936c8b27e8a3541">FNMAdd</a> (const S a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:a66111f12cf6c2119b936c8b27e8a3541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a66111f12cf6c2119b936c8b27e8a3541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76416f4792002a3835be04bbaebdea50" id="r_a76416f4792002a3835be04bbaebdea50"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a76416f4792002a3835be04bbaebdea50"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76416f4792002a3835be04bbaebdea50">FNMAdd</a> (const S a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a76416f4792002a3835be04bbaebdea50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values.  <br /></td></tr>
<tr class="separator:a76416f4792002a3835be04bbaebdea50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39f5bb4c2a5a6bd80cf0cf92dd2254e" id="r_aa39f5bb4c2a5a6bd80cf0cf92dd2254e"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:aa39f5bb4c2a5a6bd80cf0cf92dd2254e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa39f5bb4c2a5a6bd80cf0cf92dd2254e">FNMSub</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:aa39f5bb4c2a5a6bd80cf0cf92dd2254e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value.  <br /></td></tr>
<tr class="separator:aa39f5bb4c2a5a6bd80cf0cf92dd2254e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa5b0e9a338d1eac12c24099a357cff" id="r_a0fa5b0e9a338d1eac12c24099a357cff"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a0fa5b0e9a338d1eac12c24099a357cff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0fa5b0e9a338d1eac12c24099a357cff">FNMSub</a> (const S &amp;a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:a0fa5b0e9a338d1eac12c24099a357cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value.  <br /></td></tr>
<tr class="separator:a0fa5b0e9a338d1eac12c24099a357cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b1fae16725b6c6912cd7d7dc4adf8b" id="r_ab7b1fae16725b6c6912cd7d7dc4adf8b"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</td></tr>
<tr class="memitem:ab7b1fae16725b6c6912cd7d7dc4adf8b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7b1fae16725b6c6912cd7d7dc4adf8b">FNMSub</a> (const S &amp;a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:ab7b1fae16725b6c6912cd7d7dc4adf8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value.  <br /></td></tr>
<tr class="separator:ab7b1fae16725b6c6912cd7d7dc4adf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9fc01fcbb146431b021ad4f5abd786" id="r_a3f9fc01fcbb146431b021ad4f5abd786"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a3f9fc01fcbb146431b021ad4f5abd786"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f9fc01fcbb146431b021ad4f5abd786">FNMSub</a> (const S &amp;a, const T b, const U c) noexcept</td></tr>
<tr class="memdesc:a3f9fc01fcbb146431b021ad4f5abd786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value.  <br /></td></tr>
<tr class="separator:a3f9fc01fcbb146431b021ad4f5abd786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38b1067ea2bd62e831dfff3a3de6ab9" id="r_ac38b1067ea2bd62e831dfff3a3de6ab9"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ac38b1067ea2bd62e831dfff3a3de6ab9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac38b1067ea2bd62e831dfff3a3de6ab9">FNMSub</a> (const S a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:ac38b1067ea2bd62e831dfff3a3de6ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value.  <br /></td></tr>
<tr class="separator:ac38b1067ea2bd62e831dfff3a3de6ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ef6a65f0303050455f6c0ad677b0f3" id="r_a71ef6a65f0303050455f6c0ad677b0f3"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a71ef6a65f0303050455f6c0ad677b0f3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71ef6a65f0303050455f6c0ad677b0f3">FNMSub</a> (const S a, const T &amp;b, const U c) noexcept</td></tr>
<tr class="memdesc:a71ef6a65f0303050455f6c0ad677b0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value.  <br /></td></tr>
<tr class="separator:a71ef6a65f0303050455f6c0ad677b0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1af49997109d0c21835c03ed78ddea9" id="r_aa1af49997109d0c21835c03ed78ddea9"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:aa1af49997109d0c21835c03ed78ddea9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa1af49997109d0c21835c03ed78ddea9">FNMSub</a> (const S a, const T b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:aa1af49997109d0c21835c03ed78ddea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value.  <br /></td></tr>
<tr class="separator:aa1af49997109d0c21835c03ed78ddea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b81740275833db47fce3675780ffb67" id="r_a8b81740275833db47fce3675780ffb67"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a8b81740275833db47fce3675780ffb67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b81740275833db47fce3675780ffb67">Sin</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a8b81740275833db47fce3675780ffb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sine of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:a8b81740275833db47fce3675780ffb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fe4772620490929181e53fe6825abe" id="r_a05fe4772620490929181e53fe6825abe"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a05fe4772620490929181e53fe6825abe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05fe4772620490929181e53fe6825abe">FastSin</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a05fe4772620490929181e53fe6825abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sine of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:a05fe4772620490929181e53fe6825abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f2604b44c3de6b3b69207975eed2eb" id="r_aa4f2604b44c3de6b3b69207975eed2eb"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:aa4f2604b44c3de6b3b69207975eed2eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4f2604b44c3de6b3b69207975eed2eb">Cos</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:aa4f2604b44c3de6b3b69207975eed2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cosine of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:aa4f2604b44c3de6b3b69207975eed2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26aa9b0281a6223877e9f1abd15c37f9" id="r_a26aa9b0281a6223877e9f1abd15c37f9"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a26aa9b0281a6223877e9f1abd15c37f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a26aa9b0281a6223877e9f1abd15c37f9">FastCos</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a26aa9b0281a6223877e9f1abd15c37f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cosine of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:a26aa9b0281a6223877e9f1abd15c37f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701492ad1f13932a750e33478d1b94e4" id="r_a701492ad1f13932a750e33478d1b94e4"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a701492ad1f13932a750e33478d1b94e4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a701492ad1f13932a750e33478d1b94e4">SinCos</a> (const T &amp;v, T *cosines) noexcept</td></tr>
<tr class="memdesc:a701492ad1f13932a750e33478d1b94e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sine and cosine of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:a701492ad1f13932a750e33478d1b94e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4d39644295d3bd1b454e43dfe22673" id="r_afc4d39644295d3bd1b454e43dfe22673"><td class="memTemplParams" colspan="2">template&lt;TupleType T&gt; </td></tr>
<tr class="memitem:afc4d39644295d3bd1b454e43dfe22673"><td class="memTemplItemLeft" align="right" valign="top">T::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afc4d39644295d3bd1b454e43dfe22673">SinCos</a> (const T &amp;v, typename T::Simd *cosines) noexcept</td></tr>
<tr class="memdesc:afc4d39644295d3bd1b454e43dfe22673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sine and cosine of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:afc4d39644295d3bd1b454e43dfe22673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8aa947ced76e3fafcffd99f974c86b" id="r_a4a8aa947ced76e3fafcffd99f974c86b"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a4a8aa947ced76e3fafcffd99f974c86b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4a8aa947ced76e3fafcffd99f974c86b">FastSinCos</a> (const T &amp;v, T *cosines) noexcept</td></tr>
<tr class="memdesc:a4a8aa947ced76e3fafcffd99f974c86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sine and cosine of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:a4a8aa947ced76e3fafcffd99f974c86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae576d139ee4b7472146cfe608385b089" id="r_ae576d139ee4b7472146cfe608385b089"><td class="memTemplParams" colspan="2">template&lt;TupleType T&gt; </td></tr>
<tr class="memitem:ae576d139ee4b7472146cfe608385b089"><td class="memTemplItemLeft" align="right" valign="top">T::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae576d139ee4b7472146cfe608385b089">FastSinCos</a> (const T &amp;v, typename T::Simd *cosines) noexcept</td></tr>
<tr class="memdesc:ae576d139ee4b7472146cfe608385b089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sine and cosine of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:ae576d139ee4b7472146cfe608385b089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d486627e18042d3cb0d35aa4ccace4" id="r_aa3d486627e18042d3cb0d35aa4ccace4"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:aa3d486627e18042d3cb0d35aa4ccace4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa3d486627e18042d3cb0d35aa4ccace4">Tan</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:aa3d486627e18042d3cb0d35aa4ccace4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the tangent of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:aa3d486627e18042d3cb0d35aa4ccace4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8beede0d8813f97fce2e613b4e447a" id="r_aca8beede0d8813f97fce2e613b4e447a"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:aca8beede0d8813f97fce2e613b4e447a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca8beede0d8813f97fce2e613b4e447a">FastTan</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:aca8beede0d8813f97fce2e613b4e447a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the tangent of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:aca8beede0d8813f97fce2e613b4e447a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148224234abd6b410e5fa40201323924" id="r_a148224234abd6b410e5fa40201323924"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a148224234abd6b410e5fa40201323924"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a148224234abd6b410e5fa40201323924">ASin</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a148224234abd6b410e5fa40201323924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse sine of each element in the argument, in radians.  <br /></td></tr>
<tr class="separator:a148224234abd6b410e5fa40201323924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd02887de83f75907452f439b12e4146" id="r_acd02887de83f75907452f439b12e4146"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:acd02887de83f75907452f439b12e4146"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd02887de83f75907452f439b12e4146">ACos</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:acd02887de83f75907452f439b12e4146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse cosine of each element in the argument, in radians.  <br /></td></tr>
<tr class="separator:acd02887de83f75907452f439b12e4146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e5113b26b069b7d297029c72a65148" id="r_a23e5113b26b069b7d297029c72a65148"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a23e5113b26b069b7d297029c72a65148"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23e5113b26b069b7d297029c72a65148">ATan</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a23e5113b26b069b7d297029c72a65148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse tangent of each element in the argument, in radians.  <br /></td></tr>
<tr class="separator:a23e5113b26b069b7d297029c72a65148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c55b5799f42e0976196d5ad27e9e88" id="r_a44c55b5799f42e0976196d5ad27e9e88"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a44c55b5799f42e0976196d5ad27e9e88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a44c55b5799f42e0976196d5ad27e9e88">FastATan</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a44c55b5799f42e0976196d5ad27e9e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse tangent of each element in the argument, in radians.  <br /></td></tr>
<tr class="separator:a44c55b5799f42e0976196d5ad27e9e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55019be7b30b045b1e05d76d9b32e26" id="r_af55019be7b30b045b1e05d76d9b32e26"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:af55019be7b30b045b1e05d76d9b32e26"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af55019be7b30b045b1e05d76d9b32e26">ATan2</a> (const T &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, const U &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:af55019be7b30b045b1e05d76d9b32e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse tangent of each element in x divided by the corresponding element in y, in radians.  <br /></td></tr>
<tr class="separator:af55019be7b30b045b1e05d76d9b32e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182b6b9d78f9849bfb481babcc85f358" id="r_a182b6b9d78f9849bfb481babcc85f358"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a182b6b9d78f9849bfb481babcc85f358"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a182b6b9d78f9849bfb481babcc85f358">FastATan2</a> (const T &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, const U &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:a182b6b9d78f9849bfb481babcc85f358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse tangent of each element in x divided by the corresponding element in y, in radians.  <br /></td></tr>
<tr class="separator:a182b6b9d78f9849bfb481babcc85f358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771a7558deecb257a45b252229b48510" id="r_a771a7558deecb257a45b252229b48510"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a771a7558deecb257a45b252229b48510"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a771a7558deecb257a45b252229b48510">ModAngles</a> (const T &amp;angles)</td></tr>
<tr class="memdesc:a771a7558deecb257a45b252229b48510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the angle modulo 2PI.  <br /></td></tr>
<tr class="separator:a771a7558deecb257a45b252229b48510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fda071392d17eba907c00339c957a1" id="r_ae6fda071392d17eba907c00339c957a1"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ae6fda071392d17eba907c00339c957a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6fda071392d17eba907c00339c957a1">AddAngles</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:ae6fda071392d17eba907c00339c957a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the angles in the corresponding elements of v1 and v2. The argument angles must be in the range [-PI,PI), and the computed angles will be in the range [-PI,PI)  <br /></td></tr>
<tr class="separator:ae6fda071392d17eba907c00339c957a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f1a977bd237afc8a98de60c9b50a18" id="r_ab7f1a977bd237afc8a98de60c9b50a18"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ab7f1a977bd237afc8a98de60c9b50a18"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7f1a977bd237afc8a98de60c9b50a18">SubtractAngles</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:ab7f1a977bd237afc8a98de60c9b50a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the angles in v2 from the corresponding elements of v1. The argument angles must be in the range [-PI,PI), and the computed angles will be in the range [-PI,PI)  <br /></td></tr>
<tr class="separator:ab7f1a977bd237afc8a98de60c9b50a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6878772c2f5fec34d65f22f07291de1" id="r_ae6878772c2f5fec34d65f22f07291de1"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:ae6878772c2f5fec34d65f22f07291de1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6878772c2f5fec34d65f22f07291de1">SinH</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:ae6878772c2f5fec34d65f22f07291de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the hyperbolic sine of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:ae6878772c2f5fec34d65f22f07291de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7461c7f210cd8cb3753bac3d7c5c6160" id="r_a7461c7f210cd8cb3753bac3d7c5c6160"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a7461c7f210cd8cb3753bac3d7c5c6160"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7461c7f210cd8cb3753bac3d7c5c6160">CosH</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a7461c7f210cd8cb3753bac3d7c5c6160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the hyperbolic cosine of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:a7461c7f210cd8cb3753bac3d7c5c6160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09340bd80cd86c491c3091922b9acb80" id="r_a09340bd80cd86c491c3091922b9acb80"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a09340bd80cd86c491c3091922b9acb80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09340bd80cd86c491c3091922b9acb80">TanH</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a09340bd80cd86c491c3091922b9acb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the hyperbolic tangent of each element in the argument expressed in radians.  <br /></td></tr>
<tr class="separator:a09340bd80cd86c491c3091922b9acb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb9edec361f93d6d523c242f075657a" id="r_a9eb9edec361f93d6d523c242f075657a"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a9eb9edec361f93d6d523c242f075657a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9eb9edec361f93d6d523c242f075657a">ASinH</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a9eb9edec361f93d6d523c242f075657a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse hyperbolic sine of each element in the argument, in radians.  <br /></td></tr>
<tr class="separator:a9eb9edec361f93d6d523c242f075657a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ec4e562d1a0253868cfb2589af5877" id="r_ac6ec4e562d1a0253868cfb2589af5877"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:ac6ec4e562d1a0253868cfb2589af5877"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6ec4e562d1a0253868cfb2589af5877">ACosH</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:ac6ec4e562d1a0253868cfb2589af5877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse hyperbolic cosine of each element in the argument, in radians.  <br /></td></tr>
<tr class="separator:ac6ec4e562d1a0253868cfb2589af5877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d1e54202e936cc46491aa0ba1c316a" id="r_a00d1e54202e936cc46491aa0ba1c316a"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a00d1e54202e936cc46491aa0ba1c316a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00d1e54202e936cc46491aa0ba1c316a">ATanH</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a00d1e54202e936cc46491aa0ba1c316a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse hyperbolic tangent of each element in the argument, in radians.  <br /></td></tr>
<tr class="separator:a00d1e54202e936cc46491aa0ba1c316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3360f8684fa170bcb63d44ad9005b014" id="r_a3360f8684fa170bcb63d44ad9005b014"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a3360f8684fa170bcb63d44ad9005b014"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3360f8684fa170bcb63d44ad9005b014">Log</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a3360f8684fa170bcb63d44ad9005b014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the natural logarithm of each element in the argument.  <br /></td></tr>
<tr class="separator:a3360f8684fa170bcb63d44ad9005b014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fd41f558e13f68d037f037ceae96fd" id="r_a46fd41f558e13f68d037f037ceae96fd"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a46fd41f558e13f68d037f037ceae96fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a46fd41f558e13f68d037f037ceae96fd">Log1P</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a46fd41f558e13f68d037f037ceae96fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the natural logarithm of 1 + each element in the argument.  <br /></td></tr>
<tr class="separator:a46fd41f558e13f68d037f037ceae96fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a5ad775d4811bff132b7e8a7e8b63e" id="r_a80a5ad775d4811bff132b7e8a7e8b63e"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a80a5ad775d4811bff132b7e8a7e8b63e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80a5ad775d4811bff132b7e8a7e8b63e">Log10</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a80a5ad775d4811bff132b7e8a7e8b63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the base-10 logarithm of each element in the argument.  <br /></td></tr>
<tr class="separator:a80a5ad775d4811bff132b7e8a7e8b63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce8e1e47b5b4a0c3dcdbbb88ffffcd2" id="r_a8ce8e1e47b5b4a0c3dcdbbb88ffffcd2"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a8ce8e1e47b5b4a0c3dcdbbb88ffffcd2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ce8e1e47b5b4a0c3dcdbbb88ffffcd2">Log2</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a8ce8e1e47b5b4a0c3dcdbbb88ffffcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the base-2 logarithm, $$log_{2}_$$, of each element in the argument.  <br /></td></tr>
<tr class="separator:a8ce8e1e47b5b4a0c3dcdbbb88ffffcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806f968580b0257d965065603809d962" id="r_a806f968580b0257d965065603809d962"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a806f968580b0257d965065603809d962"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a806f968580b0257d965065603809d962">Exp</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a806f968580b0257d965065603809d962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $$e$$ (Euler's number, 2.7182818...), raised to the power of each element in the argument.  <br /></td></tr>
<tr class="separator:a806f968580b0257d965065603809d962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29845cbe4869b9e544f14827cc6be1df" id="r_a29845cbe4869b9e544f14827cc6be1df"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a29845cbe4869b9e544f14827cc6be1df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a29845cbe4869b9e544f14827cc6be1df">Exp10</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a29845cbe4869b9e544f14827cc6be1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the base-10 exponential of each element in the argument.  <br /></td></tr>
<tr class="separator:a29845cbe4869b9e544f14827cc6be1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23873c748c37959a4325dfac0e63ca43" id="r_a23873c748c37959a4325dfac0e63ca43"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a23873c748c37959a4325dfac0e63ca43"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23873c748c37959a4325dfac0e63ca43">Exp2</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a23873c748c37959a4325dfac0e63ca43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the base-2 exponential of each element in the argument.  <br /></td></tr>
<tr class="separator:a23873c748c37959a4325dfac0e63ca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4918974e22475001414044815a56fff6" id="r_a4918974e22475001414044815a56fff6"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a4918974e22475001414044815a56fff6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4918974e22475001414044815a56fff6">ExpM1</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a4918974e22475001414044815a56fff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates $$e$$ (Euler's number, 2.7182818...), raised to the power of each element in the argument, $$-1.0$$.  <br /></td></tr>
<tr class="separator:a4918974e22475001414044815a56fff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9108e5e3a74180c9c1c0f2e73aabcc84" id="r_a9108e5e3a74180c9c1c0f2e73aabcc84"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a9108e5e3a74180c9c1c0f2e73aabcc84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9108e5e3a74180c9c1c0f2e73aabcc84">Pow</a> (const T &amp;base, const U &amp;exponent) noexcept</td></tr>
<tr class="memdesc:a9108e5e3a74180c9c1c0f2e73aabcc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the elements in base raised to the corresponding element in exponent.  <br /></td></tr>
<tr class="separator:a9108e5e3a74180c9c1c0f2e73aabcc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1b60f9e68148505f1efbabd53d485d" id="r_afe1b60f9e68148505f1efbabd53d485d"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:afe1b60f9e68148505f1efbabd53d485d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe1b60f9e68148505f1efbabd53d485d">Pow</a> (const T &amp;base, const U exponent) noexcept</td></tr>
<tr class="memdesc:afe1b60f9e68148505f1efbabd53d485d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the elements in base raised to the value of exponent.  <br /></td></tr>
<tr class="separator:afe1b60f9e68148505f1efbabd53d485d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f5edb148bde50ba186189d742735ba" id="r_a37f5edb148bde50ba186189d742735ba"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a37f5edb148bde50ba186189d742735ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a37f5edb148bde50ba186189d742735ba">Pow</a> (const T &amp;base, const U &amp;exponent) noexcept</td></tr>
<tr class="memdesc:a37f5edb148bde50ba186189d742735ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of base raised to the corresponding elements in exponent.  <br /></td></tr>
<tr class="separator:a37f5edb148bde50ba186189d742735ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac649d582494620f306d07ff202ce287a" id="r_ac649d582494620f306d07ff202ce287a"><td class="memTemplParams" colspan="2">template&lt;int n, SimdType T&gt; </td></tr>
<tr class="memitem:ac649d582494620f306d07ff202ce287a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac649d582494620f306d07ff202ce287a">FastPow</a> (const T &amp;v)</td></tr>
<tr class="separator:ac649d582494620f306d07ff202ce287a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709296e6bc85fea1f90f0c07fe3d2ac3" id="r_a709296e6bc85fea1f90f0c07fe3d2ac3"><td class="memTemplParams" colspan="2">template&lt;int n, TupleType T&gt; </td></tr>
<tr class="memitem:a709296e6bc85fea1f90f0c07fe3d2ac3"><td class="memTemplItemLeft" align="right" valign="top">T::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a709296e6bc85fea1f90f0c07fe3d2ac3">FastPow</a> (const T &amp;v)</td></tr>
<tr class="separator:a709296e6bc85fea1f90f0c07fe3d2ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcd184cdeb070c8ddc099fd62c411bf" id="r_a7fcd184cdeb070c8ddc099fd62c411bf"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a7fcd184cdeb070c8ddc099fd62c411bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7fcd184cdeb070c8ddc099fd62c411bf">FMod</a> (const T &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, const U &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:a7fcd184cdeb070c8ddc099fd62c411bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation $x/y$.  <br /></td></tr>
<tr class="separator:a7fcd184cdeb070c8ddc099fd62c411bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1503d6a59b4562f3c33e6ec1171b9f1c" id="r_a1503d6a59b4562f3c33e6ec1171b9f1c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a1503d6a59b4562f3c33e6ec1171b9f1c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1503d6a59b4562f3c33e6ec1171b9f1c">FMod</a> (const T &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, const U <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:a1503d6a59b4562f3c33e6ec1171b9f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation $x/y$.  <br /></td></tr>
<tr class="separator:a1503d6a59b4562f3c33e6ec1171b9f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef8e8e0e4ae9d41ef85300aeed0e632" id="r_afef8e8e0e4ae9d41ef85300aeed0e632"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:afef8e8e0e4ae9d41ef85300aeed0e632"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afef8e8e0e4ae9d41ef85300aeed0e632">FMod</a> (const T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, const U &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:afef8e8e0e4ae9d41ef85300aeed0e632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the floating-point remainder of the division operation $x/y$.  <br /></td></tr>
<tr class="separator:afef8e8e0e4ae9d41ef85300aeed0e632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4646614499840724444a965539095d9" id="r_af4646614499840724444a965539095d9"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:af4646614499840724444a965539095d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af4646614499840724444a965539095d9">Hypot</a> (const T &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, const U &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:af4646614499840724444a965539095d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the square root of the sum of the squares of each corresponding element in x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:af4646614499840724444a965539095d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef21ea126690435f04dc76bcc14431c" id="r_afef21ea126690435f04dc76bcc14431c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:afef21ea126690435f04dc76bcc14431c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afef21ea126690435f04dc76bcc14431c">Hypot</a> (const T &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, const U <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:afef21ea126690435f04dc76bcc14431c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the square root of the sum of the squares of each corresponding element in x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:afef21ea126690435f04dc76bcc14431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482e782f44215ca6caebade70e35a942" id="r_a482e782f44215ca6caebade70e35a942"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a482e782f44215ca6caebade70e35a942"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a482e782f44215ca6caebade70e35a942">Hypot</a> (const T <a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a9abf21c7b37d6b658358f167db7e49a7">x</a>, const U &amp;<a class="el" href="_h_a_i_o_n_n_x_model_8cpp.html#a44596b79a5e28408065d1565fa209510">y</a>) noexcept</td></tr>
<tr class="memdesc:a482e782f44215ca6caebade70e35a942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the square root of the sum of the squares of each corresponding element in x and y, without undue overflow or underflow at intermediate stages of the computation.  <br /></td></tr>
<tr class="separator:a482e782f44215ca6caebade70e35a942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29cfbabaf6d069066e181e1b2a3f8e2" id="r_aa29cfbabaf6d069066e181e1b2a3f8e2"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U, SimdOrTupleType V, SimdOrTupleType W, ArithmeticType X&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U, V, W&gt;</td></tr>
<tr class="memitem:aa29cfbabaf6d069066e181e1b2a3f8e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa29cfbabaf6d069066e181e1b2a3f8e2">Hermite</a> (const T &amp;firstPosition, const U &amp;firstTangent, const V &amp;secondPosition, const W &amp;secondTangent, const <a class="el" href="_h_c_c_com_8cpp.html#ab73683fe9b2b763a892a53615dfae862">X</a> t) noexcept</td></tr>
<tr class="memdesc:aa29cfbabaf6d069066e181e1b2a3f8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Hermite spline interpolation, using the specified arguments.  <br /></td></tr>
<tr class="separator:aa29cfbabaf6d069066e181e1b2a3f8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ef4fecdb929d9eab252bb3ec07f3df" id="r_a58ef4fecdb929d9eab252bb3ec07f3df"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a58ef4fecdb929d9eab252bb3ec07f3df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58ef4fecdb929d9eab252bb3ec07f3df">Dot</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a58ef4fecdb929d9eab252bb3ec07f3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product between v1 and v2.  <br /></td></tr>
<tr class="separator:a58ef4fecdb929d9eab252bb3ec07f3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535a11852e78c12e2e2f04411ea4668c" id="r_a535a11852e78c12e2e2f04411ea4668c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#ae8eda03ef4993145c2888150d80a2892">Internal::HasSimdType</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a535a11852e78c12e2e2f04411ea4668c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a535a11852e78c12e2e2f04411ea4668c">Dot</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a535a11852e78c12e2e2f04411ea4668c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product between v1 and v2.  <br /></td></tr>
<tr class="separator:a535a11852e78c12e2e2f04411ea4668c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de2193bfc79a047f22aaf2b7a6ba143" id="r_a2de2193bfc79a047f22aaf2b7a6ba143"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a2de2193bfc79a047f22aaf2b7a6ba143"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2de2193bfc79a047f22aaf2b7a6ba143">Dot</a> (const T &amp;v1, const U v2) noexcept</td></tr>
<tr class="memdesc:a2de2193bfc79a047f22aaf2b7a6ba143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product between v1 and v2.  <br /></td></tr>
<tr class="separator:a2de2193bfc79a047f22aaf2b7a6ba143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bda914e3dc04887ca615396e6b8ddbe" id="r_a3bda914e3dc04887ca615396e6b8ddbe"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:a3bda914e3dc04887ca615396e6b8ddbe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bda914e3dc04887ca615396e6b8ddbe">Dot</a> (const T v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a3bda914e3dc04887ca615396e6b8ddbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product between v1 and v2.  <br /></td></tr>
<tr class="separator:a3bda914e3dc04887ca615396e6b8ddbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89da23e53a5cdd7dd0b69848e1a7d1ec" id="r_a89da23e53a5cdd7dd0b69848e1a7d1ec"><td class="memTemplParams" colspan="2">template&lt;TupleType T, TupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a89da23e53a5cdd7dd0b69848e1a7d1ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr T::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a89da23e53a5cdd7dd0b69848e1a7d1ec">Dot</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="separator:a89da23e53a5cdd7dd0b69848e1a7d1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc007fbeb8421fdc50933caf130913cc" id="r_abc007fbeb8421fdc50933caf130913cc"><td class="memTemplParams" colspan="2">template&lt;int mask, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:abc007fbeb8421fdc50933caf130913cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc007fbeb8421fdc50933caf130913cc">Dot</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:abc007fbeb8421fdc50933caf130913cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product between v1 and v2.  <br /></td></tr>
<tr class="separator:abc007fbeb8421fdc50933caf130913cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c33afe9b1a3559e46c7e720d3b405fd" id="r_a7c33afe9b1a3559e46c7e720d3b405fd"><td class="memTemplParams" colspan="2">template&lt;int mask, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#ae8eda03ef4993145c2888150d80a2892">Internal::HasSimdType</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a7c33afe9b1a3559e46c7e720d3b405fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c33afe9b1a3559e46c7e720d3b405fd">Dot</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a7c33afe9b1a3559e46c7e720d3b405fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product between v1 and v2.  <br /></td></tr>
<tr class="separator:a7c33afe9b1a3559e46c7e720d3b405fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c83ecd1022852cb347f6d5e3fced583" id="r_a8c83ecd1022852cb347f6d5e3fced583"><td class="memTemplParams" colspan="2">template&lt;int mask, SimdOrTupleType T, ArithmeticType U&gt; </td></tr>
<tr class="memitem:a8c83ecd1022852cb347f6d5e3fced583"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8c83ecd1022852cb347f6d5e3fced583">Dot</a> (const T &amp;v1, const U v2) noexcept</td></tr>
<tr class="memdesc:a8c83ecd1022852cb347f6d5e3fced583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product between v1 and v2.  <br /></td></tr>
<tr class="separator:a8c83ecd1022852cb347f6d5e3fced583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa0f41540e80c0195e72bc4c7d754cf" id="r_affa0f41540e80c0195e72bc4c7d754cf"><td class="memTemplParams" colspan="2">template&lt;int mask, ArithmeticType T, SimdOrTupleType U&gt; </td></tr>
<tr class="memitem:affa0f41540e80c0195e72bc4c7d754cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#affa0f41540e80c0195e72bc4c7d754cf">Dot</a> (const T v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:affa0f41540e80c0195e72bc4c7d754cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product between v1 and v2.  <br /></td></tr>
<tr class="separator:affa0f41540e80c0195e72bc4c7d754cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca8e0eca1deb0b0d310317b9e57afa" id="r_a4eca8e0eca1deb0b0d310317b9e57afa"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a4eca8e0eca1deb0b0d310317b9e57afa"><td class="memTemplItemLeft" align="right" valign="top">constexpr T::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4eca8e0eca1deb0b0d310317b9e57afa">ScalarDot</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="separator:a4eca8e0eca1deb0b0d310317b9e57afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc42c6c932eb1f9fb96fed3da5666e7" id="r_a6bc42c6c932eb1f9fb96fed3da5666e7"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a6bc42c6c932eb1f9fb96fed3da5666e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6bc42c6c932eb1f9fb96fed3da5666e7">AbsDot</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a6bc42c6c932eb1f9fb96fed3da5666e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the absolute value of the dot product between v1 and v2.  <br /></td></tr>
<tr class="separator:a6bc42c6c932eb1f9fb96fed3da5666e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b71e6c04f9d4206d02650a3a6510e7c" id="r_a6b71e6c04f9d4206d02650a3a6510e7c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a6b71e6c04f9d4206d02650a3a6510e7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b71e6c04f9d4206d02650a3a6510e7c">ScalarAbsDot</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a6b71e6c04f9d4206d02650a3a6510e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the absolute value of the dot product between v1 and v2.  <br /></td></tr>
<tr class="separator:a6b71e6c04f9d4206d02650a3a6510e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9d219069f5b092b9390a6920e28fa8" id="r_a9e9d219069f5b092b9390a6920e28fa8"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a9e9d219069f5b092b9390a6920e28fa8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e9d219069f5b092b9390a6920e28fa8">Cross</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a9e9d219069f5b092b9390a6920e28fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cross product between v1 and v2.  <br /></td></tr>
<tr class="separator:a9e9d219069f5b092b9390a6920e28fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9364713636ae2ee902dce90efa5d34ac" id="r_a9364713636ae2ee902dce90efa5d34ac"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a9364713636ae2ee902dce90efa5d34ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9364713636ae2ee902dce90efa5d34ac">Cross</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:a9364713636ae2ee902dce90efa5d34ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cross product between v1 and v2.  <br /></td></tr>
<tr class="separator:a9364713636ae2ee902dce90efa5d34ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b72c4a04cc88f914c316703d3c9df4" id="r_aa2b72c4a04cc88f914c316703d3c9df4"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:aa2b72c4a04cc88f914c316703d3c9df4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2b72c4a04cc88f914c316703d3c9df4">UnitCross</a> (const T &amp;v1, const U &amp;v2) noexcept</td></tr>
<tr class="memdesc:aa2b72c4a04cc88f914c316703d3c9df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the normalized cross product between v1 and v2.  <br /></td></tr>
<tr class="separator:aa2b72c4a04cc88f914c316703d3c9df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844c2009d9ced9f68ebd1b38de558e3c" id="r_a844c2009d9ced9f68ebd1b38de558e3c"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a844c2009d9ced9f68ebd1b38de558e3c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a844c2009d9ced9f68ebd1b38de558e3c">LengthSquared</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a844c2009d9ced9f68ebd1b38de558e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the squared length of v.  <br /></td></tr>
<tr class="separator:a844c2009d9ced9f68ebd1b38de558e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845a18f6d14abfb760de3a704fdecb91" id="r_a845a18f6d14abfb760de3a704fdecb91"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a845a18f6d14abfb760de3a704fdecb91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a845a18f6d14abfb760de3a704fdecb91">ScalarLengthSquared</a> (const T &amp;q) noexcept</td></tr>
<tr class="memdesc:a845a18f6d14abfb760de3a704fdecb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the square of the magnitude of a quaternion.  <br /></td></tr>
<tr class="separator:a845a18f6d14abfb760de3a704fdecb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad629bd0baac90c81107449235c3c2bcd" id="r_ad629bd0baac90c81107449235c3c2bcd"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:ad629bd0baac90c81107449235c3c2bcd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad629bd0baac90c81107449235c3c2bcd">Length</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:ad629bd0baac90c81107449235c3c2bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of v.  <br /></td></tr>
<tr class="separator:ad629bd0baac90c81107449235c3c2bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb677fdd2d3818f18c641b0979867e2" id="r_afbb677fdd2d3818f18c641b0979867e2"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:afbb677fdd2d3818f18c641b0979867e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbb677fdd2d3818f18c641b0979867e2">ScalarLength</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:afbb677fdd2d3818f18c641b0979867e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of v.  <br /></td></tr>
<tr class="separator:afbb677fdd2d3818f18c641b0979867e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bd724e99db6ccfcb40062a81912b07" id="r_a06bd724e99db6ccfcb40062a81912b07"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a06bd724e99db6ccfcb40062a81912b07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06bd724e99db6ccfcb40062a81912b07">Normalize</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a06bd724e99db6ccfcb40062a81912b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes v.  <br /></td></tr>
<tr class="separator:a06bd724e99db6ccfcb40062a81912b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0cd83fd88311738365f0bd98ec0542" id="r_a9a0cd83fd88311738365f0bd98ec0542"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a9a0cd83fd88311738365f0bd98ec0542"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a0cd83fd88311738365f0bd98ec0542">ReciprocalLength</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a9a0cd83fd88311738365f0bd98ec0542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the reciprocal length of v.  <br /></td></tr>
<tr class="separator:a9a0cd83fd88311738365f0bd98ec0542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f4468eca5feda1c1d36d561e0bd15e" id="r_ad0f4468eca5feda1c1d36d561e0bd15e"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:ad0f4468eca5feda1c1d36d561e0bd15e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0f4468eca5feda1c1d36d561e0bd15e">ScalarReciprocalLength</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:ad0f4468eca5feda1c1d36d561e0bd15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the reciprocal length of v.  <br /></td></tr>
<tr class="separator:ad0f4468eca5feda1c1d36d561e0bd15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a213a957f84c2ff45dd040b31ae57be" id="r_a4a213a957f84c2ff45dd040b31ae57be"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a4a213a957f84c2ff45dd040b31ae57be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4a213a957f84c2ff45dd040b31ae57be">DistanceSquared</a> (const T &amp;p1, const U &amp;p2) noexcept</td></tr>
<tr class="memdesc:a4a213a957f84c2ff45dd040b31ae57be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the squared distance between p1 and p2.  <br /></td></tr>
<tr class="separator:a4a213a957f84c2ff45dd040b31ae57be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291445cde5e5b18624862188adfe8323" id="r_a291445cde5e5b18624862188adfe8323"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a291445cde5e5b18624862188adfe8323"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a291445cde5e5b18624862188adfe8323">DistanceSquared</a> (const T &amp;p1, const U &amp;p2) noexcept</td></tr>
<tr class="memdesc:a291445cde5e5b18624862188adfe8323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the squared distance between p1 and p2.  <br /></td></tr>
<tr class="separator:a291445cde5e5b18624862188adfe8323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0232e9d00987e9fc0013d4eb0c610a31" id="r_a0232e9d00987e9fc0013d4eb0c610a31"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#ae8eda03ef4993145c2888150d80a2892">Internal::HasSimdType</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a0232e9d00987e9fc0013d4eb0c610a31"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0232e9d00987e9fc0013d4eb0c610a31">ScalarDistanceSquared</a> (const T &amp;p1, const U &amp;p2) noexcept</td></tr>
<tr class="memdesc:a0232e9d00987e9fc0013d4eb0c610a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the squared distance between p1 and p2.  <br /></td></tr>
<tr class="separator:a0232e9d00987e9fc0013d4eb0c610a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5936a2b50a56de122afc7b9b32b41c2" id="r_af5936a2b50a56de122afc7b9b32b41c2"><td class="memTemplParams" colspan="2">template&lt;TupleType T, TupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:af5936a2b50a56de122afc7b9b32b41c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5936a2b50a56de122afc7b9b32b41c2">ScalarDistanceSquared</a> (const T &amp;p1, const U &amp;p2) noexcept</td></tr>
<tr class="memdesc:af5936a2b50a56de122afc7b9b32b41c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the squared distance between p1 and p2.  <br /></td></tr>
<tr class="separator:af5936a2b50a56de122afc7b9b32b41c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff15aade37ccacb452f6c77ca7c65c97" id="r_aff15aade37ccacb452f6c77ca7c65c97"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:aff15aade37ccacb452f6c77ca7c65c97"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff15aade37ccacb452f6c77ca7c65c97">Distance</a> (const T &amp;p1, const U &amp;p2) noexcept</td></tr>
<tr class="memdesc:aff15aade37ccacb452f6c77ca7c65c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance between p1 and p2.  <br /></td></tr>
<tr class="separator:aff15aade37ccacb452f6c77ca7c65c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51cf618cee5a168c1fb2cc47f41af6c" id="r_af51cf618cee5a168c1fb2cc47f41af6c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:af51cf618cee5a168c1fb2cc47f41af6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af51cf618cee5a168c1fb2cc47f41af6c">ScalarDistance</a> (const T &amp;p1, const U &amp;p2) noexcept</td></tr>
<tr class="separator:af51cf618cee5a168c1fb2cc47f41af6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca7d37b4f5aca693fc56cd26d08f039" id="r_a2ca7d37b4f5aca693fc56cd26d08f039"><td class="memTemplParams" colspan="2">template&lt;SimdTupleOrArithmeticType S, SimdOrTupleType T, SimdTupleOrArithmeticType U, SimdTupleOrArithmeticType V&gt; </td></tr>
<tr class="memitem:a2ca7d37b4f5aca693fc56cd26d08f039"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ca7d37b4f5aca693fc56cd26d08f039">DifferenceOfProducts</a> (const S &amp;v1, const T &amp;v2, const U &amp;v3, const V &amp;v4) noexcept</td></tr>
<tr class="memdesc:a2ca7d37b4f5aca693fc56cd26d08f039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the difference between the product of the first and the second argument, and the product of the third and fourth argument.  <br /></td></tr>
<tr class="separator:a2ca7d37b4f5aca693fc56cd26d08f039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244585ee75d84b3a2da60a7b7cff3231" id="r_a244585ee75d84b3a2da60a7b7cff3231"><td class="memTemplParams" colspan="2">template&lt;SimdTupleOrArithmeticType S, SimdOrTupleType T, SimdTupleOrArithmeticType U, SimdTupleOrArithmeticType V&gt; </td></tr>
<tr class="memitem:a244585ee75d84b3a2da60a7b7cff3231"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a244585ee75d84b3a2da60a7b7cff3231">SumOfProducts</a> (const S &amp;v1, const T &amp;v2, const U &amp;v3, const V &amp;v4) noexcept</td></tr>
<tr class="memdesc:a244585ee75d84b3a2da60a7b7cff3231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sum of the product of the first and the second argument, and the product of the third and fourth argument.  <br /></td></tr>
<tr class="separator:a244585ee75d84b3a2da60a7b7cff3231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5224ffde0d0cbc95426bf45ce24d0570" id="r_a5224ffde0d0cbc95426bf45ce24d0570"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U, SimdOrTupleType V, SimdOrTupleType W&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, V&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, W&gt;</td></tr>
<tr class="memitem:a5224ffde0d0cbc95426bf45ce24d0570"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5224ffde0d0cbc95426bf45ce24d0570">BaryCentric</a> (const S &amp;p1, const T &amp;p2, const U &amp;p3, const V &amp;f, const W &amp;g) noexcept</td></tr>
<tr class="memdesc:a5224ffde0d0cbc95426bf45ce24d0570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a point in Barycentric coordinates, using the specified triangle. <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">https://en.wikipedia.org/wiki/Barycentric_coordinate_system</a>.  <br /></td></tr>
<tr class="separator:a5224ffde0d0cbc95426bf45ce24d0570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec68f5d1bd70bd9979501aa00682e22d" id="r_aec68f5d1bd70bd9979501aa00682e22d"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U, ArithmeticType V, ArithmeticType W&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</td></tr>
<tr class="memitem:aec68f5d1bd70bd9979501aa00682e22d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec68f5d1bd70bd9979501aa00682e22d">BaryCentric</a> (const S &amp;p1, const T &amp;p2, const U &amp;p3, const V f, const W g) noexcept</td></tr>
<tr class="memdesc:aec68f5d1bd70bd9979501aa00682e22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a point in Barycentric coordinates, using the specified triangle. <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">https://en.wikipedia.org/wiki/Barycentric_coordinate_system</a>.  <br /></td></tr>
<tr class="separator:aec68f5d1bd70bd9979501aa00682e22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcedb3d6ca6bcbd0023d9e712dc141c4" id="r_adcedb3d6ca6bcbd0023d9e712dc141c4"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U, SimdOrTupleType V, SimdOrTupleType W&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U, V, W&gt;</td></tr>
<tr class="memitem:adcedb3d6ca6bcbd0023d9e712dc141c4"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adcedb3d6ca6bcbd0023d9e712dc141c4">CatmullRom</a> (const S &amp;p1, const T &amp;p2, const U &amp;p3, const V &amp;p4, const W &amp;t) noexcept</td></tr>
<tr class="memdesc:adcedb3d6ca6bcbd0023d9e712dc141c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Catmull-Rom interpolation, using the specified positions.  <br /></td></tr>
<tr class="separator:adcedb3d6ca6bcbd0023d9e712dc141c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bae2f8239b21c4ae271716a81025a7" id="r_a07bae2f8239b21c4ae271716a81025a7"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U, SimdOrTupleType V, ArithmeticType W&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U, V&gt;</td></tr>
<tr class="memitem:a07bae2f8239b21c4ae271716a81025a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07bae2f8239b21c4ae271716a81025a7">CatmullRom</a> (const S &amp;p1, const T &amp;p2, const U &amp;p3, const V &amp;p4, const W t) noexcept</td></tr>
<tr class="memdesc:a07bae2f8239b21c4ae271716a81025a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Catmull-Rom interpolation, using the specified positions.  <br /></td></tr>
<tr class="separator:a07bae2f8239b21c4ae271716a81025a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9f5a30b8f0743f6ae2a8298a2176c8" id="r_a8e9f5a30b8f0743f6ae2a8298a2176c8"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a8e9f5a30b8f0743f6ae2a8298a2176c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8e9f5a30b8f0743f6ae2a8298a2176c8">MinComponentValue</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a8e9f5a30b8f0743f6ae2a8298a2176c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the lowest value held by the argument.  <br /></td></tr>
<tr class="separator:a8e9f5a30b8f0743f6ae2a8298a2176c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b71ee867b56992571eafaa17d3c3c6" id="r_a01b71ee867b56992571eafaa17d3c3c6"><td class="memTemplParams" colspan="2">template&lt;TupleType T&gt; </td></tr>
<tr class="memitem:a01b71ee867b56992571eafaa17d3c3c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a01b71ee867b56992571eafaa17d3c3c6">MinComponentValue</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a01b71ee867b56992571eafaa17d3c3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the lowest value held by the argument.  <br /></td></tr>
<tr class="separator:a01b71ee867b56992571eafaa17d3c3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed19a24e36207be2f169e7cc9bd5a76" id="r_a8ed19a24e36207be2f169e7cc9bd5a76"><td class="memTemplParams" colspan="2">template&lt;SimdType T&gt; </td></tr>
<tr class="memitem:a8ed19a24e36207be2f169e7cc9bd5a76"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8ed19a24e36207be2f169e7cc9bd5a76">MaxComponentValue</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a8ed19a24e36207be2f169e7cc9bd5a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the highest value held by the argument.  <br /></td></tr>
<tr class="separator:a8ed19a24e36207be2f169e7cc9bd5a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f4ae5005618854ec9e301326189950" id="r_a80f4ae5005618854ec9e301326189950"><td class="memTemplParams" colspan="2">template&lt;TupleType T&gt; </td></tr>
<tr class="memitem:a80f4ae5005618854ec9e301326189950"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80f4ae5005618854ec9e301326189950">MaxComponentValue</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a80f4ae5005618854ec9e301326189950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the highest value held by the argument.  <br /></td></tr>
<tr class="separator:a80f4ae5005618854ec9e301326189950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b567e29868c58fa11a7686d59fedd1" id="r_a71b567e29868c58fa11a7686d59fedd1"><td class="memTemplParams" colspan="2">template&lt;TupleType T&gt; </td></tr>
<tr class="memitem:a71b567e29868c58fa11a7686d59fedd1"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a71b567e29868c58fa11a7686d59fedd1">MaxComponentIndex</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a71b567e29868c58fa11a7686d59fedd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the offset of the highest value held by the argument.  <br /></td></tr>
<tr class="separator:a71b567e29868c58fa11a7686d59fedd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2407366affb46f16caaf16edb37864" id="r_aea2407366affb46f16caaf16edb37864"><td class="memTemplParams" colspan="2">template&lt;TupleType T&gt; </td></tr>
<tr class="memitem:aea2407366affb46f16caaf16edb37864"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea2407366affb46f16caaf16edb37864">MinComponentIndex</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:aea2407366affb46f16caaf16edb37864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the offset of the lowest value held by the argument.  <br /></td></tr>
<tr class="separator:aea2407366affb46f16caaf16edb37864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6010f678c8459ac1c6211e6cca8da1e" id="r_ae6010f678c8459ac1c6211e6cca8da1e"><td class="memTemplParams" colspan="2">template&lt;SimdType T, typename ResultT  = typename T::value_type&gt; </td></tr>
<tr class="memitem:ae6010f678c8459ac1c6211e6cca8da1e"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6010f678c8459ac1c6211e6cca8da1e">MinComponentIndex</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:ae6010f678c8459ac1c6211e6cca8da1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the offset of the lowest value held by the argument.  <br /></td></tr>
<tr class="separator:ae6010f678c8459ac1c6211e6cca8da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f134b133253b52c7e8b904af5237c1" id="r_a16f134b133253b52c7e8b904af5237c1"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:a16f134b133253b52c7e8b904af5237c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16f134b133253b52c7e8b904af5237c1">NextUp</a> (const T &amp;t) noexcept</td></tr>
<tr class="separator:a16f134b133253b52c7e8b904af5237c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf30bdb0da01190ccc7ca313a4e9cf89" id="r_acf30bdb0da01190ccc7ca313a4e9cf89"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T&gt; </td></tr>
<tr class="memitem:acf30bdb0da01190ccc7ca313a4e9cf89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf30bdb0da01190ccc7ca313a4e9cf89">NextDown</a> (const T &amp;t) noexcept</td></tr>
<tr class="separator:acf30bdb0da01190ccc7ca313a4e9cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f3155d409c324b290a15cf76e55c47" id="r_a41f3155d409c324b290a15cf76e55c47"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a41f3155d409c324b290a15cf76e55c47"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a41f3155d409c324b290a15cf76e55c47">AddAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a41f3155d409c324b290a15cf76e55c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7d295658733b6a9fc5565acc79b5f8" id="r_a2e7d295658733b6a9fc5565acc79b5f8"><td class="memTemplParams" colspan="2">template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a2e7d295658733b6a9fc5565acc79b5f8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e7d295658733b6a9fc5565acc79b5f8">AddAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a2e7d295658733b6a9fc5565acc79b5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d690183d66734176c5816622493ad13" id="r_a5d690183d66734176c5816622493ad13"><td class="memTemplParams" colspan="2">template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a5d690183d66734176c5816622493ad13"><td class="memTemplItemLeft" align="right" valign="top">S::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d690183d66734176c5816622493ad13">AddAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a5d690183d66734176c5816622493ad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ffb82246acf4370fe200803be25daa" id="r_ae1ffb82246acf4370fe200803be25daa"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:ae1ffb82246acf4370fe200803be25daa"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae1ffb82246acf4370fe200803be25daa">AddAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:ae1ffb82246acf4370fe200803be25daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfb11ad9dc88a77c73ccd5178496978" id="r_a6dfb11ad9dc88a77c73ccd5178496978"><td class="memTemplParams" colspan="2">template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a6dfb11ad9dc88a77c73ccd5178496978"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6dfb11ad9dc88a77c73ccd5178496978">AddAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a6dfb11ad9dc88a77c73ccd5178496978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60854f7df718292f5e99c7b1104c42ae" id="r_a60854f7df718292f5e99c7b1104c42ae"><td class="memTemplParams" colspan="2">template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a60854f7df718292f5e99c7b1104c42ae"><td class="memTemplItemLeft" align="right" valign="top">S::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60854f7df718292f5e99c7b1104c42ae">AddAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a60854f7df718292f5e99c7b1104c42ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2def5a3d62d220f756af1fd9eb9d49" id="r_adb2def5a3d62d220f756af1fd9eb9d49"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:adb2def5a3d62d220f756af1fd9eb9d49"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb2def5a3d62d220f756af1fd9eb9d49">SubAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:adb2def5a3d62d220f756af1fd9eb9d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e81baab7edbc21f3b0167ca2c580ae" id="r_ad2e81baab7edbc21f3b0167ca2c580ae"><td class="memTemplParams" colspan="2">template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:ad2e81baab7edbc21f3b0167ca2c580ae"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad2e81baab7edbc21f3b0167ca2c580ae">SubAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:ad2e81baab7edbc21f3b0167ca2c580ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f465768111b8acec4c637c68c3415b6" id="r_a1f465768111b8acec4c637c68c3415b6"><td class="memTemplParams" colspan="2">template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a1f465768111b8acec4c637c68c3415b6"><td class="memTemplItemLeft" align="right" valign="top">S::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f465768111b8acec4c637c68c3415b6">SubAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a1f465768111b8acec4c637c68c3415b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9122d0438e18a03261d45460ba892eb8" id="r_a9122d0438e18a03261d45460ba892eb8"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a9122d0438e18a03261d45460ba892eb8"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9122d0438e18a03261d45460ba892eb8">SubAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a9122d0438e18a03261d45460ba892eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70830bc95de2dd87f85e16122098531c" id="r_a70830bc95de2dd87f85e16122098531c"><td class="memTemplParams" colspan="2">template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a70830bc95de2dd87f85e16122098531c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70830bc95de2dd87f85e16122098531c">SubAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a70830bc95de2dd87f85e16122098531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580ff114a60306df67376f15eaa8727a" id="r_a580ff114a60306df67376f15eaa8727a"><td class="memTemplParams" colspan="2">template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a580ff114a60306df67376f15eaa8727a"><td class="memTemplItemLeft" align="right" valign="top">S::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a580ff114a60306df67376f15eaa8727a">SubAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a580ff114a60306df67376f15eaa8727a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bf712f5b1a53e2e7211cb8e6e097ba" id="r_a01bf712f5b1a53e2e7211cb8e6e097ba"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a01bf712f5b1a53e2e7211cb8e6e097ba"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a01bf712f5b1a53e2e7211cb8e6e097ba">MulAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a01bf712f5b1a53e2e7211cb8e6e097ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81563787853df304ae0c1048141b9fd6" id="r_a81563787853df304ae0c1048141b9fd6"><td class="memTemplParams" colspan="2">template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a81563787853df304ae0c1048141b9fd6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81563787853df304ae0c1048141b9fd6">MulAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a81563787853df304ae0c1048141b9fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1758b6a82a702c0ff58e4ecfab9f5c2b" id="r_a1758b6a82a702c0ff58e4ecfab9f5c2b"><td class="memTemplParams" colspan="2">template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a1758b6a82a702c0ff58e4ecfab9f5c2b"><td class="memTemplItemLeft" align="right" valign="top">S::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1758b6a82a702c0ff58e4ecfab9f5c2b">MulAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a1758b6a82a702c0ff58e4ecfab9f5c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2831472ebd0b5253938bd4af13be125f" id="r_a2831472ebd0b5253938bd4af13be125f"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a2831472ebd0b5253938bd4af13be125f"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2831472ebd0b5253938bd4af13be125f">MulAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a2831472ebd0b5253938bd4af13be125f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5012fda809dfc71f79505811e149427b" id="r_a5012fda809dfc71f79505811e149427b"><td class="memTemplParams" colspan="2">template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a5012fda809dfc71f79505811e149427b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5012fda809dfc71f79505811e149427b">MulAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a5012fda809dfc71f79505811e149427b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038223a68090555ae7602da11b1a9ac3" id="r_a038223a68090555ae7602da11b1a9ac3"><td class="memTemplParams" colspan="2">template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a038223a68090555ae7602da11b1a9ac3"><td class="memTemplItemLeft" align="right" valign="top">S::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a038223a68090555ae7602da11b1a9ac3">MulAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a038223a68090555ae7602da11b1a9ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c846bb8205b6c037a2fb8cffac719d" id="r_a88c846bb8205b6c037a2fb8cffac719d"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a88c846bb8205b6c037a2fb8cffac719d"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88c846bb8205b6c037a2fb8cffac719d">DivAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a88c846bb8205b6c037a2fb8cffac719d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074274f3a2a072ec34a50c73cb0d5187" id="r_a074274f3a2a072ec34a50c73cb0d5187"><td class="memTemplParams" colspan="2">template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a074274f3a2a072ec34a50c73cb0d5187"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a074274f3a2a072ec34a50c73cb0d5187">DivAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a074274f3a2a072ec34a50c73cb0d5187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1914b2720651f8581fde0dd1868e19" id="r_a7a1914b2720651f8581fde0dd1868e19"><td class="memTemplParams" colspan="2">template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a7a1914b2720651f8581fde0dd1868e19"><td class="memTemplItemLeft" align="right" valign="top">S::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a1914b2720651f8581fde0dd1868e19">DivAdjustUp</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a7a1914b2720651f8581fde0dd1868e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce27796f7b5a4cb52f8a00dd9cfda57" id="r_a9ce27796f7b5a4cb52f8a00dd9cfda57"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a9ce27796f7b5a4cb52f8a00dd9cfda57"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ce27796f7b5a4cb52f8a00dd9cfda57">DivAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a9ce27796f7b5a4cb52f8a00dd9cfda57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad82a485e04ca81c9a49b8f47e6263c" id="r_a0ad82a485e04ca81c9a49b8f47e6263c"><td class="memTemplParams" colspan="2">template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a0ad82a485e04ca81c9a49b8f47e6263c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ad82a485e04ca81c9a49b8f47e6263c">DivAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a0ad82a485e04ca81c9a49b8f47e6263c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203cd558a66fa30b66af04eb1c5029d3" id="r_a203cd558a66fa30b66af04eb1c5029d3"><td class="memTemplParams" colspan="2">template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a203cd558a66fa30b66af04eb1c5029d3"><td class="memTemplItemLeft" align="right" valign="top">S::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a203cd558a66fa30b66af04eb1c5029d3">DivAdjustDown</a> (const S &amp;a, const T &amp;b) noexcept</td></tr>
<tr class="separator:a203cd558a66fa30b66af04eb1c5029d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fed943c191fac14f41b20c994f1d83b" id="r_a6fed943c191fac14f41b20c994f1d83b"><td class="memTemplParams" colspan="2">template&lt;SimdType S&gt; </td></tr>
<tr class="memitem:a6fed943c191fac14f41b20c994f1d83b"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6fed943c191fac14f41b20c994f1d83b">SqrtAdjustUp</a> (const S &amp;v) noexcept</td></tr>
<tr class="separator:a6fed943c191fac14f41b20c994f1d83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc765d2ea0f51551231ce5e0c056f4f9" id="r_afc765d2ea0f51551231ce5e0c056f4f9"><td class="memTemplParams" colspan="2">template&lt;TupleType S&gt; </td></tr>
<tr class="memitem:afc765d2ea0f51551231ce5e0c056f4f9"><td class="memTemplItemLeft" align="right" valign="top">S::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afc765d2ea0f51551231ce5e0c056f4f9">SqrtAdjustUp</a> (const S &amp;v) noexcept</td></tr>
<tr class="separator:afc765d2ea0f51551231ce5e0c056f4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93ba39b1fd7996108093248f2da5b02" id="r_ad93ba39b1fd7996108093248f2da5b02"><td class="memTemplParams" colspan="2">template&lt;SimdType S&gt; </td></tr>
<tr class="memitem:ad93ba39b1fd7996108093248f2da5b02"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad93ba39b1fd7996108093248f2da5b02">SqrtAdjustDown</a> (const S &amp;v) noexcept</td></tr>
<tr class="separator:ad93ba39b1fd7996108093248f2da5b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0839a63c1f94a51660d37e2f6305cb5" id="r_ac0839a63c1f94a51660d37e2f6305cb5"><td class="memTemplParams" colspan="2">template&lt;TupleType S&gt; </td></tr>
<tr class="memitem:ac0839a63c1f94a51660d37e2f6305cb5"><td class="memTemplItemLeft" align="right" valign="top">S::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac0839a63c1f94a51660d37e2f6305cb5">SqrtAdjustDown</a> (const S &amp;v) noexcept</td></tr>
<tr class="separator:ac0839a63c1f94a51660d37e2f6305cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d6ba1326feac82c6dc11db4110fd49" id="r_a01d6ba1326feac82c6dc11db4110fd49"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , SimdType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a01d6ba1326feac82c6dc11db4110fd49"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a01d6ba1326feac82c6dc11db4110fd49">FMAAdjustUp</a> (NumberT a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a01d6ba1326feac82c6dc11db4110fd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a01d6ba1326feac82c6dc11db4110fd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcf4e69931fb6948645fa5e67a06fe3" id="r_afbcf4e69931fb6948645fa5e67a06fe3"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , TupleType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:afbcf4e69931fb6948645fa5e67a06fe3"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbcf4e69931fb6948645fa5e67a06fe3">FMAAdjustUp</a> (NumberT a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:afbcf4e69931fb6948645fa5e67a06fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:afbcf4e69931fb6948645fa5e67a06fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d1a6298de6409171125936f2f120d8" id="r_a32d1a6298de6409171125936f2f120d8"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a32d1a6298de6409171125936f2f120d8"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32d1a6298de6409171125936f2f120d8">FMAAdjustUp</a> (NumberT a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a32d1a6298de6409171125936f2f120d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a32d1a6298de6409171125936f2f120d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98e3f9abf59e917582f16e7d3749ae9" id="r_ad98e3f9abf59e917582f16e7d3749ae9"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , SimdType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ad98e3f9abf59e917582f16e7d3749ae9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad98e3f9abf59e917582f16e7d3749ae9">FMAAdjustUp</a> (const T &amp;a, NumberT b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:ad98e3f9abf59e917582f16e7d3749ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:ad98e3f9abf59e917582f16e7d3749ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659dbcd6f443dbcff7d0a9d39dc44f76" id="r_a659dbcd6f443dbcff7d0a9d39dc44f76"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , TupleType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a659dbcd6f443dbcff7d0a9d39dc44f76"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a659dbcd6f443dbcff7d0a9d39dc44f76">FMAAdjustUp</a> (const T &amp;a, NumberT b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a659dbcd6f443dbcff7d0a9d39dc44f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a659dbcd6f443dbcff7d0a9d39dc44f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4080d1c773e9b29db1dad5cb95f84f49" id="r_a4080d1c773e9b29db1dad5cb95f84f49"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a4080d1c773e9b29db1dad5cb95f84f49"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4080d1c773e9b29db1dad5cb95f84f49">FMAAdjustUp</a> (const T &amp;a, NumberT b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a4080d1c773e9b29db1dad5cb95f84f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a4080d1c773e9b29db1dad5cb95f84f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963d5366391bf28fad1dc92cef0c8650" id="r_a963d5366391bf28fad1dc92cef0c8650"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a963d5366391bf28fad1dc92cef0c8650"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a963d5366391bf28fad1dc92cef0c8650">FMAAdjustUp</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a963d5366391bf28fad1dc92cef0c8650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a963d5366391bf28fad1dc92cef0c8650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb099a8b9ab60811aea24071d683f89" id="r_a3fb099a8b9ab60811aea24071d683f89"><td class="memTemplParams" colspan="2">template&lt;SimdType S, TupleType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a3fb099a8b9ab60811aea24071d683f89"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3fb099a8b9ab60811aea24071d683f89">FMAAdjustUp</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a3fb099a8b9ab60811aea24071d683f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a3fb099a8b9ab60811aea24071d683f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e18cc03321cdb7178f68efc82edee80" id="r_a4e18cc03321cdb7178f68efc82edee80"><td class="memTemplParams" colspan="2">template&lt;SimdType S, TupleType T, TupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a4e18cc03321cdb7178f68efc82edee80"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e18cc03321cdb7178f68efc82edee80">FMAAdjustUp</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a4e18cc03321cdb7178f68efc82edee80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a4e18cc03321cdb7178f68efc82edee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2138cf0403a76a9f01a069cb8858a2" id="r_a3b2138cf0403a76a9f01a069cb8858a2"><td class="memTemplParams" colspan="2">template&lt;TupleType S, TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a3b2138cf0403a76a9f01a069cb8858a2"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b2138cf0403a76a9f01a069cb8858a2">FMAAdjustUp</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a3b2138cf0403a76a9f01a069cb8858a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a3b2138cf0403a76a9f01a069cb8858a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada06eb08176b89693d95f02bb1d69398" id="r_ada06eb08176b89693d95f02bb1d69398"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , SimdType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:ada06eb08176b89693d95f02bb1d69398"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada06eb08176b89693d95f02bb1d69398">FMAAdjustDown</a> (NumberT a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:ada06eb08176b89693d95f02bb1d69398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:ada06eb08176b89693d95f02bb1d69398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728238ae7ab7958aefe5492d63979d53" id="r_a728238ae7ab7958aefe5492d63979d53"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , TupleType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a728238ae7ab7958aefe5492d63979d53"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a728238ae7ab7958aefe5492d63979d53">FMAAdjustDown</a> (NumberT a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a728238ae7ab7958aefe5492d63979d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a728238ae7ab7958aefe5492d63979d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4998e180bead63df218dc87351854f1" id="r_aa4998e180bead63df218dc87351854f1"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:aa4998e180bead63df218dc87351854f1"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4998e180bead63df218dc87351854f1">FMAAdjustDown</a> (NumberT a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:aa4998e180bead63df218dc87351854f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:aa4998e180bead63df218dc87351854f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d030d2e8569d47fdb063b27a53c33d9" id="r_a1d030d2e8569d47fdb063b27a53c33d9"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , SimdType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a1d030d2e8569d47fdb063b27a53c33d9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d030d2e8569d47fdb063b27a53c33d9">FMAAdjustDown</a> (const T &amp;a, NumberT b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a1d030d2e8569d47fdb063b27a53c33d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a1d030d2e8569d47fdb063b27a53c33d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb442c09fa65c5dbad4bd1b8ab83961d" id="r_aeb442c09fa65c5dbad4bd1b8ab83961d"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , TupleType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:aeb442c09fa65c5dbad4bd1b8ab83961d"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb442c09fa65c5dbad4bd1b8ab83961d">FMAAdjustDown</a> (const T &amp;a, NumberT b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:aeb442c09fa65c5dbad4bd1b8ab83961d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:aeb442c09fa65c5dbad4bd1b8ab83961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b203902707ebce390b9255a7b7ab94" id="r_a08b203902707ebce390b9255a7b7ab94"><td class="memTemplParams" colspan="2">template&lt;typename NumberT , TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a08b203902707ebce390b9255a7b7ab94"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08b203902707ebce390b9255a7b7ab94">FMAAdjustDown</a> (const T &amp;a, NumberT b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a08b203902707ebce390b9255a7b7ab94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a08b203902707ebce390b9255a7b7ab94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b54d3ee46859cbde89486d392b17fa" id="r_a43b54d3ee46859cbde89486d392b17fa"><td class="memTemplParams" colspan="2">template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a43b54d3ee46859cbde89486d392b17fa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a43b54d3ee46859cbde89486d392b17fa">FMAAdjustDown</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a43b54d3ee46859cbde89486d392b17fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a43b54d3ee46859cbde89486d392b17fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844d22a670a4d5feb0442825cf692dd6" id="r_a844d22a670a4d5feb0442825cf692dd6"><td class="memTemplParams" colspan="2">template&lt;SimdType S, TupleType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a844d22a670a4d5feb0442825cf692dd6"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a844d22a670a4d5feb0442825cf692dd6">FMAAdjustDown</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a844d22a670a4d5feb0442825cf692dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a844d22a670a4d5feb0442825cf692dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d038320f1e1484d7071b739c97d5c6f" id="r_a6d038320f1e1484d7071b739c97d5c6f"><td class="memTemplParams" colspan="2">template&lt;SimdType S, TupleType T, TupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a6d038320f1e1484d7071b739c97d5c6f"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d038320f1e1484d7071b739c97d5c6f">FMAAdjustDown</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a6d038320f1e1484d7071b739c97d5c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a6d038320f1e1484d7071b739c97d5c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e243ae1456f282199c34591c10ae43" id="r_a23e243ae1456f282199c34591c10ae43"><td class="memTemplParams" colspan="2">template&lt;TupleType S, TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a23e243ae1456f282199c34591c10ae43"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23e243ae1456f282199c34591c10ae43">FMAAdjustDown</a> (const S &amp;a, const T &amp;b, const U &amp;c) noexcept</td></tr>
<tr class="memdesc:a23e243ae1456f282199c34591c10ae43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.  <br /></td></tr>
<tr class="separator:a23e243ae1456f282199c34591c10ae43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a730afee6f66dec7bf9ec64f48e263" id="r_a62a730afee6f66dec7bf9ec64f48e263"><td class="memTemplParams" colspan="2">template&lt;VectorOrVectorSimdType S, VectorOrVectorSimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a62a730afee6f66dec7bf9ec64f48e263"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a62a730afee6f66dec7bf9ec64f48e263">AngleBetween</a> (const S &amp;v1, const T &amp;v2) noexcept</td></tr>
<tr class="memdesc:a62a730afee6f66dec7bf9ec64f48e263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the angle in radians between two vectors.  <br /></td></tr>
<tr class="separator:a62a730afee6f66dec7bf9ec64f48e263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f09dcb382f2a6d37cd1cbe95cfb6e73" id="r_a6f09dcb382f2a6d37cd1cbe95cfb6e73"><td class="memTemplParams" colspan="2">template&lt;VectorOrVectorSimdType S, VectorOrVectorSimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</td></tr>
<tr class="memitem:a6f09dcb382f2a6d37cd1cbe95cfb6e73"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6f09dcb382f2a6d37cd1cbe95cfb6e73">AngleBetweenNormalized</a> (const S &amp;v1, const T &amp;v2) noexcept</td></tr>
<tr class="memdesc:a6f09dcb382f2a6d37cd1cbe95cfb6e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the angle in radians between two normalized vectors.  <br /></td></tr>
<tr class="separator:a6f09dcb382f2a6d37cd1cbe95cfb6e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5e427bddb4cf1199f2adbc65eeced4" id="r_a0e5e427bddb4cf1199f2adbc65eeced4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a639cabf2f826e7b0876ba10529ea9d06">Point2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e5e427bddb4cf1199f2adbc65eeced4">InvertBilinear</a> (const <a class="el" href="#a639cabf2f826e7b0876ba10529ea9d06">Point2f</a> &amp;p, const std::array&lt; <a class="el" href="#a639cabf2f826e7b0876ba10529ea9d06">Point2f</a>, 4 &gt; &amp;vert)</td></tr>
<tr class="separator:a0e5e427bddb4cf1199f2adbc65eeced4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eda795c9a79228776bc7b0a7047fd24" id="r_a4eda795c9a79228776bc7b0a7047fd24"><td class="memTemplParams" colspan="2">template&lt;PointOrPointSimdType S, PointOrPointSimdType T, PointOrPointSimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</td></tr>
<tr class="memitem:a4eda795c9a79228776bc7b0a7047fd24"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4eda795c9a79228776bc7b0a7047fd24">LinePointDistance</a> (const S &amp;linePoint1, const T &amp;linePoint2, const U &amp;point) noexcept</td></tr>
<tr class="memdesc:a4eda795c9a79228776bc7b0a7047fd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimum distance between a line and a point.  <br /></td></tr>
<tr class="separator:a4eda795c9a79228776bc7b0a7047fd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdc7f1c5e4d3611321bcbc9413e6660" id="r_a8fdc7f1c5e4d3611321bcbc9413e6660"><td class="memTemplParams" colspan="2">template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a8fdc7f1c5e4d3611321bcbc9413e6660"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8fdc7f1c5e4d3611321bcbc9413e6660">operator+</a> (const T &amp;q1, const U &amp;q2) noexcept</td></tr>
<tr class="separator:a8fdc7f1c5e4d3611321bcbc9413e6660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58296b0814d43e5623976d0be580bf22" id="r_a58296b0814d43e5623976d0be580bf22"><td class="memTemplParams" colspan="2">template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a58296b0814d43e5623976d0be580bf22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58296b0814d43e5623976d0be580bf22">operator-</a> (const T &amp;q1, const U &amp;q2) noexcept</td></tr>
<tr class="separator:a58296b0814d43e5623976d0be580bf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4885d377d4fc579d579d6e1736ac1d" id="r_a1b4885d377d4fc579d579d6e1736ac1d"><td class="memTemplParams" colspan="2">template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a1b4885d377d4fc579d579d6e1736ac1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b4885d377d4fc579d579d6e1736ac1d">operator*</a> (const T &amp;q1, const U &amp;q2) noexcept</td></tr>
<tr class="separator:a1b4885d377d4fc579d579d6e1736ac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed3e7b2f7bcdb1ebea8d4eb3164a0ee" id="r_a7ed3e7b2f7bcdb1ebea8d4eb3164a0ee"><td class="memTemplParams" colspan="2">template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a7ed3e7b2f7bcdb1ebea8d4eb3164a0ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ed3e7b2f7bcdb1ebea8d4eb3164a0ee">Dot</a> (const T &amp;q1, const U &amp;q2) noexcept</td></tr>
<tr class="memdesc:a7ed3e7b2f7bcdb1ebea8d4eb3164a0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product of two quaternions.  <br /></td></tr>
<tr class="separator:a7ed3e7b2f7bcdb1ebea8d4eb3164a0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a6ee17ae410663b02855e1e8f2f82a" id="r_aa4a6ee17ae410663b02855e1e8f2f82a"><td class="memTemplParams" colspan="2">template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:aa4a6ee17ae410663b02855e1e8f2f82a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa4a6ee17ae410663b02855e1e8f2f82a">ScalarDot</a> (const T &amp;q1, const U &amp;q2) noexcept</td></tr>
<tr class="memdesc:aa4a6ee17ae410663b02855e1e8f2f82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product of two quaternions.  <br /></td></tr>
<tr class="separator:aa4a6ee17ae410663b02855e1e8f2f82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57f09c85801bdd5cc42aeea627cc386" id="r_ac57f09c85801bdd5cc42aeea627cc386"><td class="memTemplParams" colspan="2">template&lt;QuaternionOrQuaternionSimdType T&gt; </td></tr>
<tr class="memitem:ac57f09c85801bdd5cc42aeea627cc386"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac57f09c85801bdd5cc42aeea627cc386">Conjugate</a> (const T &amp;q) noexcept</td></tr>
<tr class="memdesc:ac57f09c85801bdd5cc42aeea627cc386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the conjugate of a quaternion.  <br /></td></tr>
<tr class="separator:ac57f09c85801bdd5cc42aeea627cc386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9398ca7ba986eb00da0a2cf9d51f6c65" id="r_a9398ca7ba986eb00da0a2cf9d51f6c65"><td class="memTemplParams" colspan="2">template&lt;QuaternionOrQuaternionSimdType T&gt; </td></tr>
<tr class="memitem:a9398ca7ba986eb00da0a2cf9d51f6c65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9398ca7ba986eb00da0a2cf9d51f6c65">Inverse</a> (const T &amp;q) noexcept</td></tr>
<tr class="memdesc:a9398ca7ba986eb00da0a2cf9d51f6c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of a quaternion.  <br /></td></tr>
<tr class="separator:a9398ca7ba986eb00da0a2cf9d51f6c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6884f244221cfbec2986a8052bdbb20f" id="r_a6884f244221cfbec2986a8052bdbb20f"><td class="memTemplParams" colspan="2">template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U, SimdOrTupleType V&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt; &amp;&amp; ( V::Size == 4 )</td></tr>
<tr class="memitem:a6884f244221cfbec2986a8052bdbb20f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6884f244221cfbec2986a8052bdbb20f">Slerp</a> (const T &amp;q1, const U &amp;q2, const V &amp;t) noexcept</td></tr>
<tr class="memdesc:a6884f244221cfbec2986a8052bdbb20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical linear interpolation between two unit quaternions.  <br /></td></tr>
<tr class="separator:a6884f244221cfbec2986a8052bdbb20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb07950d74b4056483380a8912c2c07" id="r_a9cb07950d74b4056483380a8912c2c07"><td class="memTemplParams" colspan="2">template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U, ArithmeticType V&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a9cb07950d74b4056483380a8912c2c07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9cb07950d74b4056483380a8912c2c07">Slerp</a> (const T &amp;q1, const U &amp;q2, const V t) noexcept</td></tr>
<tr class="memdesc:a9cb07950d74b4056483380a8912c2c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical linear interpolation between two unit quaternions.  <br /></td></tr>
<tr class="separator:a9cb07950d74b4056483380a8912c2c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0bb61b81c4d1b1a92ae52f0e3d23e3" id="r_abc0bb61b81c4d1b1a92ae52f0e3d23e3"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, QuaternionOrQuaternionSimdType T&gt; <br />
requires ( S::Size == 3 )</td></tr>
<tr class="memitem:abc0bb61b81c4d1b1a92ae52f0e3d23e3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc0bb61b81c4d1b1a92ae52f0e3d23e3">Rotate</a> (const S &amp;v, const T &amp;rotationQuaternion)</td></tr>
<tr class="memdesc:abc0bb61b81c4d1b1a92ae52f0e3d23e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a vector using a quaternion.  <br /></td></tr>
<tr class="separator:abc0bb61b81c4d1b1a92ae52f0e3d23e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486d0c6b90afc438145d4a28f35fc7fd" id="r_a486d0c6b90afc438145d4a28f35fc7fd"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, QuaternionOrQuaternionSimdType T&gt; <br />
requires ( S::Size == 3 )</td></tr>
<tr class="memitem:a486d0c6b90afc438145d4a28f35fc7fd"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a486d0c6b90afc438145d4a28f35fc7fd">InverseRotate</a> (const S &amp;v, const T &amp;rotationQuaternion)</td></tr>
<tr class="memdesc:a486d0c6b90afc438145d4a28f35fc7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a vector using the inverse of a quaternion.  <br /></td></tr>
<tr class="separator:a486d0c6b90afc438145d4a28f35fc7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac241719bf1efad28424d9bf63041785d" id="r_ac241719bf1efad28424d9bf63041785d"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt; &amp;&amp; ( T::Size == 3 )</td></tr>
<tr class="memitem:ac241719bf1efad28424d9bf63041785d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac241719bf1efad28424d9bf63041785d">ShortestArc</a> (const T &amp;fromDir, const U &amp;toDir) noexcept</td></tr>
<tr class="memdesc:ac241719bf1efad28424d9bf63041785d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the shortest-arc rotation between two directions.  <br /></td></tr>
<tr class="separator:ac241719bf1efad28424d9bf63041785d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b5fc6c7c9034cd605b23d36c997b15" id="r_a30b5fc6c7c9034cd605b23d36c997b15"><td class="memTemplParams" colspan="2">template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</td></tr>
<tr class="memitem:a30b5fc6c7c9034cd605b23d36c997b15"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a30b5fc6c7c9034cd605b23d36c997b15">ScalarAngleBetween</a> (const T &amp;v1, const U &amp;v2)</td></tr>
<tr class="separator:a30b5fc6c7c9034cd605b23d36c997b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81a7492e799828f6e7d4be05dae1d13" id="r_ad81a7492e799828f6e7d4be05dae1d13"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename FloatT &gt; </td></tr>
<tr class="memitem:ad81a7492e799828f6e7d4be05dae1d13"><td class="memTemplItemLeft" align="right" valign="top">constexpr FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad81a7492e799828f6e7d4be05dae1d13">ScalarAngleBetween</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a>&lt; DerivedT, FloatT &gt; &amp;v1, const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a>&lt; DerivedT, FloatT &gt; &amp;v2)</td></tr>
<tr class="separator:ad81a7492e799828f6e7d4be05dae1d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9f26a9d9d52903ed5ab6fd5e049073" id="r_a7c9f26a9d9d52903ed5ab6fd5e049073"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename FloatT &gt; </td></tr>
<tr class="memitem:a7c9f26a9d9d52903ed5ab6fd5e049073"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a>&lt; DerivedT, FloatT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c9f26a9d9d52903ed5ab6fd5e049073">AngleBetween</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a>&lt; DerivedT, FloatT &gt; &amp;v1, const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a>&lt; DerivedT, FloatT &gt; &amp;v2)</td></tr>
<tr class="separator:a7c9f26a9d9d52903ed5ab6fd5e049073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48babd24dcb46b99a6ced9df03584318" id="r_a48babd24dcb46b99a6ced9df03584318"><td class="memTemplParams" colspan="2">template&lt;SquareMatrixSimdType T1, SquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;</td></tr>
<tr class="memitem:a48babd24dcb46b99a6ced9df03584318"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a48babd24dcb46b99a6ced9df03584318">operator+</a> (const T1 &amp;m1, const T2 &amp;m2) noexcept</td></tr>
<tr class="separator:a48babd24dcb46b99a6ced9df03584318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e0eba6c3d8532ebfb469ed5b261949" id="r_aa1e0eba6c3d8532ebfb469ed5b261949"><td class="memTemplParams" colspan="2">template&lt;SquareMatrixOrSquareMatrixSimdType T1, SquareMatrixOrSquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a7fa2d00d342443c20580e84a3b0801af">Internal::HasSquareMatrixType</a>&lt;T1, T2&gt;</td></tr>
<tr class="memitem:aa1e0eba6c3d8532ebfb469ed5b261949"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa1e0eba6c3d8532ebfb469ed5b261949">operator+</a> (const T1 &amp;m1, const T2 &amp;m2) noexcept</td></tr>
<tr class="separator:aa1e0eba6c3d8532ebfb469ed5b261949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac180780e4dbe64adc7088be7c8e4064c" id="r_ac180780e4dbe64adc7088be7c8e4064c"><td class="memTemplParams" colspan="2">template&lt;SquareMatrixSimdType T1, SquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;</td></tr>
<tr class="memitem:ac180780e4dbe64adc7088be7c8e4064c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac180780e4dbe64adc7088be7c8e4064c">operator-</a> (const T1 &amp;m1, const T2 &amp;m2) noexcept</td></tr>
<tr class="separator:ac180780e4dbe64adc7088be7c8e4064c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6527d7bd8ca484e1803e0666742e6bf7" id="r_a6527d7bd8ca484e1803e0666742e6bf7"><td class="memTemplParams" colspan="2">template&lt;SquareMatrixOrSquareMatrixSimdType T1, SquareMatrixOrSquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a7fa2d00d342443c20580e84a3b0801af">Internal::HasSquareMatrixType</a>&lt;T1, T2&gt;</td></tr>
<tr class="memitem:a6527d7bd8ca484e1803e0666742e6bf7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6527d7bd8ca484e1803e0666742e6bf7">operator-</a> (const T1 &amp;m1, const T2 &amp;m2) noexcept</td></tr>
<tr class="separator:a6527d7bd8ca484e1803e0666742e6bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c27345e36bab562bb6400257e6bf9f" id="r_a22c27345e36bab562bb6400257e6bf9f"><td class="memTemplParams" colspan="2">template&lt;SquareMatrixSimdType T1, ArithmeticType T2&gt; </td></tr>
<tr class="memitem:a22c27345e36bab562bb6400257e6bf9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22c27345e36bab562bb6400257e6bf9f">operator*</a> (const T1 &amp;m, const T2 value) noexcept</td></tr>
<tr class="separator:a22c27345e36bab562bb6400257e6bf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97582e6b0faba54403efe1a447814e15" id="r_a97582e6b0faba54403efe1a447814e15"><td class="memTemplParams" colspan="2">template&lt;ArithmeticType T1, SquareMatrixSimdType T2&gt; </td></tr>
<tr class="memitem:a97582e6b0faba54403efe1a447814e15"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97582e6b0faba54403efe1a447814e15">operator*</a> (const T1 value, const T2 &amp;m) noexcept</td></tr>
<tr class="separator:a97582e6b0faba54403efe1a447814e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd38be8b38c54a3d95d6aec83210fe72" id="r_abd38be8b38c54a3d95d6aec83210fe72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd38be8b38c54a3d95d6aec83210fe72">Multiply</a> (const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix1, const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix2)</td></tr>
<tr class="separator:abd38be8b38c54a3d95d6aec83210fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c1e5b9df24737ba75503b9c28f99e4" id="r_a68c1e5b9df24737ba75503b9c28f99e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68c1e5b9df24737ba75503b9c28f99e4">Multiply</a> (const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;matrix1, const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;matrix2)</td></tr>
<tr class="separator:a68c1e5b9df24737ba75503b9c28f99e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c2203568f640ece6355f4c7c410e5f" id="r_a55c2203568f640ece6355f4c7c410e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55c2203568f640ece6355f4c7c410e5f">Multiply</a> (const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd &amp;matrix1, const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd &amp;matrix2)</td></tr>
<tr class="separator:a55c2203568f640ece6355f4c7c410e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81703e59f6620bdff2dda6e9d49ad673" id="r_a81703e59f6620bdff2dda6e9d49ad673"><td class="memTemplParams" colspan="2">template&lt;SquareMatrixSimdType T1, SquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;</td></tr>
<tr class="memitem:a81703e59f6620bdff2dda6e9d49ad673"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81703e59f6620bdff2dda6e9d49ad673">operator*</a> (const T1 &amp;m1, const T2 &amp;m2) noexcept</td></tr>
<tr class="separator:a81703e59f6620bdff2dda6e9d49ad673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea6cd95aab758c786a09b0cbdb80469" id="r_afea6cd95aab758c786a09b0cbdb80469"><td class="memTemplParams" colspan="2">template&lt;SquareMatrixOrSquareMatrixSimdType T1, SquareMatrixOrSquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a7fa2d00d342443c20580e84a3b0801af">Internal::HasSquareMatrixType</a>&lt;T1, T2&gt;</td></tr>
<tr class="memitem:afea6cd95aab758c786a09b0cbdb80469"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afea6cd95aab758c786a09b0cbdb80469">operator*</a> (const T1 &amp;m1, const T2 &amp;m2) noexcept</td></tr>
<tr class="separator:afea6cd95aab758c786a09b0cbdb80469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd5c844d002cef4d06056aa2eac4e96" id="r_abfd5c844d002cef4d06056aa2eac4e96"><td class="memTemplParams" colspan="2">template&lt;SquareMatrixSimdType T1, ArithmeticType T2&gt; </td></tr>
<tr class="memitem:abfd5c844d002cef4d06056aa2eac4e96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfd5c844d002cef4d06056aa2eac4e96">operator/</a> (const T1 &amp;m, const T2 value) noexcept</td></tr>
<tr class="separator:abfd5c844d002cef4d06056aa2eac4e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab056d5780d63e945050659a902d81827" id="r_ab056d5780d63e945050659a902d81827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab056d5780d63e945050659a902d81827">Determinant</a> (const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix)</td></tr>
<tr class="memdesc:ab056d5780d63e945050659a902d81827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of a matrix.  <br /></td></tr>
<tr class="separator:ab056d5780d63e945050659a902d81827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17025574276f6ce1fcc2f3dcfa35a664" id="r_a17025574276f6ce1fcc2f3dcfa35a664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17025574276f6ce1fcc2f3dcfa35a664">Determinant</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4ULL &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a17025574276f6ce1fcc2f3dcfa35a664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of a matrix.  <br /></td></tr>
<tr class="separator:a17025574276f6ce1fcc2f3dcfa35a664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01094c311b40f985bde98581f7dfc177" id="r_a01094c311b40f985bde98581f7dfc177"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01094c311b40f985bde98581f7dfc177">ScalarDeterminant</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix)</td></tr>
<tr class="memdesc:a01094c311b40f985bde98581f7dfc177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of a matrix.  <br /></td></tr>
<tr class="separator:a01094c311b40f985bde98581f7dfc177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27380204bf720dc4efefa91a93cb606" id="r_af27380204bf720dc4efefa91a93cb606"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af27380204bf720dc4efefa91a93cb606">ScalarDeterminant</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;matrix)</td></tr>
<tr class="memdesc:af27380204bf720dc4efefa91a93cb606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of a matrix.  <br /></td></tr>
<tr class="separator:af27380204bf720dc4efefa91a93cb606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a473f32ab8024889945e6efd19a2a7c" id="r_a1a473f32ab8024889945e6efd19a2a7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a473f32ab8024889945e6efd19a2a7c">Determinant</a> (const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;matrix)</td></tr>
<tr class="separator:a1a473f32ab8024889945e6efd19a2a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d260c83ce0585f82db3268998e8003e" id="r_a5d260c83ce0585f82db3268998e8003e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d260c83ce0585f82db3268998e8003e">Determinant</a> (const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;matrix)</td></tr>
<tr class="separator:a5d260c83ce0585f82db3268998e8003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d536fa51dd08c4f743adccffa86db8" id="r_a05d536fa51dd08c4f743adccffa86db8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05d536fa51dd08c4f743adccffa86db8">ScalarDeterminant</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;matrix)</td></tr>
<tr class="separator:a05d536fa51dd08c4f743adccffa86db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6986744d3bf3a56eb85a861eaeea751" id="r_ad6986744d3bf3a56eb85a861eaeea751"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6986744d3bf3a56eb85a861eaeea751">ScalarDeterminant</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;matrix)</td></tr>
<tr class="separator:ad6986744d3bf3a56eb85a861eaeea751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939e394d0b8ff88f3a49916e6a61613e" id="r_a939e394d0b8ff88f3a49916e6a61613e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a939e394d0b8ff88f3a49916e6a61613e">Transpose</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;matrix)</td></tr>
<tr class="separator:a939e394d0b8ff88f3a49916e6a61613e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16aadd31879ae5f4690efbcd41a4cb9" id="r_ac16aadd31879ae5f4690efbcd41a4cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac16aadd31879ae5f4690efbcd41a4cb9">Transpose</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;matrix)</td></tr>
<tr class="separator:ac16aadd31879ae5f4690efbcd41a4cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d770c36bd8c255dc890c69dde5c3db" id="r_af5d770c36bd8c255dc890c69dde5c3db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d770c36bd8c255dc890c69dde5c3db">Transpose</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix)</td></tr>
<tr class="memdesc:af5d770c36bd8c255dc890c69dde5c3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the transpose of the matrix.  <br /></td></tr>
<tr class="separator:af5d770c36bd8c255dc890c69dde5c3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c85009aa20ed3fbd0ccdce93996ca0" id="r_af4c85009aa20ed3fbd0ccdce93996ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4c85009aa20ed3fbd0ccdce93996ca0">Transpose</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;matrix)</td></tr>
<tr class="memdesc:af4c85009aa20ed3fbd0ccdce93996ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the transpose of the matrix.  <br /></td></tr>
<tr class="separator:af4c85009aa20ed3fbd0ccdce93996ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddad3200d4342e357638ca53f579b0a" id="r_a8ddad3200d4342e357638ca53f579b0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ddad3200d4342e357638ca53f579b0a">Inverse</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix, typename <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd *determinant=nullptr)</td></tr>
<tr class="memdesc:a8ddad3200d4342e357638ca53f579b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of the matrix.  <br /></td></tr>
<tr class="separator:a8ddad3200d4342e357638ca53f579b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427ec98ac1ee40c09ee02c50b20476b0" id="r_a427ec98ac1ee40c09ee02c50b20476b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a427ec98ac1ee40c09ee02c50b20476b0">Inverse</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;matrix, typename <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd *determinant=nullptr)</td></tr>
<tr class="memdesc:a427ec98ac1ee40c09ee02c50b20476b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of the matrix.  <br /></td></tr>
<tr class="separator:a427ec98ac1ee40c09ee02c50b20476b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245cb392ca77a55109d46c081cdeb855" id="r_a245cb392ca77a55109d46c081cdeb855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a245cb392ca77a55109d46c081cdeb855">Inverse</a> (const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;matrix, typename <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd *determinant=nullptr)</td></tr>
<tr class="separator:a245cb392ca77a55109d46c081cdeb855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1c9328150d1bf8244fdd400c241ef0" id="r_a8f1c9328150d1bf8244fdd400c241ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f1c9328150d1bf8244fdd400c241ef0">Inverse</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;matrix, typename <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd *determinant=nullptr)</td></tr>
<tr class="separator:a8f1c9328150d1bf8244fdd400c241ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eb9b47d3f2bf259f6ae5718e4561fe" id="r_a42eb9b47d3f2bf259f6ae5718e4561fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42eb9b47d3f2bf259f6ae5718e4561fe">Transpose</a> (const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd &amp;matrix)</td></tr>
<tr class="separator:a42eb9b47d3f2bf259f6ae5718e4561fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9562e78d43d89db1bd94214055e5a2" id="r_aef9562e78d43d89db1bd94214055e5a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef9562e78d43d89db1bd94214055e5a2">Transpose</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt; &amp;matrix)</td></tr>
<tr class="separator:aef9562e78d43d89db1bd94214055e5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca0317bd4a434340786be3c4ded4462" id="r_a5ca0317bd4a434340786be3c4ded4462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 2 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ca0317bd4a434340786be3c4ded4462">Determinant</a> (const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd &amp;matrix)</td></tr>
<tr class="separator:a5ca0317bd4a434340786be3c4ded4462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75812fb4e7f9f181be32dcf8f11a3f6" id="r_af75812fb4e7f9f181be32dcf8f11a3f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 2 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af75812fb4e7f9f181be32dcf8f11a3f6">Determinant</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt; &amp;matrix)</td></tr>
<tr class="separator:af75812fb4e7f9f181be32dcf8f11a3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeab1d037de4f8c9abc1230c03b9df97" id="r_adeab1d037de4f8c9abc1230c03b9df97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeab1d037de4f8c9abc1230c03b9df97">Inverse</a> (const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd &amp;matrix, typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd *determinant=nullptr)</td></tr>
<tr class="separator:adeab1d037de4f8c9abc1230c03b9df97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ea12c2c0d6108e9ae341b965000b9" id="r_a079ea12c2c0d6108e9ae341b965000b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a079ea12c2c0d6108e9ae341b965000b9">Inverse</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt; &amp;matrix)</td></tr>
<tr class="separator:a079ea12c2c0d6108e9ae341b965000b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec715c57979a3c11c339e26c248e6794" id="r_aec715c57979a3c11c339e26c248e6794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec715c57979a3c11c339e26c248e6794">Translation</a> (float offsetX, float offsetY, float offsetZ)</td></tr>
<tr class="memdesc:aec715c57979a3c11c339e26c248e6794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a translation matrix using the provided offsets.  <br /></td></tr>
<tr class="separator:aec715c57979a3c11c339e26c248e6794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2108dc0b27fba4880795227e5b8941d9" id="r_a2108dc0b27fba4880795227e5b8941d9"><td class="memTemplParams" colspan="2">template&lt;SimdType S&gt; <br />
requires ( S::Size &gt; 2 ) &amp;&amp; std::is_same_v&lt;typename S::value_type, float&gt;</td></tr>
<tr class="memitem:a2108dc0b27fba4880795227e5b8941d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2108dc0b27fba4880795227e5b8941d9">Translation</a> (const S &amp;offsets)</td></tr>
<tr class="memdesc:a2108dc0b27fba4880795227e5b8941d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a translation matrix using the provided offsets.  <br /></td></tr>
<tr class="separator:a2108dc0b27fba4880795227e5b8941d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98716baa55ecf7bff99a5b2b12fc5077" id="r_a98716baa55ecf7bff99a5b2b12fc5077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98716baa55ecf7bff99a5b2b12fc5077">Translation</a> (float offsetX, float offsetY)</td></tr>
<tr class="separator:a98716baa55ecf7bff99a5b2b12fc5077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b42a2a600b71648715f5a4aa24f7658" id="r_a6b42a2a600b71648715f5a4aa24f7658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b42a2a600b71648715f5a4aa24f7658">Scaling</a> (float scaleX, float scaleY, float scaleZ)</td></tr>
<tr class="memdesc:a6b42a2a600b71648715f5a4aa24f7658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transformation matrix for scaling along the x-axis, y-axis, and z-axis.  <br /></td></tr>
<tr class="separator:a6b42a2a600b71648715f5a4aa24f7658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958995f0dfc1740ec052cc91d158b4bb" id="r_a958995f0dfc1740ec052cc91d158b4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a958995f0dfc1740ec052cc91d158b4bb">Scaling</a> (float scale)</td></tr>
<tr class="memdesc:a958995f0dfc1740ec052cc91d158b4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transformation matrix for scaling along the x-axis, y-axis, and z-axis.  <br /></td></tr>
<tr class="separator:a958995f0dfc1740ec052cc91d158b4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb67684dc0e1c65a5551f8182f6bc7f1" id="r_aeb67684dc0e1c65a5551f8182f6bc7f1"><td class="memTemplParams" colspan="2">template&lt;SimdType S&gt; <br />
requires ( S::Size &gt; 2 )</td></tr>
<tr class="memitem:aeb67684dc0e1c65a5551f8182f6bc7f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeb67684dc0e1c65a5551f8182f6bc7f1">Scaling</a> (const S &amp;v) noexcept</td></tr>
<tr class="memdesc:aeb67684dc0e1c65a5551f8182f6bc7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transformation matrix for scaling along the x-axis, y-axis, and z-axis.  <br /></td></tr>
<tr class="separator:aeb67684dc0e1c65a5551f8182f6bc7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34301223edef4910b4f41aa676e1e3fe" id="r_a34301223edef4910b4f41aa676e1e3fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34301223edef4910b4f41aa676e1e3fe">Scaling</a> (float scaleX, float scaleY)</td></tr>
<tr class="separator:a34301223edef4910b4f41aa676e1e3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cf1666ad5fb3e80caadaf396f12e85" id="r_ad5cf1666ad5fb3e80caadaf396f12e85"><td class="memTemplParams" colspan="2">template&lt;SimdType S&gt; <br />
requires ( S::Size &gt; 2 )</td></tr>
<tr class="memitem:ad5cf1666ad5fb3e80caadaf396f12e85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5cf1666ad5fb3e80caadaf396f12e85">Rotation</a> (const S &amp;v) noexcept</td></tr>
<tr class="memdesc:ad5cf1666ad5fb3e80caadaf396f12e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transformation matrix that rotates about the y-axis, then the x-axis, and finally the z-axis.  <br /></td></tr>
<tr class="separator:ad5cf1666ad5fb3e80caadaf396f12e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ba4b5556e837c9fb76989979bbbad8" id="r_ab6ba4b5556e837c9fb76989979bbbad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6ba4b5556e837c9fb76989979bbbad8">Rotation</a> (float xAxisRotation, float yAxisRotation, float zAxisRotation) noexcept</td></tr>
<tr class="memdesc:ab6ba4b5556e837c9fb76989979bbbad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transformation matrix that rotates about the y-axis, then the x-axis, and finally the z-axis.  <br /></td></tr>
<tr class="separator:ab6ba4b5556e837c9fb76989979bbbad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76601f15559c23bc8a25706bab103e6" id="r_ab76601f15559c23bc8a25706bab103e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab76601f15559c23bc8a25706bab103e6">RotationX</a> (float angle) noexcept</td></tr>
<tr class="memdesc:ab76601f15559c23bc8a25706bab103e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix that rotates around the x-axis.  <br /></td></tr>
<tr class="separator:ab76601f15559c23bc8a25706bab103e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb97478680f9efe69655e750d4af94c" id="r_accb97478680f9efe69655e750d4af94c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accb97478680f9efe69655e750d4af94c">RotationY</a> (float angle) noexcept</td></tr>
<tr class="memdesc:accb97478680f9efe69655e750d4af94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix that rotates around the y-axis.  <br /></td></tr>
<tr class="separator:accb97478680f9efe69655e750d4af94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085be3848f9e107b57849f9ebc6cc351" id="r_a085be3848f9e107b57849f9ebc6cc351"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a085be3848f9e107b57849f9ebc6cc351">RotationZ</a> (float angle) noexcept</td></tr>
<tr class="memdesc:a085be3848f9e107b57849f9ebc6cc351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix that rotates around the z-axis.  <br /></td></tr>
<tr class="separator:a085be3848f9e107b57849f9ebc6cc351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f1abed5223b2f5db7aca783ee50a4d" id="r_aa1f1abed5223b2f5db7aca783ee50a4d"><td class="memTemplParams" colspan="2">template&lt;SimdType S&gt; <br />
requires ( S::Size &gt; 2 )</td></tr>
<tr class="memitem:aa1f1abed5223b2f5db7aca783ee50a4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa1f1abed5223b2f5db7aca783ee50a4d">RotationNormal</a> (const S &amp;normalizedAxis, float angle) noexcept</td></tr>
<tr class="memdesc:aa1f1abed5223b2f5db7aca783ee50a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix that rotates around a normalized vector.  <br /></td></tr>
<tr class="separator:aa1f1abed5223b2f5db7aca783ee50a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e20fa3c7b4ab363aafbc4796d52d1c" id="r_a34e20fa3c7b4ab363aafbc4796d52d1c"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S&gt; <br />
requires ( S::Size &gt; 2 )</td></tr>
<tr class="memitem:a34e20fa3c7b4ab363aafbc4796d52d1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a34e20fa3c7b4ab363aafbc4796d52d1c">RotationAxis</a> (const S &amp;axis, float angle) noexcept</td></tr>
<tr class="memdesc:a34e20fa3c7b4ab363aafbc4796d52d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix that rotates around an arbitrary axis.  <br /></td></tr>
<tr class="separator:a34e20fa3c7b4ab363aafbc4796d52d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf9abd7b8eed5202cbacba56d49627d" id="r_afaf9abd7b8eed5202cbacba56d49627d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaf9abd7b8eed5202cbacba56d49627d">Rotation</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a>&lt; float &gt;::Simd &amp;q) noexcept</td></tr>
<tr class="memdesc:afaf9abd7b8eed5202cbacba56d49627d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotation matrix from a quaternion.  <br /></td></tr>
<tr class="separator:afaf9abd7b8eed5202cbacba56d49627d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3028f2700ba6f376096a060dc0cdc00" id="r_ac3028f2700ba6f376096a060dc0cdc00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3028f2700ba6f376096a060dc0cdc00">Rotation</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a>&lt; float &gt; &amp;q) noexcept</td></tr>
<tr class="memdesc:ac3028f2700ba6f376096a060dc0cdc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotation matrix from a quaternion.  <br /></td></tr>
<tr class="separator:ac3028f2700ba6f376096a060dc0cdc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2641419ead7bb00457bd4d84eccb4b" id="r_aad2641419ead7bb00457bd4d84eccb4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad2641419ead7bb00457bd4d84eccb4b">RotationQuaternion</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a>&lt; float &gt;::Simd &amp;q) noexcept</td></tr>
<tr class="memdesc:aad2641419ead7bb00457bd4d84eccb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotation matrix from a quaternion.  <br /></td></tr>
<tr class="separator:aad2641419ead7bb00457bd4d84eccb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676b83fba8557911e19e9fe55bd9bb7b" id="r_a676b83fba8557911e19e9fe55bd9bb7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a676b83fba8557911e19e9fe55bd9bb7b">RotationQuaternion</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a>&lt; float &gt; &amp;q) noexcept</td></tr>
<tr class="memdesc:a676b83fba8557911e19e9fe55bd9bb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotation matrix from a quaternion.  <br /></td></tr>
<tr class="separator:a676b83fba8557911e19e9fe55bd9bb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4eb60720db709f8ac7ea776c95bed89" id="r_ab4eb60720db709f8ac7ea776c95bed89"><td class="memTemplParams" colspan="2">template&lt;PointOrPointSimdType PointT, QuaternionOrQuaternionSimdType QuaternionT, VectorOrVectorSimdType VectorT&gt; <br />
requires ( PointT::Size == 3 ) &amp;&amp; ( VectorT::Size == 3 ) &amp;&amp; std::is_same_v&lt;typename PointT::value_type, typename QuaternionT::value_type&gt;&amp;&amp; std::is_same_v&lt;typename PointT::value_type, typename VectorT::value_type&gt;</td></tr>
<tr class="memitem:ab4eb60720db709f8ac7ea776c95bed89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; typenamePointT::value_type, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4eb60720db709f8ac7ea776c95bed89">TransformationMatrix</a> (const PointT &amp;scalingOrigin, const QuaternionT &amp;scalingOrientationQuaternion, const VectorT &amp;scaling, const PointT &amp;rotationOrigin, const QuaternionT &amp;rotationQuaternion, const VectorT &amp;translation) noexcept</td></tr>
<tr class="memdesc:ab4eb60720db709f8ac7ea776c95bed89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transformation matrix.  <br /></td></tr>
<tr class="separator:ab4eb60720db709f8ac7ea776c95bed89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe6f75ae996d8972718250ee8c579d8" id="r_a0fe6f75ae996d8972718250ee8c579d8"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, QuaternionOrQuaternionSimdType U, SimdOrTupleType W&gt; <br />
requires ( S::Size &gt; 2 ) &amp;&amp; ( T::Size &gt; 2 ) &amp;&amp; ( W::Size &gt; 2 ) &amp;&amp; std::is_same_v&lt;typename S::value_type, typename T::value_type&gt;&amp;&amp; std::is_same_v&lt;typename S::value_type, typename U::value_type&gt;&amp;&amp; std::is_same_v&lt;typename S::value_type, typename W::value_type&gt;</td></tr>
<tr class="memitem:a0fe6f75ae996d8972718250ee8c579d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; typenameS::value_type, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0fe6f75ae996d8972718250ee8c579d8">AffineTransformationMatrix</a> (const S &amp;scaling, const T &amp;rotationOrigin, const U &amp;rotationQuaternion, const W &amp;translation) noexcept</td></tr>
<tr class="memdesc:a0fe6f75ae996d8972718250ee8c579d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine transformation matrix.  <br /></td></tr>
<tr class="separator:a0fe6f75ae996d8972718250ee8c579d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbd8de9377706d9a75eca81c33b3740" id="r_a5dbd8de9377706d9a75eca81c33b3740"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt; &amp;&amp; ( S::Size == 3 )</td></tr>
<tr class="memitem:a5dbd8de9377706d9a75eca81c33b3740"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; typenameS::value_type, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5dbd8de9377706d9a75eca81c33b3740">LookTo</a> (const S &amp;cameraPosition, const T &amp;cameraDirection, const U &amp;upDirection) noexcept</td></tr>
<tr class="memdesc:a5dbd8de9377706d9a75eca81c33b3740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view matrix using the left-handed coordinate system for the provided camera position, camera direction, and up direction.  <br /></td></tr>
<tr class="separator:a5dbd8de9377706d9a75eca81c33b3740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c8a2682c3f9ca44bf2b39c1bc65365" id="r_ab3c8a2682c3f9ca44bf2b39c1bc65365"><td class="memTemplParams" colspan="2">template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt; &amp;&amp; ( S::Size == 3 )</td></tr>
<tr class="memitem:ab3c8a2682c3f9ca44bf2b39c1bc65365"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; typenameS::value_type, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab3c8a2682c3f9ca44bf2b39c1bc65365">LookAt</a> (const S &amp;cameraPosition, const T &amp;focusPosition, const U &amp;upDirection) noexcept</td></tr>
<tr class="memdesc:ab3c8a2682c3f9ca44bf2b39c1bc65365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view matrix using the left-handed coordinate system for the provided camera position, focal point, and up direction.  <br /></td></tr>
<tr class="separator:ab3c8a2682c3f9ca44bf2b39c1bc65365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45359349a6edc0cd6ef5d06e67768da9" id="r_a45359349a6edc0cd6ef5d06e67768da9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;T&gt;</td></tr>
<tr class="memitem:a45359349a6edc0cd6ef5d06e67768da9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; T, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45359349a6edc0cd6ef5d06e67768da9">PerspectiveProjection</a> (T viewWidth, T viewHeight, T nearZ, T farZ) noexcept</td></tr>
<tr class="memdesc:a45359349a6edc0cd6ef5d06e67768da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a left-handed perspective projection matrix.  <br /></td></tr>
<tr class="separator:a45359349a6edc0cd6ef5d06e67768da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50a969107d9e9d2fcefa2d004b1f883" id="r_ab50a969107d9e9d2fcefa2d004b1f883"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;T&gt;</td></tr>
<tr class="memitem:ab50a969107d9e9d2fcefa2d004b1f883"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; T, 4 &gt;::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab50a969107d9e9d2fcefa2d004b1f883">PerspectiveFovProjection</a> (T fovAngleY, T aspectRatio, T nearZ, T farZ) noexcept</td></tr>
<tr class="memdesc:ab50a969107d9e9d2fcefa2d004b1f883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a left-handed perspective projection matrix based on a field of view.  <br /></td></tr>
<tr class="separator:ab50a969107d9e9d2fcefa2d004b1f883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada263e6c5f2aeb53798c204ccb03c95d" id="r_ada263e6c5f2aeb53798c204ccb03c95d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 2 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada263e6c5f2aeb53798c204ccb03c95d">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 2 &gt;::Simd &amp;v, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;matrix) noexcept</td></tr>
<tr class="memdesc:ada263e6c5f2aeb53798c204ccb03c95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a 2D vector by a matrix.  <br /></td></tr>
<tr class="separator:ada263e6c5f2aeb53798c204ccb03c95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931e9f6b261bebeab93e34fab710bca1" id="r_a931e9f6b261bebeab93e34fab710bca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a931e9f6b261bebeab93e34fab710bca1">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd &amp;v, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix) noexcept</td></tr>
<tr class="memdesc:a931e9f6b261bebeab93e34fab710bca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a 3D vector.  <br /></td></tr>
<tr class="separator:a931e9f6b261bebeab93e34fab710bca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7ba1c29b1bb2b88b48c4b446211b0d" id="r_aad7ba1c29b1bb2b88b48c4b446211b0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad7ba1c29b1bb2b88b48c4b446211b0d">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt; &amp;v, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix) noexcept</td></tr>
<tr class="memdesc:aad7ba1c29b1bb2b88b48c4b446211b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a 3D vector.  <br /></td></tr>
<tr class="separator:aad7ba1c29b1bb2b88b48c4b446211b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0027cca999b58c2dfa35f96bf7ed54" id="r_a0d0027cca999b58c2dfa35f96bf7ed54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d0027cca999b58c2dfa35f96bf7ed54">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd &amp;v, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:a0d0027cca999b58c2dfa35f96bf7ed54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a 3D vector.  <br /></td></tr>
<tr class="separator:a0d0027cca999b58c2dfa35f96bf7ed54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752a3cc24e6d697bea03ab245bc15bf9" id="r_a752a3cc24e6d697bea03ab245bc15bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a752a3cc24e6d697bea03ab245bc15bf9">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt; &amp;v, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:a752a3cc24e6d697bea03ab245bc15bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a 3D vector.  <br /></td></tr>
<tr class="separator:a752a3cc24e6d697bea03ab245bc15bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe7a244ec792a5e5f027c7ffd85987c" id="r_a5fe7a244ec792a5e5f027c7ffd85987c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fe7a244ec792a5e5f027c7ffd85987c">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd &amp;v, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix) noexcept</td></tr>
<tr class="separator:a5fe7a244ec792a5e5f027c7ffd85987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b38f8116123a40bc6f2016787deca2" id="r_ac5b38f8116123a40bc6f2016787deca2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple2.html#aec4a2899d234894c2f377ea8e5a33857">Point2f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5b38f8116123a40bc6f2016787deca2">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_tuple2.html#aec4a2899d234894c2f377ea8e5a33857">Point2f::Simd</a> &amp;p, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;matrix) noexcept</td></tr>
<tr class="memdesc:ac5b38f8116123a40bc6f2016787deca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a 2D coordinate.  <br /></td></tr>
<tr class="separator:ac5b38f8116123a40bc6f2016787deca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1d5383f7ec894eb0ef95eea5fe83ed" id="r_aba1d5383f7ec894eb0ef95eea5fe83ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba1d5383f7ec894eb0ef95eea5fe83ed">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a> &amp;p, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix) noexcept</td></tr>
<tr class="memdesc:aba1d5383f7ec894eb0ef95eea5fe83ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a 3D coordinate.  <br /></td></tr>
<tr class="separator:aba1d5383f7ec894eb0ef95eea5fe83ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450ad7a7a92c53a0695da972870db6d8" id="r_a450ad7a7a92c53a0695da972870db6d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a450ad7a7a92c53a0695da972870db6d8">Transform</a> (const <a class="el" href="#a3e227c35130c9e7e322ead53eeff7b6e">Point3f</a> &amp;p, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix) noexcept</td></tr>
<tr class="memdesc:a450ad7a7a92c53a0695da972870db6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a 3D coordinate.  <br /></td></tr>
<tr class="separator:a450ad7a7a92c53a0695da972870db6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae851e035a0e3787898e33ef6900738d2" id="r_ae851e035a0e3787898e33ef6900738d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae851e035a0e3787898e33ef6900738d2">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a> &amp;p, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:ae851e035a0e3787898e33ef6900738d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a 3D coordinate.  <br /></td></tr>
<tr class="separator:ae851e035a0e3787898e33ef6900738d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb29887a16e7d057515d7695eedf40b" id="r_a1eb29887a16e7d057515d7695eedf40b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eb29887a16e7d057515d7695eedf40b">Transform</a> (const <a class="el" href="#a3e227c35130c9e7e322ead53eeff7b6e">Point3f</a> &amp;p, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:a1eb29887a16e7d057515d7695eedf40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a 3D coordinate.  <br /></td></tr>
<tr class="separator:a1eb29887a16e7d057515d7695eedf40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36fea0bb34d938288620a56829fae22" id="r_ad36fea0bb34d938288620a56829fae22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad36fea0bb34d938288620a56829fae22">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> &amp;n, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;matrix) noexcept</td></tr>
<tr class="memdesc:ad36fea0bb34d938288620a56829fae22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a normal.  <br /></td></tr>
<tr class="separator:ad36fea0bb34d938288620a56829fae22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b0f7ad7e7c00da3461736b995b13dc" id="r_a27b0f7ad7e7c00da3461736b995b13dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27b0f7ad7e7c00da3461736b995b13dc">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> &amp;n, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix) noexcept</td></tr>
<tr class="memdesc:a27b0f7ad7e7c00da3461736b995b13dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a normal.  <br /></td></tr>
<tr class="separator:a27b0f7ad7e7c00da3461736b995b13dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224fc718e1811160e2ff02db34d2f07d" id="r_a224fc718e1811160e2ff02db34d2f07d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a224fc718e1811160e2ff02db34d2f07d">Transform</a> (const <a class="el" href="#a43e3e7d66212411e17fb90bdadba1354">Normal3f</a> &amp;n, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;matrix) noexcept</td></tr>
<tr class="memdesc:a224fc718e1811160e2ff02db34d2f07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a normal.  <br /></td></tr>
<tr class="separator:a224fc718e1811160e2ff02db34d2f07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65c6ba4435a6c75062be956ec90026f" id="r_ac65c6ba4435a6c75062be956ec90026f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac65c6ba4435a6c75062be956ec90026f">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> &amp;n, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:ac65c6ba4435a6c75062be956ec90026f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a normal.  <br /></td></tr>
<tr class="separator:ac65c6ba4435a6c75062be956ec90026f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab861d58fd40d8bbbb9e5277b384410be" id="r_ab861d58fd40d8bbbb9e5277b384410be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab861d58fd40d8bbbb9e5277b384410be">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> &amp;n, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:ab861d58fd40d8bbbb9e5277b384410be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a normal.  <br /></td></tr>
<tr class="separator:ab861d58fd40d8bbbb9e5277b384410be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fb33758c5743a91b4a7eac45313d40" id="r_a87fb33758c5743a91b4a7eac45313d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87fb33758c5743a91b4a7eac45313d40">Transform</a> (const <a class="el" href="#a43e3e7d66212411e17fb90bdadba1354">Normal3f</a> &amp;n, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;matrix) noexcept</td></tr>
<tr class="memdesc:a87fb33758c5743a91b4a7eac45313d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a transformation matrix to a normal.  <br /></td></tr>
<tr class="separator:a87fb33758c5743a91b4a7eac45313d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180c8349b261c441cc6daa689307d41e" id="r_a180c8349b261c441cc6daa689307d41e"><td class="memTemplParams" colspan="2">template&lt;SimdType S, typename FloatT  = S::value_type, typename MatrixT  = typename SquareMatrix&lt;FloatT, 4&gt;::Simd&gt; </td></tr>
<tr class="memitem:a180c8349b261c441cc6daa689307d41e"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a180c8349b261c441cc6daa689307d41e">Project</a> (const S &amp;v, FloatT viewportX, FloatT viewportY, FloatT viewportWidth, FloatT viewportHeight, FloatT viewportMinZ, FloatT viewportMaxZ, const MatrixT &amp;projection, const MatrixT &amp;viewTransform, const MatrixT &amp;WorldTransform) noexcept</td></tr>
<tr class="memdesc:a180c8349b261c441cc6daa689307d41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects a 3D coordinate from object space into screen space.  <br /></td></tr>
<tr class="separator:a180c8349b261c441cc6daa689307d41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dafb1c605411399bbba722ee3e04ee" id="r_a68dafb1c605411399bbba722ee3e04ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68dafb1c605411399bbba722ee3e04ee">Decompose</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;matrix, <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Vector3f::Simd</a> *outScale, <a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a>&lt; float &gt;::Simd *outRotQuat, <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Vector3f::Simd</a> *outTrans) noexcept</td></tr>
<tr class="separator:a68dafb1c605411399bbba722ee3e04ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e39bf90eb8a112d92e3e5f3aebf4d5e" id="r_a9e39bf90eb8a112d92e3e5f3aebf4d5e"><td class="memTemplParams" colspan="2">template&lt;PlaneSimdType T&gt; </td></tr>
<tr class="memitem:a9e39bf90eb8a112d92e3e5f3aebf4d5e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e39bf90eb8a112d92e3e5f3aebf4d5e">Normalize</a> (const T &amp;plane) noexcept</td></tr>
<tr class="separator:a9e39bf90eb8a112d92e3e5f3aebf4d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc72b4e27e5b2be1f9a01ad12373a59" id="r_a7dc72b4e27e5b2be1f9a01ad12373a59"><td class="memTemplParams" colspan="2">template&lt;PlaneType T&gt; </td></tr>
<tr class="memitem:a7dc72b4e27e5b2be1f9a01ad12373a59"><td class="memTemplItemLeft" align="right" valign="top">T::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7dc72b4e27e5b2be1f9a01ad12373a59">Normalize</a> (const T &amp;plane) noexcept</td></tr>
<tr class="separator:a7dc72b4e27e5b2be1f9a01ad12373a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3322322c3cf836f49ec67026997b6a1" id="r_ac3322322c3cf836f49ec67026997b6a1"><td class="memTemplParams" colspan="2">template&lt;PlaneSimdType T&gt; </td></tr>
<tr class="memitem:ac3322322c3cf836f49ec67026997b6a1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3322322c3cf836f49ec67026997b6a1">FastNormalize</a> (const T &amp;plane) noexcept</td></tr>
<tr class="separator:ac3322322c3cf836f49ec67026997b6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9230cc0fe52a8708cdced54d8ddc121" id="r_af9230cc0fe52a8708cdced54d8ddc121"><td class="memTemplParams" colspan="2">template&lt;PlaneType T&gt; </td></tr>
<tr class="memitem:af9230cc0fe52a8708cdced54d8ddc121"><td class="memTemplItemLeft" align="right" valign="top">T::Simd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9230cc0fe52a8708cdced54d8ddc121">FastNormalize</a> (const T &amp;plane) noexcept</td></tr>
<tr class="separator:af9230cc0fe52a8708cdced54d8ddc121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03db02bfb723a9ee8f38466c25a870eb" id="r_a03db02bfb723a9ee8f38466c25a870eb"><td class="memTemplParams" colspan="2">template&lt;PlaneSimdType P, VectorSimdType V&gt; <br />
requires std::is_same_v&lt;typename P::value_type, typename V::value_type&gt; &amp;&amp; ( V::Size &gt; 2 )</td></tr>
<tr class="memitem:a03db02bfb723a9ee8f38466c25a870eb"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03db02bfb723a9ee8f38466c25a870eb">Dot</a> (const P &amp;plane, const V &amp;v)</td></tr>
<tr class="separator:a03db02bfb723a9ee8f38466c25a870eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4fd2ee195df3f51c259fc4e475581d" id="r_a0f4fd2ee195df3f51c259fc4e475581d"><td class="memTemplParams" colspan="2">template&lt;PlaneSimdType P, NormalSimdType N&gt; <br />
requires std::is_same_v&lt;typename P::value_type, typename N::value_type&gt; &amp;&amp; ( N::Size &gt; 2 )</td></tr>
<tr class="memitem:a0f4fd2ee195df3f51c259fc4e475581d"><td class="memTemplItemLeft" align="right" valign="top">N&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f4fd2ee195df3f51c259fc4e475581d">Dot</a> (const P &amp;plane, const N &amp;normal)</td></tr>
<tr class="separator:a0f4fd2ee195df3f51c259fc4e475581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed35007e0c5073bfb1c4ee2dcb6d5dbb" id="r_aed35007e0c5073bfb1c4ee2dcb6d5dbb"><td class="memTemplParams" colspan="2">template&lt;PlaneSimdType P, PointSimdType PT&gt; </td></tr>
<tr class="memitem:aed35007e0c5073bfb1c4ee2dcb6d5dbb"><td class="memTemplItemLeft" align="right" valign="top">PT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed35007e0c5073bfb1c4ee2dcb6d5dbb">Dot</a> (const P &amp;plane, const PT &amp;point)</td></tr>
<tr class="separator:aed35007e0c5073bfb1c4ee2dcb6d5dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7199183ff90ab7a9cb9f547107b15f6" id="r_ad7199183ff90ab7a9cb9f547107b15f6"><td class="memTemplParams" colspan="2">template&lt;Internal::VectorNormalOrPointSimdType T, PlaneSimdType P&gt; </td></tr>
<tr class="memitem:ad7199183ff90ab7a9cb9f547107b15f6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7199183ff90ab7a9cb9f547107b15f6">Dot</a> (const T &amp;v, const P &amp;plane)</td></tr>
<tr class="separator:ad7199183ff90ab7a9cb9f547107b15f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7a3c2ca0c0e99ed82e08fdc5581c9b" id="r_a9d7a3c2ca0c0e99ed82e08fdc5581c9b"><td class="memTemplParams" colspan="2">template&lt;PlaneType P, Internal::VectorNormalOrPointType T&gt; </td></tr>
<tr class="memitem:a9d7a3c2ca0c0e99ed82e08fdc5581c9b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d7a3c2ca0c0e99ed82e08fdc5581c9b">Dot</a> (const P &amp;plane, const T &amp;v)</td></tr>
<tr class="separator:a9d7a3c2ca0c0e99ed82e08fdc5581c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a588045303691a8c1941c0d8343998" id="r_a17a588045303691a8c1941c0d8343998"><td class="memTemplParams" colspan="2">template&lt;PlaneType P, PointSimdType PT&gt; </td></tr>
<tr class="memitem:a17a588045303691a8c1941c0d8343998"><td class="memTemplItemLeft" align="right" valign="top">PT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17a588045303691a8c1941c0d8343998">Intersect</a> (const P &amp;plane, const PT &amp;linePoint1, const PT &amp;linePoint2) noexcept</td></tr>
<tr class="separator:a17a588045303691a8c1941c0d8343998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c7d0cf56edc18072b8b2f0652000e9" id="r_a03c7d0cf56edc18072b8b2f0652000e9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a>, <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03c7d0cf56edc18072b8b2f0652000e9">Intersect</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_plane.html">Plane</a>&lt; float &gt;::Simd &amp;plane1, const <a class="el" href="class_harlinn_1_1_math_1_1_plane.html">Plane</a>&lt; float &gt;::Simd &amp;plane2) noexcept</td></tr>
<tr class="separator:a03c7d0cf56edc18072b8b2f0652000e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922f783d63c073da7ef485f264f875dd" id="r_a922f783d63c073da7ef485f264f875dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_harlinn_1_1_math_1_1_plane.html">Plane</a>&lt; float &gt;::Simd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a922f783d63c073da7ef485f264f875dd">Transform</a> (const <a class="el" href="class_harlinn_1_1_math_1_1_plane.html">Plane</a>&lt; float &gt;::Simd &amp;plane, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;transformationMatrix) noexcept</td></tr>
<tr class="separator:a922f783d63c073da7ef485f264f875dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caf8691a3ed0400c953a09da1bb9662" id="r_a3caf8691a3ed0400c953a09da1bb9662"><td class="memTemplParams" colspan="2">template&lt;typename CharT , size_t N&gt; </td></tr>
<tr class="memitem:a3caf8691a3ed0400c953a09da1bb9662"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3caf8691a3ed0400c953a09da1bb9662">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT &gt; &amp;os, const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, N &gt; &amp;value)</td></tr>
<tr class="separator:a3caf8691a3ed0400c953a09da1bb9662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7ac8e15ecd635df241596bc5500b24" id="r_a5a7ac8e15ecd635df241596bc5500b24"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a7ac8e15ecd635df241596bc5500b24">Min</a> (const <a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a> &amp;first, const <a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a> &amp;second)</td></tr>
<tr class="separator:a5a7ac8e15ecd635df241596bc5500b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa49e0c3b68be42b68b4232b4322b72" id="r_a1aa49e0c3b68be42b68b4232b4322b72"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1aa49e0c3b68be42b68b4232b4322b72">Max</a> (const <a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a> &amp;first, const <a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a> &amp;second)</td></tr>
<tr class="separator:a1aa49e0c3b68be42b68b4232b4322b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269b27b08bf6a21ba5cc074dc6687725" id="r_a269b27b08bf6a21ba5cc074dc6687725"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a269b27b08bf6a21ba5cc074dc6687725">Min</a> (const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a> &amp;first, const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a> &amp;second)</td></tr>
<tr class="separator:a269b27b08bf6a21ba5cc074dc6687725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdec897d69d6865dcb74849e4a630781" id="r_abdec897d69d6865dcb74849e4a630781"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdec897d69d6865dcb74849e4a630781">Max</a> (const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a> &amp;first, const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a> &amp;second)</td></tr>
<tr class="separator:abdec897d69d6865dcb74849e4a630781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c6141c2fd2f95514007f63427018d4" id="r_a32c6141c2fd2f95514007f63427018d4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32c6141c2fd2f95514007f63427018d4">Min</a> (const <a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a> &amp;first, const <a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a> &amp;second)</td></tr>
<tr class="separator:a32c6141c2fd2f95514007f63427018d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80a0ffc11f73133b75b31634a05807c" id="r_ad80a0ffc11f73133b75b31634a05807c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad80a0ffc11f73133b75b31634a05807c">Max</a> (const <a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a> &amp;first, const <a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a> &amp;second)</td></tr>
<tr class="separator:ad80a0ffc11f73133b75b31634a05807c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bbd01608f5091cd678efdd56b216b3" id="r_a56bbd01608f5091cd678efdd56b216b3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56bbd01608f5091cd678efdd56b216b3">Min</a> (const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a> &amp;first, const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a> &amp;second)</td></tr>
<tr class="separator:a56bbd01608f5091cd678efdd56b216b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066c9764bb82bbb23ba88bb5215ded01" id="r_a066c9764bb82bbb23ba88bb5215ded01"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a066c9764bb82bbb23ba88bb5215ded01">Max</a> (const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a> &amp;first, const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a> &amp;second)</td></tr>
<tr class="separator:a066c9764bb82bbb23ba88bb5215ded01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4ee32222d27fda36d433fb6dbbfedc" id="r_a0d4ee32222d27fda36d433fb6dbbfedc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_point_t.html">Harlinn::Windows::PointT</a>&gt;</td></tr>
<tr class="memitem:a0d4ee32222d27fda36d433fb6dbbfedc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_cvref_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d4ee32222d27fda36d433fb6dbbfedc">Clamp</a> (T value, T minimumValue, T maximumValue) noexcept</td></tr>
<tr class="separator:a0d4ee32222d27fda36d433fb6dbbfedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfc06b14ebf76aeb2b60a46f591a44a" id="r_afbfc06b14ebf76aeb2b60a46f591a44a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_size_t.html">Harlinn::Windows::SizeT</a>&gt;</td></tr>
<tr class="memitem:afbfc06b14ebf76aeb2b60a46f591a44a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_cvref_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbfc06b14ebf76aeb2b60a46f591a44a">Clamp</a> (T value, T minimumValue, T maximumValue) noexcept</td></tr>
<tr class="separator:afbfc06b14ebf76aeb2b60a46f591a44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e716ee76fcedc06477de9f2be173a7a" id="r_a1e716ee76fcedc06477de9f2be173a7a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_point_t.html">Harlinn::Windows::PointT</a>&gt;</td></tr>
<tr class="memitem:a1e716ee76fcedc06477de9f2be173a7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_cvref_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e716ee76fcedc06477de9f2be173a7a">Floor</a> (T value) noexcept</td></tr>
<tr class="separator:a1e716ee76fcedc06477de9f2be173a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68598df2fe024d131d276cd153efbe9e" id="r_a68598df2fe024d131d276cd153efbe9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_size_t.html">Harlinn::Windows::SizeT</a>&gt;</td></tr>
<tr class="memitem:a68598df2fe024d131d276cd153efbe9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_cvref_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a68598df2fe024d131d276cd153efbe9e">Floor</a> (T value) noexcept</td></tr>
<tr class="separator:a68598df2fe024d131d276cd153efbe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402d665243728a47ff32bedf75c8751e" id="r_a402d665243728a47ff32bedf75c8751e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_point_t.html">Harlinn::Windows::PointT</a>&gt;</td></tr>
<tr class="memitem:a402d665243728a47ff32bedf75c8751e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_cvref_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a402d665243728a47ff32bedf75c8751e">Ceil</a> (T value) noexcept</td></tr>
<tr class="separator:a402d665243728a47ff32bedf75c8751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b10b32d0c645d3b25a139172d9ea2b2" id="r_a7b10b32d0c645d3b25a139172d9ea2b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_size_t.html">Harlinn::Windows::SizeT</a>&gt;</td></tr>
<tr class="memitem:a7b10b32d0c645d3b25a139172d9ea2b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_cvref_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b10b32d0c645d3b25a139172d9ea2b2">Ceil</a> (T value) noexcept</td></tr>
<tr class="separator:a7b10b32d0c645d3b25a139172d9ea2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60123fd2b94a5ca1fb5fd36ec0417e8a" id="r_a60123fd2b94a5ca1fb5fd36ec0417e8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_point_t.html">Harlinn::Windows::PointT</a>&gt;</td></tr>
<tr class="memitem:a60123fd2b94a5ca1fb5fd36ec0417e8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_cvref_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60123fd2b94a5ca1fb5fd36ec0417e8a">Lerp</a> (T a, T b, T t) noexcept</td></tr>
<tr class="separator:a60123fd2b94a5ca1fb5fd36ec0417e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09afe22d93f315729fd816d05f67653e" id="r_a09afe22d93f315729fd816d05f67653e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; <br />
requires (<a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_point_t.html">Harlinn::Windows::PointT</a>&gt; &amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;U&gt; )</td></tr>
<tr class="memitem:a09afe22d93f315729fd816d05f67653e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_cvref_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09afe22d93f315729fd816d05f67653e">Lerp</a> (T a, T b, U t) noexcept</td></tr>
<tr class="separator:a09afe22d93f315729fd816d05f67653e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d46344daea2b5c5760e49134f88732a" id="r_a8d46344daea2b5c5760e49134f88732a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_size_t.html">Harlinn::Windows::SizeT</a>&gt;</td></tr>
<tr class="memitem:a8d46344daea2b5c5760e49134f88732a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_cvref_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8d46344daea2b5c5760e49134f88732a">Lerp</a> (T a, T b, T t) noexcept</td></tr>
<tr class="separator:a8d46344daea2b5c5760e49134f88732a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa6771851bd5f804c8fb6f047cd24af7a" id="r_aa6771851bd5f804c8fb6f047cd24af7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Other&gt; </td></tr>
<tr class="memitem:aa6771851bd5f804c8fb6f047cd24af7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a> = ( std::is_same_v&lt;typename T::Traits, typename Other::Traits&gt; &amp;&amp; ... )</td></tr>
<tr class="separator:aa6771851bd5f804c8fb6f047cd24af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada36e8b3cd1f8901977574f25c1ec5f1" id="r_ada36e8b3cd1f8901977574f25c1ec5f1"><td class="memTemplParams" colspan="2">template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType ... Other&gt; </td></tr>
<tr class="memitem:ada36e8b3cd1f8901977574f25c1ec5f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a> = ( std::is_same_v&lt;typename T::Traits, typename Other::Traits&gt; &amp;&amp; ... )</td></tr>
<tr class="separator:ada36e8b3cd1f8901977574f25c1ec5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee661002deccc8f6242fe3fca873f99" id="r_a9ee661002deccc8f6242fe3fca873f99"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Other&gt; </td></tr>
<tr class="memitem:a9ee661002deccc8f6242fe3fca873f99"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a> = ( ( std::is_same_v&lt;typename T::Traits, typename Other::Traits&gt; &amp;&amp; ( T::Size == Other::Size ) ) &amp;&amp; ... )</td></tr>
<tr class="separator:a9ee661002deccc8f6242fe3fca873f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5279366f91fd5443f161eb3cf06e221a" id="r_a5279366f91fd5443f161eb3cf06e221a"><td class="memTemplParams" colspan="2">template&lt;PlaneOrPlaneSimdType T, PlaneOrPlaneSimdType ... Other&gt; </td></tr>
<tr class="memitem:a5279366f91fd5443f161eb3cf06e221a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5279366f91fd5443f161eb3cf06e221a">IsCompatiblePlane</a> = ( std::is_same_v&lt;typename T::Traits, typename Other::Traits&gt; &amp;&amp; ... )</td></tr>
<tr class="separator:a5279366f91fd5443f161eb3cf06e221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a906fd8ff6cbc5920af294d742c031071" name="a906fd8ff6cbc5920af294d742c031071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906fd8ff6cbc5920af294d742c031071">&#9670;&#160;</a></span>Line2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a906fd8ff6cbc5920af294d742c031071">Harlinn::Math::Line2</a> = <a class="el" href="struct_harlinn_1_1_math_1_1_line.html">Line</a>&lt;T, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b5a636c49265909a8893c4f7016d75b" name="a5b5a636c49265909a8893c4f7016d75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5a636c49265909a8893c4f7016d75b">&#9670;&#160;</a></span>Line2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5b5a636c49265909a8893c4f7016d75b">Harlinn::Math::Line2d</a> = <a class="el" href="#a906fd8ff6cbc5920af294d742c031071">Line2</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64b5d72ac584ecb9fc511618355214dd" name="a64b5d72ac584ecb9fc511618355214dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b5d72ac584ecb9fc511618355214dd">&#9670;&#160;</a></span>Line2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a64b5d72ac584ecb9fc511618355214dd">Harlinn::Math::Line2f</a> = <a class="el" href="#a906fd8ff6cbc5920af294d742c031071">Line2</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a306d4b18029ab8d02ced8135e7aa7a" name="a9a306d4b18029ab8d02ced8135e7aa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a306d4b18029ab8d02ced8135e7aa7a">&#9670;&#160;</a></span>Line3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9a306d4b18029ab8d02ced8135e7aa7a">Harlinn::Math::Line3</a> = <a class="el" href="struct_harlinn_1_1_math_1_1_line.html">Line</a>&lt;T, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a106fd971fe491b702c9e6a57f1ef8af6" name="a106fd971fe491b702c9e6a57f1ef8af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106fd971fe491b702c9e6a57f1ef8af6">&#9670;&#160;</a></span>Line3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a106fd971fe491b702c9e6a57f1ef8af6">Harlinn::Math::Line3d</a> = <a class="el" href="#a9a306d4b18029ab8d02ced8135e7aa7a">Line3</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7104d8ce3d358f968d96ffe84242d864" name="a7104d8ce3d358f968d96ffe84242d864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7104d8ce3d358f968d96ffe84242d864">&#9670;&#160;</a></span>Line3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7104d8ce3d358f968d96ffe84242d864">Harlinn::Math::Line3f</a> = <a class="el" href="#a9a306d4b18029ab8d02ced8135e7aa7a">Line3</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43e3e7d66212411e17fb90bdadba1354" name="a43e3e7d66212411e17fb90bdadba1354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e3e7d66212411e17fb90bdadba1354">&#9670;&#160;</a></span>Normal3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a43e3e7d66212411e17fb90bdadba1354">Harlinn::Math::Normal3f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_normal.html">Normal</a>&lt;float, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a639cabf2f826e7b0876ba10529ea9d06" name="a639cabf2f826e7b0876ba10529ea9d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639cabf2f826e7b0876ba10529ea9d06">&#9670;&#160;</a></span>Point2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a639cabf2f826e7b0876ba10529ea9d06">Harlinn::Math::Point2f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_point.html">Point</a>&lt;float, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1450880d4a39dfc0d03aefb442c1dc9" name="ab1450880d4a39dfc0d03aefb442c1dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1450880d4a39dfc0d03aefb442c1dc9">&#9670;&#160;</a></span>Point2i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab1450880d4a39dfc0d03aefb442c1dc9">Harlinn::Math::Point2i</a> = <a class="el" href="class_harlinn_1_1_math_1_1_point.html">Point</a>&lt;<a class="el" href="namespace_harlinn_1_1_common.html#a77b0045551d73ca9f4fb32769fa84426">Int32</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e227c35130c9e7e322ead53eeff7b6e" name="a3e227c35130c9e7e322ead53eeff7b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e227c35130c9e7e322ead53eeff7b6e">&#9670;&#160;</a></span>Point3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3e227c35130c9e7e322ead53eeff7b6e">Harlinn::Math::Point3f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_point.html">Point</a>&lt;float, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68e93e5118ab44e76e75ff4538ed5515" name="a68e93e5118ab44e76e75ff4538ed5515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e93e5118ab44e76e75ff4538ed5515">&#9670;&#160;</a></span>Point3i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a68e93e5118ab44e76e75ff4538ed5515">Harlinn::Math::Point3i</a> = <a class="el" href="class_harlinn_1_1_math_1_1_point.html">Point</a>&lt;<a class="el" href="namespace_harlinn_1_1_common.html#a77b0045551d73ca9f4fb32769fa84426">Int32</a>, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1a0c4e3a80e5024216032a7c46231c9" name="ab1a0c4e3a80e5024216032a7c46231c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a0c4e3a80e5024216032a7c46231c9">&#9670;&#160;</a></span>Segment2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab1a0c4e3a80e5024216032a7c46231c9">Harlinn::Math::Segment2</a> = <a class="el" href="struct_harlinn_1_1_math_1_1_segment.html">Segment</a>&lt;T, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8b7513b64d4f88490581352422f22d5" name="ac8b7513b64d4f88490581352422f22d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b7513b64d4f88490581352422f22d5">&#9670;&#160;</a></span>Segment2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac8b7513b64d4f88490581352422f22d5">Harlinn::Math::Segment2d</a> = <a class="el" href="#ab1a0c4e3a80e5024216032a7c46231c9">Segment2</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19c3a96481febfc8ea4aa0e69d45f341" name="a19c3a96481febfc8ea4aa0e69d45f341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c3a96481febfc8ea4aa0e69d45f341">&#9670;&#160;</a></span>Segment2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a19c3a96481febfc8ea4aa0e69d45f341">Harlinn::Math::Segment2f</a> = <a class="el" href="#ab1a0c4e3a80e5024216032a7c46231c9">Segment2</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e0925b6dc26d6be4b4fd33e5a69bba3" name="a0e0925b6dc26d6be4b4fd33e5a69bba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0925b6dc26d6be4b4fd33e5a69bba3">&#9670;&#160;</a></span>Segment3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0e0925b6dc26d6be4b4fd33e5a69bba3">Harlinn::Math::Segment3</a> = <a class="el" href="struct_harlinn_1_1_math_1_1_segment.html">Segment</a>&lt;T, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45b32810cc322dd1e5efaf1cc9684817" name="a45b32810cc322dd1e5efaf1cc9684817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b32810cc322dd1e5efaf1cc9684817">&#9670;&#160;</a></span>Segment3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a45b32810cc322dd1e5efaf1cc9684817">Harlinn::Math::Segment3d</a> = <a class="el" href="#a0e0925b6dc26d6be4b4fd33e5a69bba3">Segment3</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c669d52535837f83ac6f1f780858890" name="a3c669d52535837f83ac6f1f780858890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c669d52535837f83ac6f1f780858890">&#9670;&#160;</a></span>Segment3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3c669d52535837f83ac6f1f780858890">Harlinn::Math::Segment3f</a> = <a class="el" href="#a0e0925b6dc26d6be4b4fd33e5a69bba3">Segment3</a>&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae56153f60040dd948ae3ca936cb6d9c9" name="ae56153f60040dd948ae3ca936cb6d9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56153f60040dd948ae3ca936cb6d9c9">&#9670;&#160;</a></span>Vector2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae56153f60040dd948ae3ca936cb6d9c9">Harlinn::Math::Vector2d</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;double, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82ce90da94510f0e2ede5d7968a05bbe" name="a82ce90da94510f0e2ede5d7968a05bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ce90da94510f0e2ede5d7968a05bbe">&#9670;&#160;</a></span>Vector2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a82ce90da94510f0e2ede5d7968a05bbe">Harlinn::Math::Vector2f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;float, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f4fcb05bbc5bf7a6ba71960d5436cf9" name="a7f4fcb05bbc5bf7a6ba71960d5436cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4fcb05bbc5bf7a6ba71960d5436cf9">&#9670;&#160;</a></span>Vector2i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7f4fcb05bbc5bf7a6ba71960d5436cf9">Harlinn::Math::Vector2i</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;int, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3759c6917a7be994d53e0e90622a7c1d" name="a3759c6917a7be994d53e0e90622a7c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3759c6917a7be994d53e0e90622a7c1d">&#9670;&#160;</a></span>Vector3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3759c6917a7be994d53e0e90622a7c1d">Harlinn::Math::Vector3d</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;double, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f636c112afae492b0c6354badc3cf73" name="a2f636c112afae492b0c6354badc3cf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f636c112afae492b0c6354badc3cf73">&#9670;&#160;</a></span>Vector3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2f636c112afae492b0c6354badc3cf73">Harlinn::Math::Vector3f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;float, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea76ac78b5bc5432ac4598540c03873e" name="aea76ac78b5bc5432ac4598540c03873e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea76ac78b5bc5432ac4598540c03873e">&#9670;&#160;</a></span>Vector3i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aea76ac78b5bc5432ac4598540c03873e">Harlinn::Math::Vector3i</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;int, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae37ef7a1d9b6a1eeb76916b6fbffd0b5" name="ae37ef7a1d9b6a1eeb76916b6fbffd0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37ef7a1d9b6a1eeb76916b6fbffd0b5">&#9670;&#160;</a></span>Vector4d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae37ef7a1d9b6a1eeb76916b6fbffd0b5">Harlinn::Math::Vector4d</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;double, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab05e5ab93d92035d4287e44a528b30ef" name="ab05e5ab93d92035d4287e44a528b30ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05e5ab93d92035d4287e44a528b30ef">&#9670;&#160;</a></span>Vector4f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab05e5ab93d92035d4287e44a528b30ef">Harlinn::Math::Vector4f</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;float, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef59117700c1f463a437b502d5173b1e" name="aef59117700c1f463a437b502d5173b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef59117700c1f463a437b502d5173b1e">&#9670;&#160;</a></span>Vector4i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aef59117700c1f463a437b502d5173b1e">Harlinn::Math::Vector4i</a> = <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;int, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6851f9f03a800224c7551b42347ef2f8" name="a6851f9f03a800224c7551b42347ef2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6851f9f03a800224c7551b42347ef2f8">&#9670;&#160;</a></span>MatrixType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a6851f9f03a800224c7551b42347ef2f8">Harlinn::Math::MatrixType</a> : <a class="el" href="namespace_harlinn_1_1_common.html#af3ce862d19ad61e7bef7ba1566ed81ef">UInt32</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6851f9f03a800224c7551b42347ef2f8ad7ed4ee1df437474d005188535f74875" name="a6851f9f03a800224c7551b42347ef2f8ad7ed4ee1df437474d005188535f74875"></a>Zero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6851f9f03a800224c7551b42347ef2f8ac9c5c65fb4af9cf90eb99b3b84424189" name="a6851f9f03a800224c7551b42347ef2f8ac9c5c65fb4af9cf90eb99b3b84424189"></a>Identity&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a832789d34c30752ca8c56ce1aabd4eea" name="a832789d34c30752ca8c56ce1aabd4eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832789d34c30752ca8c56ce1aabd4eea">&#9670;&#160;</a></span>Abs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::Abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c7551b98354b140049ec9bef3343c63" name="a3c7551b98354b140049ec9bef3343c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7551b98354b140049ec9bef3343c63">&#9670;&#160;</a></span>Abs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of each element held by the argument. </p>

</div>
</div>
<a id="ab4a4bfa28ef8b8b47b2e42a18925a8ce" name="ab4a4bfa28ef8b8b47b2e42a18925a8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a4bfa28ef8b8b47b2e42a18925a8ce">&#9670;&#160;</a></span>Abs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SignedIntegerType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Abs </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The absolute value of any unsigned integer is the same as its value. </p>
<p>Computes the absolute value of a signed integer number. The behavior is undefined if the result cannot be represented by the return type. </p>
<p>In 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any signed integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A signed integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of val. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>An unsigned integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>val without any modification. </dd></dl>
<p>Computes the absolute value of a floating point value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of val. </dd></dl>

</div>
</div>
<a id="a7ff71ab5e0388ba969d625a90c4f4ffd" name="a7ff71ab5e0388ba969d625a90c4f4ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff71ab5e0388ba969d625a90c4f4ffd">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bc42c6c932eb1f9fb96fed3da5666e7" name="a6bc42c6c932eb1f9fb96fed3da5666e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc42c6c932eb1f9fb96fed3da5666e7">&#9670;&#160;</a></span>AbsDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::AbsDot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the absolute value of the dot product between v1 and v2. </p>

</div>
</div>
<a id="aba1a6cb5c100e56b0a9ab52177e51aba" name="aba1a6cb5c100e56b0a9ab52177e51aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1a6cb5c100e56b0a9ab52177e51aba">&#9670;&#160;</a></span>ACos() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::ACos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd02887de83f75907452f439b12e4146" name="acd02887de83f75907452f439b12e4146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd02887de83f75907452f439b12e4146">&#9670;&#160;</a></span>ACos() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ACos </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse cosine of each element in the argument, in radians. </p>

</div>
</div>
<a id="a25da3bc32c648dbc8ab9713872b9a62f" name="a25da3bc32c648dbc8ab9713872b9a62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25da3bc32c648dbc8ab9713872b9a62f">&#9670;&#160;</a></span>ACos() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ACos </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the value of the arc cosine of x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The principal value of the arc cosine of x. </dd></dl>

</div>
</div>
<a id="ac6ec4e562d1a0253868cfb2589af5877" name="ac6ec4e562d1a0253868cfb2589af5877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ec4e562d1a0253868cfb2589af5877">&#9670;&#160;</a></span>ACosH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ACosH </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse hyperbolic cosine of each element in the argument, in radians. </p>

</div>
</div>
<a id="aaaf7efc2ffbd402a6ee28db4e313a19d" name="aaaf7efc2ffbd402a6ee28db4e313a19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf7efc2ffbd402a6ee28db4e313a19d">&#9670;&#160;</a></span>ACosH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ACosH </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse hyperbolic cosine of x. </p>

</div>
</div>
<a id="ae1ffb82246acf4370fe200803be25daa" name="ae1ffb82246acf4370fe200803be25daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ffb82246acf4370fe200803be25daa">&#9670;&#160;</a></span>AddAdjustDown() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::AddAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dfb11ad9dc88a77c73ccd5178496978" name="a6dfb11ad9dc88a77c73ccd5178496978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfb11ad9dc88a77c73ccd5178496978">&#9670;&#160;</a></span>AddAdjustDown() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::AddAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60854f7df718292f5e99c7b1104c42ae" name="a60854f7df718292f5e99c7b1104c42ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60854f7df718292f5e99c7b1104c42ae">&#9670;&#160;</a></span>AddAdjustDown() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S::Simd Harlinn::Math::AddAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7317afcfb2986b82fb7ee42610fc4991" name="a7317afcfb2986b82fb7ee42610fc4991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7317afcfb2986b82fb7ee42610fc4991">&#9670;&#160;</a></span>AddAdjustDown() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::AddAdjustDown </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41f3155d409c324b290a15cf76e55c47" name="a41f3155d409c324b290a15cf76e55c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f3155d409c324b290a15cf76e55c47">&#9670;&#160;</a></span>AddAdjustUp() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::AddAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e7d295658733b6a9fc5565acc79b5f8" name="a2e7d295658733b6a9fc5565acc79b5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7d295658733b6a9fc5565acc79b5f8">&#9670;&#160;</a></span>AddAdjustUp() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::AddAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d690183d66734176c5816622493ad13" name="a5d690183d66734176c5816622493ad13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d690183d66734176c5816622493ad13">&#9670;&#160;</a></span>AddAdjustUp() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S::Simd Harlinn::Math::AddAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1a4e8b02290576eda68b4a39dbc644f" name="af1a4e8b02290576eda68b4a39dbc644f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a4e8b02290576eda68b4a39dbc644f">&#9670;&#160;</a></span>AddAdjustUp() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::AddAdjustUp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6fda071392d17eba907c00339c957a1" name="ae6fda071392d17eba907c00339c957a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fda071392d17eba907c00339c957a1">&#9670;&#160;</a></span>AddAngles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::AddAngles </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the angles in the corresponding elements of v1 and v2. The argument angles must be in the range [-PI,PI), and the computed angles will be in the range [-PI,PI) </p>

</div>
</div>
<a id="a0fe6f75ae996d8972718250ee8c579d8" name="a0fe6f75ae996d8972718250ee8c579d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe6f75ae996d8972718250ee8c579d8">&#9670;&#160;</a></span>AffineTransformationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, QuaternionOrQuaternionSimdType U, SimdOrTupleType W&gt; <br />
requires ( S::Size &gt; 2 ) &amp;&amp; ( T::Size &gt; 2 ) &amp;&amp; ( W::Size &gt; 2 ) &amp;&amp; std::is_same_v&lt;typename S::value_type, typename T::value_type&gt;&amp;&amp; std::is_same_v&lt;typename S::value_type, typename U::value_type&gt;&amp;&amp; std::is_same_v&lt;typename S::value_type, typename W::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; typenameS::value_type, 4 &gt;::Simd Harlinn::Math::AffineTransformationMatrix </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>scaling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>rotationOrigin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rotationQuaternion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const W &amp;</td>          <td class="paramname"><span class="paramname"><em>translation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine transformation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaling</td><td>The scaling factors for each dimension. </td></tr>
    <tr><td class="paramname">rotationOrigin</td><td>The center of rotation. </td></tr>
    <tr><td class="paramname">rotationQuaternion</td><td>Rotation factors as a quaternion. </td></tr>
    <tr><td class="paramname">translation</td><td>The translation offsets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab3bea74c344ac67ec2ad68ef4dc31685" name="ab3bea74c344ac67ec2ad68ef4dc31685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bea74c344ac67ec2ad68ef4dc31685">&#9670;&#160;</a></span>AllEqual() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllEqual </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of lhs and their corresponding element of rhs are less or equally apart than the corresponding element of epsilon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second source of values for the comparison. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The source of the maximum difference between the corresponding elements from lhs and rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of lhs and the corresponding elements of rhs are less or equally apart than the corresponding element of epsilon, otherwise false. </dd></dl>

</div>
</div>
<a id="aea55de9394df0e63c1bd778f94c399bf" name="aea55de9394df0e63c1bd778f94c399bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea55de9394df0e63c1bd778f94c399bf">&#9670;&#160;</a></span>AllEqual() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllEqual </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of lhs and their corresponding element of rhs are less or equally apart than the value of epsilon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second source of values for the comparison. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The maximum difference between the elements from lhs and rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of lhs and the corresponding elements of rhs are less or equally apart than the value of epsilon, otherwise false. </dd></dl>

</div>
</div>
<a id="a6d414802e1e8044328593cec83faea31" name="a6d414802e1e8044328593cec83faea31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d414802e1e8044328593cec83faea31">&#9670;&#160;</a></span>AllEqual() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are equal to the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is equal to their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="aaabb0101651196796783356658503dd0" name="aaabb0101651196796783356658503dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabb0101651196796783356658503dd0">&#9670;&#160;</a></span>AllEqual() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are equal to value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is equal to value, otherwise false. </dd></dl>

</div>
</div>
<a id="aed2f5e38b089374607d675d1201ebaa8" name="aed2f5e38b089374607d675d1201ebaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2f5e38b089374607d675d1201ebaa8">&#9670;&#160;</a></span>AllEqual() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllEqual </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is equal to all the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is equal to all the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a9e93f7e30ca213ecfbb897effab57496" name="a9e93f7e30ca213ecfbb897effab57496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e93f7e30ca213ecfbb897effab57496">&#9670;&#160;</a></span>AllGreater() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllGreater </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are greater than the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is greater than their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a1e92fbbd80605ef3dc0e8f8fd1757720" name="a1e92fbbd80605ef3dc0e8f8fd1757720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e92fbbd80605ef3dc0e8f8fd1757720">&#9670;&#160;</a></span>AllGreater() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllGreater </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are greater than value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is greater than value, otherwise false. </dd></dl>

</div>
</div>
<a id="a91b2a2d38f30adf32e641791040e6e2f" name="a91b2a2d38f30adf32e641791040e6e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b2a2d38f30adf32e641791040e6e2f">&#9670;&#160;</a></span>AllGreater() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllGreater </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is greater than all of the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is greater than any of the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a6eb226d267a4b487b4fecd707febd344" name="a6eb226d267a4b487b4fecd707febd344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb226d267a4b487b4fecd707febd344">&#9670;&#160;</a></span>AllGreaterOrEqual() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllGreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are greater than, or equal to, the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is greater than, or equal to, their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a9962b9e03565d763ca0d74559b6bc83b" name="a9962b9e03565d763ca0d74559b6bc83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9962b9e03565d763ca0d74559b6bc83b">&#9670;&#160;</a></span>AllGreaterOrEqual() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllGreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are greater than, or equal to, value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is greater than, or equal to, value, otherwise false. </dd></dl>

</div>
</div>
<a id="a8c17ac14da6636881e72d8d2c7890b3d" name="a8c17ac14da6636881e72d8d2c7890b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c17ac14da6636881e72d8d2c7890b3d">&#9670;&#160;</a></span>AllGreaterOrEqual() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllGreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is greater than, or equal to, all of the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is greater than, or equal to, any of the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a04bd81dab996c9d8901bd81f80010561" name="a04bd81dab996c9d8901bd81f80010561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bd81dab996c9d8901bd81f80010561">&#9670;&#160;</a></span>AllLess() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllLess </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are less than the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is less than their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="af6b04e06b7ab1a58928eca11e05b8ff7" name="af6b04e06b7ab1a58928eca11e05b8ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b04e06b7ab1a58928eca11e05b8ff7">&#9670;&#160;</a></span>AllLess() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllLess </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are less than value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is less than value, otherwise false. </dd></dl>

</div>
</div>
<a id="afe3f44e66ffcb54085048be0eab37950" name="afe3f44e66ffcb54085048be0eab37950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3f44e66ffcb54085048be0eab37950">&#9670;&#160;</a></span>AllLess() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllLess </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is less than all of the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is less than any of the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a544ae08d9e96e999144d7c5276ff2698" name="a544ae08d9e96e999144d7c5276ff2698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544ae08d9e96e999144d7c5276ff2698">&#9670;&#160;</a></span>AllLessOrEqual() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllLessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are less than, or equal to, the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is less than, or equal to, their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a610535c9789c83a740cf1e0324ad5c83" name="a610535c9789c83a740cf1e0324ad5c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610535c9789c83a740cf1e0324ad5c83">&#9670;&#160;</a></span>AllLessOrEqual() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllLessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are less than, or equal to, value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is less than, or equal to, value, otherwise false. </dd></dl>

</div>
</div>
<a id="a726cc41d495bfb12b081ff74fa741506" name="a726cc41d495bfb12b081ff74fa741506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726cc41d495bfb12b081ff74fa741506">&#9670;&#160;</a></span>AllLessOrEqual() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllLessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is less than, or equal to, all of the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is less than, or equal to, any of the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a197badea1790b788b573928ac545be42" name="a197badea1790b788b573928ac545be42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197badea1790b788b573928ac545be42">&#9670;&#160;</a></span>AllNotEqual() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllNotEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are not equal to the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is not equal to their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="ac0caf042dfd08740b89b0f833354a66c" name="ac0caf042dfd08740b89b0f833354a66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0caf042dfd08740b89b0f833354a66c">&#9670;&#160;</a></span>AllNotEqual() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllNotEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether all the elements of v1 are not equal to value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all the elements of v1 is not equal to value, otherwise false. </dd></dl>

</div>
</div>
<a id="a042a81fe16cdd87a4ee35ff5a038d39c" name="a042a81fe16cdd87a4ee35ff5a038d39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042a81fe16cdd87a4ee35ff5a038d39c">&#9670;&#160;</a></span>AllNotEqual() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllNotEqual </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is not equal to all the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is not equal to all the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="aa0fade8696a5d96d8c669535131dad2c" name="aa0fade8696a5d96d8c669535131dad2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fade8696a5d96d8c669535131dad2c">&#9670;&#160;</a></span>AllTrue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AllTrue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all the elements of the argument have all their bits set to 1. </p>

</div>
</div>
<a id="a62a730afee6f66dec7bf9ec64f48e263" name="a62a730afee6f66dec7bf9ec64f48e263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a730afee6f66dec7bf9ec64f48e263">&#9670;&#160;</a></span>AngleBetween() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VectorOrVectorSimdType S, VectorOrVectorSimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::AngleBetween </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the angle in radians between two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first vector. </td></tr>
    <tr><td class="paramname">v2</td><td>The second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector where with each element set to the angle between the two argument vectors. </dd></dl>

</div>
</div>
<a id="a7c9f26a9d9d52903ed5ab6fd5e049073" name="a7c9f26a9d9d52903ed5ab6fd5e049073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9f26a9d9d52903ed5ab6fd5e049073">&#9670;&#160;</a></span>AngleBetween() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename FloatT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a>&lt; DerivedT, FloatT &gt; Harlinn::Math::AngleBetween </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a>&lt; DerivedT, FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a>&lt; DerivedT, FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f09dcb382f2a6d37cd1cbe95cfb6e73" name="a6f09dcb382f2a6d37cd1cbe95cfb6e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f09dcb382f2a6d37cd1cbe95cfb6e73">&#9670;&#160;</a></span>AngleBetweenNormalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VectorOrVectorSimdType S, VectorOrVectorSimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::AngleBetweenNormalized </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the angle in radians between two normalized vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first normalized vector. </td></tr>
    <tr><td class="paramname">v2</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>The second normalized vector. </p><dl class="section return"><dt>Returns</dt><dd>A vector where with each element set to the angle between the two argument vectors. </dd></dl>

</div>
</div>
<a id="a538b5121013a2626be4e22b722d26e81" name="a538b5121013a2626be4e22b722d26e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538b5121013a2626be4e22b722d26e81">&#9670;&#160;</a></span>AnyEqual() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyEqual </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of lhs and their corresponding element of rhs are less or equally apart than the corresponding element of epsilon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second source of values for the comparison. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The source of the maximum difference between the corresponding elements from lhs and rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of lhs and the corresponding elements of rhs are less or equally apart than the corresponding element of epsilon, otherwise false. </dd></dl>

</div>
</div>
<a id="a8307a2e5211ebde385cac17b7ee7082e" name="a8307a2e5211ebde385cac17b7ee7082e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8307a2e5211ebde385cac17b7ee7082e">&#9670;&#160;</a></span>AnyEqual() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyEqual </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of lhs and their corresponding element of rhs are less or equally apart than the value of epsilon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second source of values for the comparison. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The maximum difference between the elements from lhs and rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of lhs and the corresponding elements of rhs are less or equally apart than the value of epsilon, otherwise false. </dd></dl>

</div>
</div>
<a id="ad2955961bbb0693a8fd10678a625cb1d" name="ad2955961bbb0693a8fd10678a625cb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2955961bbb0693a8fd10678a625cb1d">&#9670;&#160;</a></span>AnyEqual() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are equal to the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is equal to their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a051ab117c341ed3303404066719d4339" name="a051ab117c341ed3303404066719d4339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051ab117c341ed3303404066719d4339">&#9670;&#160;</a></span>AnyEqual() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are equal to value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is equal to value, otherwise false. </dd></dl>

</div>
</div>
<a id="a1fa49131bc680cb56347787af15bc427" name="a1fa49131bc680cb56347787af15bc427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa49131bc680cb56347787af15bc427">&#9670;&#160;</a></span>AnyEqual() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyEqual </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is equal to any of the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is equal to any of the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="aa5650716a27e2245f5fec40a1ebe6127" name="aa5650716a27e2245f5fec40a1ebe6127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5650716a27e2245f5fec40a1ebe6127">&#9670;&#160;</a></span>AnyGreater() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyGreater </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are greater than the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is greater than their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a5a88831c343f6ea0d617e8cb002ca279" name="a5a88831c343f6ea0d617e8cb002ca279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a88831c343f6ea0d617e8cb002ca279">&#9670;&#160;</a></span>AnyGreater() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyGreater </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are greater than value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is greater than value, otherwise false. </dd></dl>

</div>
</div>
<a id="a0f6ce2fd86bde562781f66c7540f2935" name="a0f6ce2fd86bde562781f66c7540f2935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6ce2fd86bde562781f66c7540f2935">&#9670;&#160;</a></span>AnyGreater() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyGreater </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is greater than any of the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is greater than any of the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a658d635179ea950b78eea98917640028" name="a658d635179ea950b78eea98917640028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658d635179ea950b78eea98917640028">&#9670;&#160;</a></span>AnyGreaterOrEqual() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyGreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are greater than, or equal to, the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is greater than, or equal to, their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="ade2214a402222e747802735a327eb054" name="ade2214a402222e747802735a327eb054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2214a402222e747802735a327eb054">&#9670;&#160;</a></span>AnyGreaterOrEqual() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyGreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are greater than, or equal to, value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is greater than, or equal to, value, otherwise false. </dd></dl>

</div>
</div>
<a id="a84a1310fcca15ec5556e13537cfad726" name="a84a1310fcca15ec5556e13537cfad726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a1310fcca15ec5556e13537cfad726">&#9670;&#160;</a></span>AnyGreaterOrEqual() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyGreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is greater than, or equal to, any of the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is greater than, or equal to, any of the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a44635a8ac9f6e7e58ab0bfb1d3bc11b0" name="a44635a8ac9f6e7e58ab0bfb1d3bc11b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44635a8ac9f6e7e58ab0bfb1d3bc11b0">&#9670;&#160;</a></span>AnyLess() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyLess </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are less than the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is less than their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a9e44008b9eee7bf058bf46270f40d38e" name="a9e44008b9eee7bf058bf46270f40d38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e44008b9eee7bf058bf46270f40d38e">&#9670;&#160;</a></span>AnyLess() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyLess </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are less than value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is less than value, otherwise false. </dd></dl>

</div>
</div>
<a id="a5efb0d2f56ca8322029b509c43d2f601" name="a5efb0d2f56ca8322029b509c43d2f601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efb0d2f56ca8322029b509c43d2f601">&#9670;&#160;</a></span>AnyLess() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyLess </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is less than any of the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is less than any of the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="ac21bf882a0c01dd485d34626f2107481" name="ac21bf882a0c01dd485d34626f2107481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21bf882a0c01dd485d34626f2107481">&#9670;&#160;</a></span>AnyLessOrEqual() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyLessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are less than, or equal to, the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is less than, or equal to, their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a72808741a4b7b23afaf86d0c6d08c4ef" name="a72808741a4b7b23afaf86d0c6d08c4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72808741a4b7b23afaf86d0c6d08c4ef">&#9670;&#160;</a></span>AnyLessOrEqual() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyLessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are less than, or equal to, value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is less than, or equal to, value, otherwise false. </dd></dl>

</div>
</div>
<a id="a0887fc10b541d47ba0ab5380ed852375" name="a0887fc10b541d47ba0ab5380ed852375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0887fc10b541d47ba0ab5380ed852375">&#9670;&#160;</a></span>AnyLessOrEqual() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyLessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is less than, or equal to, any of the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is less than, or equal to, any of the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="acf31923a32f65e52e433db988f9a6268" name="acf31923a32f65e52e433db988f9a6268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf31923a32f65e52e433db988f9a6268">&#9670;&#160;</a></span>AnyNotEqual() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyNotEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are not equal to the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is not equal to their corresponding element in v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a7c66c01e6eb66e82e56130c63dffc1e7" name="a7c66c01e6eb66e82e56130c63dffc1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c66c01e6eb66e82e56130c63dffc1e7">&#9670;&#160;</a></span>AnyNotEqual() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyNotEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any of the elements of v1 are not equal to value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any of the elements of v1 is not equal to value, otherwise false. </dd></dl>

</div>
</div>
<a id="a7340089292f28ea8bbe1f8b044d3198a" name="a7340089292f28ea8bbe1f8b044d3198a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7340089292f28ea8bbe1f8b044d3198a">&#9670;&#160;</a></span>AnyNotEqual() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyNotEqual </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is not equal to any of the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>true value is not equal to any of the elements of v2, otherwise false. </dd></dl>

</div>
</div>
<a id="a2c998fd6e7f2cd4624c3d8edbe538f03" name="a2c998fd6e7f2cd4624c3d8edbe538f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c998fd6e7f2cd4624c3d8edbe538f03">&#9670;&#160;</a></span>AnyTrue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::AnyTrue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any of the elements of the argument have all their bits set to 1. </p>

</div>
</div>
<a id="a148224234abd6b410e5fa40201323924" name="a148224234abd6b410e5fa40201323924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148224234abd6b410e5fa40201323924">&#9670;&#160;</a></span>ASin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ASin </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse sine of each element in the argument, in radians. </p>

</div>
</div>
<a id="a799c6a9b78dcf871f193a59117673f10" name="a799c6a9b78dcf871f193a59117673f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799c6a9b78dcf871f193a59117673f10">&#9670;&#160;</a></span>ASin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ASin </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the value of the arc sine of x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The principal value of the arc sine of x. </dd></dl>

</div>
</div>
<a id="a9eb9edec361f93d6d523c242f075657a" name="a9eb9edec361f93d6d523c242f075657a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb9edec361f93d6d523c242f075657a">&#9670;&#160;</a></span>ASinH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ASinH </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse hyperbolic sine of each element in the argument, in radians. </p>

</div>
</div>
<a id="ab82e83021998ad5ba22d6defdef49d48" name="ab82e83021998ad5ba22d6defdef49d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82e83021998ad5ba22d6defdef49d48">&#9670;&#160;</a></span>ASinH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ASinH </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse hyperbolic sine of x. </p>

</div>
</div>
<a id="a23e5113b26b069b7d297029c72a65148" name="a23e5113b26b069b7d297029c72a65148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e5113b26b069b7d297029c72a65148">&#9670;&#160;</a></span>ATan() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ATan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse tangent of each element in the argument, in radians. </p>

</div>
</div>
<a id="a3c753d0b4b0d0aa0944f1d0120ef0592" name="a3c753d0b4b0d0aa0944f1d0120ef0592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c753d0b4b0d0aa0944f1d0120ef0592">&#9670;&#160;</a></span>ATan() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ATan </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the value of the arc tangent of x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The principal value of the arc tangent of x. </dd></dl>

</div>
</div>
<a id="a104395137f9cc30ddf1244d894061c3d" name="a104395137f9cc30ddf1244d894061c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104395137f9cc30ddf1244d894061c3d">&#9670;&#160;</a></span>ATan() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ATan </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>arc tangent of y / x using the signs of arguments to determine the correct quadrant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">c</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arc tangent of y / x using the signs of arguments to determine the correct quadrant. </dd></dl>

</div>
</div>
<a id="af55019be7b30b045b1e05d76d9b32e26" name="af55019be7b30b045b1e05d76d9b32e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55019be7b30b045b1e05d76d9b32e26">&#9670;&#160;</a></span>ATan2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ATan2 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse tangent of each element in x divided by the corresponding element in y, in radians. </p>

</div>
</div>
<a id="aa11851fa0bb8220a20cf504153d6329e" name="aa11851fa0bb8220a20cf504153d6329e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11851fa0bb8220a20cf504153d6329e">&#9670;&#160;</a></span>ATan2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ATan2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The arc tangent of y / x using the signs of arguments to determine the correct quadrant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arc tangent of y / x using the signs of arguments to determine the correct quadrant. </dd></dl>

</div>
</div>
<a id="a00d1e54202e936cc46491aa0ba1c316a" name="a00d1e54202e936cc46491aa0ba1c316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d1e54202e936cc46491aa0ba1c316a">&#9670;&#160;</a></span>ATanH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ATanH </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse hyperbolic tangent of each element in the argument, in radians. </p>

</div>
</div>
<a id="a9a29b9decaea1c4a6b36adbe1d3b6bf7" name="a9a29b9decaea1c4a6b36adbe1d3b6bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a29b9decaea1c4a6b36adbe1d3b6bf7">&#9670;&#160;</a></span>ATanH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ATanH </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse hyperbolic tangent of x. </p>

</div>
</div>
<a id="a92c2a68b9ea84fd4f019ac54f5a59b4b" name="a92c2a68b9ea84fd4f019ac54f5a59b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c2a68b9ea84fd4f019ac54f5a59b4b">&#9670;&#160;</a></span>Avg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Avg </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5224ffde0d0cbc95426bf45ce24d0570" name="a5224ffde0d0cbc95426bf45ce24d0570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5224ffde0d0cbc95426bf45ce24d0570">&#9670;&#160;</a></span>BaryCentric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U, SimdOrTupleType V, SimdOrTupleType W&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, V&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, W&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::BaryCentric </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>p3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const W &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a point in Barycentric coordinates, using the specified triangle. <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">https://en.wikipedia.org/wiki/Barycentric_coordinate_system</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The first position. </td></tr>
    <tr><td class="paramname">p2</td><td>The second position. </td></tr>
    <tr><td class="paramname">p3</td><td>The third position. </td></tr>
    <tr><td class="paramname">f</td><td>Weighting factor. </td></tr>
    <tr><td class="paramname">g</td><td>Weighting factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec68f5d1bd70bd9979501aa00682e22d" name="aec68f5d1bd70bd9979501aa00682e22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec68f5d1bd70bd9979501aa00682e22d">&#9670;&#160;</a></span>BaryCentric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U, ArithmeticType V, ArithmeticType W&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::BaryCentric </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>p3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const W</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a point in Barycentric coordinates, using the specified triangle. <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">https://en.wikipedia.org/wiki/Barycentric_coordinate_system</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The first position. </td></tr>
    <tr><td class="paramname">p2</td><td>The second position. </td></tr>
    <tr><td class="paramname">p3</td><td>The third position. </td></tr>
    <tr><td class="paramname">f</td><td>Weighting factor. </td></tr>
    <tr><td class="paramname">g</td><td>Weighting factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcedb3d6ca6bcbd0023d9e712dc141c4" name="adcedb3d6ca6bcbd0023d9e712dc141c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcedb3d6ca6bcbd0023d9e712dc141c4">&#9670;&#160;</a></span>CatmullRom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U, SimdOrTupleType V, SimdOrTupleType W&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U, V, W&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::CatmullRom </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>p3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>p4</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const W &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Catmull-Rom interpolation, using the specified positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The first position. </td></tr>
    <tr><td class="paramname">p2</td><td>The second position. </td></tr>
    <tr><td class="paramname">p3</td><td>The third position. </td></tr>
    <tr><td class="paramname">p4</td><td>The fourth position. </td></tr>
    <tr><td class="paramname">t</td><td>The interpolation control factors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07bae2f8239b21c4ae271716a81025a7" name="a07bae2f8239b21c4ae271716a81025a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bae2f8239b21c4ae271716a81025a7">&#9670;&#160;</a></span>CatmullRom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U, SimdOrTupleType V, ArithmeticType W&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U, V&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::CatmullRom </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>p3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>p4</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const W</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Catmull-Rom interpolation, using the specified positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The first position. </td></tr>
    <tr><td class="paramname">p2</td><td>The second position. </td></tr>
    <tr><td class="paramname">p3</td><td>The third position. </td></tr>
    <tr><td class="paramname">p4</td><td>The fourth position. </td></tr>
    <tr><td class="paramname">t</td><td>The interpolation control factors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30982f405e8678c91bdbde90e0d88bbb" name="a30982f405e8678c91bdbde90e0d88bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30982f405e8678c91bdbde90e0d88bbb">&#9670;&#160;</a></span>Cbrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Cbrt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cube root of each element in the argument. </p>

</div>
</div>
<a id="a90927c2206380b934e2d0e412275031c" name="a90927c2206380b934e2d0e412275031c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90927c2206380b934e2d0e412275031c">&#9670;&#160;</a></span>Cbrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Cbrt </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7714971b42c40cee6d336bb04e018904" name="a7714971b42c40cee6d336bb04e018904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7714971b42c40cee6d336bb04e018904">&#9670;&#160;</a></span>Ceil() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::Ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed75ab665c6260a589021fca37af79a1" name="aed75ab665c6260a589021fca37af79a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed75ab665c6260a589021fca37af79a1">&#9670;&#160;</a></span>Ceil() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Ceil </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the ceiling of each element held by the argument. </p>

</div>
</div>
<a id="a5b801a8dc102a4a4e380837e432551d6" name="a5b801a8dc102a4a4e380837e432551d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b801a8dc102a4a4e380837e432551d6">&#9670;&#160;</a></span>Ceil() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Ceil </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just returns value. </p>
<p>Computes the smallest integer value not less than value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest integer value not less than value. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value </dd></dl>

</div>
</div>
<a id="a402d665243728a47ff32bedf75c8751e" name="a402d665243728a47ff32bedf75c8751e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402d665243728a47ff32bedf75c8751e">&#9670;&#160;</a></span>Ceil() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_point_t.html">Harlinn::Windows::PointT</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cvref_t&lt; T &gt; Harlinn::Math::Ceil </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b10b32d0c645d3b25a139172d9ea2b2" name="a7b10b32d0c645d3b25a139172d9ea2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b10b32d0c645d3b25a139172d9ea2b2">&#9670;&#160;</a></span>Ceil() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_size_t.html">Harlinn::Windows::SizeT</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cvref_t&lt; T &gt; Harlinn::Math::Ceil </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a38af4120787df828c7ab2ea17a555b38" name="a38af4120787df828c7ab2ea17a555b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38af4120787df828c7ab2ea17a555b38">&#9670;&#160;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a744cd55624b73cfdfca9a0107a3ba95b" name="a744cd55624b73cfdfca9a0107a3ba95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744cd55624b73cfdfca9a0107a3ba95b">&#9670;&#160;</a></span>Clamp() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Clamp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lowerBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>upperBounds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the elements of v, if the elements are between their respective boundaries specified by the elements of lowerBounds and the elements of upperBounds, otherwise the value of nearest boundary is returned. </p>

</div>
</div>
<a id="a39b5d4a61210bdf704feb47417bf92ca" name="a39b5d4a61210bdf704feb47417bf92ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b5d4a61210bdf704feb47417bf92ca">&#9670;&#160;</a></span>Clamp() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Clamp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lowerBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>upperBounds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the elements of v, if the elements are between their respective boundaries specified by the elements of lowerBounds and the elements of upperBounds, otherwise the value of nearest boundary is returned. </p>

</div>
</div>
<a id="a59669181cb9c3d42467d62701ea7a027" name="a59669181cb9c3d42467d62701ea7a027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59669181cb9c3d42467d62701ea7a027">&#9670;&#160;</a></span>Clamp() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Clamp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>lowerBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>upperBounds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the elements of v, if the elements are between their respective boundaries specified by lowerBounds and upperBounds, otherwise the value of nearest boundary is returned. </p>

</div>
</div>
<a id="aa7f91cd56dd75160292bc6ebd97c49fc" name="aa7f91cd56dd75160292bc6ebd97c49fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f91cd56dd75160292bc6ebd97c49fc">&#9670;&#160;</a></span>Clamp() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Clamp </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lowerBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>upperBounds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the elements of v, if the elements are between their respective boundaries specified by the elements of lowerBounds and the elements of upperBounds, otherwise the value of nearest boundary is returned. </p>

</div>
</div>
<a id="a0d4ee32222d27fda36d433fb6dbbfedc" name="a0d4ee32222d27fda36d433fb6dbbfedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4ee32222d27fda36d433fb6dbbfedc">&#9670;&#160;</a></span>Clamp() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_point_t.html">Harlinn::Windows::PointT</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cvref_t&lt; T &gt; Harlinn::Math::Clamp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>minimumValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>maximumValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afbfc06b14ebf76aeb2b60a46f591a44a" name="afbfc06b14ebf76aeb2b60a46f591a44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfc06b14ebf76aeb2b60a46f591a44a">&#9670;&#160;</a></span>Clamp() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_size_t.html">Harlinn::Windows::SizeT</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cvref_t&lt; T &gt; Harlinn::Math::Clamp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>minimumValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>maximumValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b4d0862351f0a2917902fc35e4da876" name="a2b4d0862351f0a2917902fc35e4da876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4d0862351f0a2917902fc35e4da876">&#9670;&#160;</a></span>Clamp() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T1, ArithmeticType T2, ArithmeticType T3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 Harlinn::Math::Clamp </td>
          <td>(</td>
          <td class="paramtype">T1</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2</td>          <td class="paramname"><span class="paramname"><em>minimumValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T3</td>          <td class="paramname"><span class="paramname"><em>maximumValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the value is within [minimumValue, maximumValue], the function returns value, otherwise returns the nearest boundary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any type that supports the <code>&lt;<code> operator. </code></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><code><code> The value to clamp. </code></code></td></tr>
    <tr><td class="paramname">minimumValue</td><td><code><code> The lower boundary. </code></code></td></tr>
    <tr><td class="paramname">maximumValue</td><td><code><code> The upper boundary. </code></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><code> The value within [minimumValue, maximumValue], or the nearest boundary. </code></code></dd></dl>

</div>
</div>
<a id="ae79dd2863aeb176c1b2bda7d8336de98" name="ae79dd2863aeb176c1b2bda7d8336de98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79dd2863aeb176c1b2bda7d8336de98">&#9670;&#160;</a></span>ClampLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ClampLength </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lengthMin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>lengthMax</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamps the length of a vector to a given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector to clamp. </td></tr>
    <tr><td class="paramname">lengthMin</td><td>A vector whose elements are equal to the minimum clamp length. The elements must be greater-than-or-equal to zero. </td></tr>
    <tr><td class="paramname">lengthMax</td><td>A vector whose elements are equal to the maximum clamp length. The elements must be greater-than-or-equal to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a vector whose length is clamped to the specified minimum and maximum. </dd></dl>

</div>
</div>
<a id="a293d0e5b9d9e3e4faf4a2df5408fd359" name="a293d0e5b9d9e3e4faf4a2df5408fd359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293d0e5b9d9e3e4faf4a2df5408fd359">&#9670;&#160;</a></span>ClampLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ClampLength </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>lengthMin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>lengthMax</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamps the length of a vector to a given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector to clamp. </td></tr>
    <tr><td class="paramname">lengthMin</td><td>Minimum clamp length. </td></tr>
    <tr><td class="paramname">lengthMax</td><td>Maximum clamp length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a vector whose length is clamped to the specified minimum and maximum. </dd></dl>

</div>
</div>
<a id="a6c1bab3fb40e39e52c0505619bbe50a2" name="a6c1bab3fb40e39e52c0505619bbe50a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1bab3fb40e39e52c0505619bbe50a2">&#9670;&#160;</a></span>ClampZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ClampZero </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac57f09c85801bdd5cc42aeea627cc386" name="ac57f09c85801bdd5cc42aeea627cc386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57f09c85801bdd5cc42aeea627cc386">&#9670;&#160;</a></span>Conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuaternionOrQuaternionSimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Conjugate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the conjugate of a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conjugate of the quaternion </dd></dl>

</div>
</div>
<a id="a944e35714a357dc8f3e38474c106b36a" name="a944e35714a357dc8f3e38474c106b36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944e35714a357dc8f3e38474c106b36a">&#9670;&#160;</a></span>CopySign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::CopySign </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>magnitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>signValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Composes a floating point value with the magnitude of <code>magnitude</code> and the sign of <code>signValue</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">magnitude</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">signValue</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A floating point value with the magnitude of <code>magnitude</code> and the sign of <code>signValue</code>. </dd></dl>

</div>
</div>
<a id="a551e47906438fa3a4da84c967fbff320" name="a551e47906438fa3a4da84c967fbff320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551e47906438fa3a4da84c967fbff320">&#9670;&#160;</a></span>Cos() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::Cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4f2604b44c3de6b3b69207975eed2eb" name="aa4f2604b44c3de6b3b69207975eed2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f2604b44c3de6b3b69207975eed2eb">&#9670;&#160;</a></span>Cos() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Cos </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cosine of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="a0d43da55ca38ba9238baf6a4655ec621" name="a0d43da55ca38ba9238baf6a4655ec621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d43da55ca38ba9238baf6a4655ec621">&#9670;&#160;</a></span>Cos() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Cos </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the cosine of x given in radians. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cosine of x given in radians. </dd></dl>

</div>
</div>
<a id="a7461c7f210cd8cb3753bac3d7c5c6160" name="a7461c7f210cd8cb3753bac3d7c5c6160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7461c7f210cd8cb3753bac3d7c5c6160">&#9670;&#160;</a></span>CosH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::CosH </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the hyperbolic cosine of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="a411ed8e28031836f4e01e360335d7129" name="a411ed8e28031836f4e01e360335d7129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411ed8e28031836f4e01e360335d7129">&#9670;&#160;</a></span>CosH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::CosH </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the hyperbolic cosine of x. </p>

</div>
</div>
<a id="a9e9d219069f5b092b9390a6920e28fa8" name="a9e9d219069f5b092b9390a6920e28fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9d219069f5b092b9390a6920e28fa8">&#9670;&#160;</a></span>Cross() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Cross </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cross product between v1 and v2. </p>

</div>
</div>
<a id="a9364713636ae2ee902dce90efa5d34ac" name="a9364713636ae2ee902dce90efa5d34ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9364713636ae2ee902dce90efa5d34ac">&#9670;&#160;</a></span>Cross() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Cross </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cross product between v1 and v2. </p>

</div>
</div>
<a id="a68dafb1c605411399bbba722ee3e04ee" name="a68dafb1c605411399bbba722ee3e04ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dafb1c605411399bbba722ee3e04ee">&#9670;&#160;</a></span>Decompose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::Decompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Vector3f::Simd</a> *</td>          <td class="paramname"><span class="paramname"><em>outScale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a>&lt; float &gt;::Simd *</td>          <td class="paramname"><span class="paramname"><em>outRotQuat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Vector3f::Simd</a> *</td>          <td class="paramname"><span class="paramname"><em>outTrans</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a287eb5f21fefd281a70f0477f9913256" name="a287eb5f21fefd281a70f0477f9913256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287eb5f21fefd281a70f0477f9913256">&#9670;&#160;</a></span>Deg2Rad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Deg2Rad </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>angleInDegrees</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an angle in degrees into the corresponding angle in radians. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angleInDegrees</td><td>The angle in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle in radians. </dd></dl>

</div>
</div>
<a id="a90f7f39bed785c1c37775de0789ca8b4" name="a90f7f39bed785c1c37775de0789ca8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f7f39bed785c1c37775de0789ca8b4">&#9670;&#160;</a></span>Degrees()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Degrees </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>rad</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af75812fb4e7f9f181be32dcf8f11a3f6" name="af75812fb4e7f9f181be32dcf8f11a3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75812fb4e7f9f181be32dcf8f11a3f6">&#9670;&#160;</a></span>Determinant() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 2 &gt;::Simd Harlinn::Math::Determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17025574276f6ce1fcc2f3dcfa35a664" name="a17025574276f6ce1fcc2f3dcfa35a664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17025574276f6ce1fcc2f3dcfa35a664">&#9670;&#160;</a></span>Determinant() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4ULL &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the determinant of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix that the determinant will be calculated for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;float,4&gt;::Simd with all the elements set to the determinant of the matrix. </dd></dl>

</div>
</div>
<a id="a5ca0317bd4a434340786be3c4ded4462" name="a5ca0317bd4a434340786be3c4ded4462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca0317bd4a434340786be3c4ded4462">&#9670;&#160;</a></span>Determinant() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 2 &gt;::Simd Harlinn::Math::Determinant </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d260c83ce0585f82db3268998e8003e" name="a5d260c83ce0585f82db3268998e8003e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d260c83ce0585f82db3268998e8003e">&#9670;&#160;</a></span>Determinant() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Determinant </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a473f32ab8024889945e6efd19a2a7c" name="a1a473f32ab8024889945e6efd19a2a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a473f32ab8024889945e6efd19a2a7c">&#9670;&#160;</a></span>Determinant() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Determinant </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab056d5780d63e945050659a902d81827" name="ab056d5780d63e945050659a902d81827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab056d5780d63e945050659a902d81827">&#9670;&#160;</a></span>Determinant() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Determinant </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the determinant of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix that the determinant will be calculated for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;float,4&gt;::Simd with all the elements set to the determinant of the matrix. </dd></dl>

</div>
</div>
<a id="a8663d793ab630d7626d3ed9df0588185" name="a8663d793ab630d7626d3ed9df0588185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8663d793ab630d7626d3ed9df0588185">&#9670;&#160;</a></span>DifferenceOfProducts() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::DifferenceOfProducts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ca7d37b4f5aca693fc56cd26d08f039" name="a2ca7d37b4f5aca693fc56cd26d08f039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca7d37b4f5aca693fc56cd26d08f039">&#9670;&#160;</a></span>DifferenceOfProducts() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdTupleOrArithmeticType S, SimdOrTupleType T, SimdTupleOrArithmeticType U, SimdTupleOrArithmeticType V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::DifferenceOfProducts </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>v4</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the difference between the product of the first and the second argument, and the product of the third and fourth argument. </p>

</div>
</div>
<a id="a919dbd5d34368d35dc39ae109e215816" name="a919dbd5d34368d35dc39ae109e215816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919dbd5d34368d35dc39ae109e215816">&#9670;&#160;</a></span>DifferenceOfProducts() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ta , typename Tb , typename Tc , typename Td &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Ta&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Tb&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Tc&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Td&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::DifferenceOfProducts </td>
          <td>(</td>
          <td class="paramtype">Ta</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tb</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tc</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Td</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff15aade37ccacb452f6c77ca7c65c97" name="aff15aade37ccacb452f6c77ca7c65c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff15aade37ccacb452f6c77ca7c65c97">&#9670;&#160;</a></span>Distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Distance </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the distance between p1 and p2. </p>

</div>
</div>
<a id="a4a213a957f84c2ff45dd040b31ae57be" name="a4a213a957f84c2ff45dd040b31ae57be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a213a957f84c2ff45dd040b31ae57be">&#9670;&#160;</a></span>DistanceSquared() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::DistanceSquared </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the squared distance between p1 and p2. </p>

</div>
</div>
<a id="a291445cde5e5b18624862188adfe8323" name="a291445cde5e5b18624862188adfe8323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291445cde5e5b18624862188adfe8323">&#9670;&#160;</a></span>DistanceSquared() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::DistanceSquared </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the squared distance between p1 and p2. </p>

</div>
</div>
<a id="a9ce27796f7b5a4cb52f8a00dd9cfda57" name="a9ce27796f7b5a4cb52f8a00dd9cfda57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce27796f7b5a4cb52f8a00dd9cfda57">&#9670;&#160;</a></span>DivAdjustDown() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::DivAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ad82a485e04ca81c9a49b8f47e6263c" name="a0ad82a485e04ca81c9a49b8f47e6263c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad82a485e04ca81c9a49b8f47e6263c">&#9670;&#160;</a></span>DivAdjustDown() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::DivAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a203cd558a66fa30b66af04eb1c5029d3" name="a203cd558a66fa30b66af04eb1c5029d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203cd558a66fa30b66af04eb1c5029d3">&#9670;&#160;</a></span>DivAdjustDown() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S::Simd Harlinn::Math::DivAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09a07d6a2a096115ebcff9fc1e8bde70" name="a09a07d6a2a096115ebcff9fc1e8bde70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a07d6a2a096115ebcff9fc1e8bde70">&#9670;&#160;</a></span>DivAdjustDown() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::DivAdjustDown </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88c846bb8205b6c037a2fb8cffac719d" name="a88c846bb8205b6c037a2fb8cffac719d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c846bb8205b6c037a2fb8cffac719d">&#9670;&#160;</a></span>DivAdjustUp() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::DivAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a074274f3a2a072ec34a50c73cb0d5187" name="a074274f3a2a072ec34a50c73cb0d5187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074274f3a2a072ec34a50c73cb0d5187">&#9670;&#160;</a></span>DivAdjustUp() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::DivAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a1914b2720651f8581fde0dd1868e19" name="a7a1914b2720651f8581fde0dd1868e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1914b2720651f8581fde0dd1868e19">&#9670;&#160;</a></span>DivAdjustUp() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S::Simd Harlinn::Math::DivAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18c4e7d809288dbc2f8e7223b3940e3d" name="a18c4e7d809288dbc2f8e7223b3940e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c4e7d809288dbc2f8e7223b3940e3d">&#9670;&#160;</a></span>DivAdjustUp() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::DivAdjustUp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f4fd2ee195df3f51c259fc4e475581d" name="a0f4fd2ee195df3f51c259fc4e475581d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4fd2ee195df3f51c259fc4e475581d">&#9670;&#160;</a></span>Dot() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneSimdType P, NormalSimdType N&gt; <br />
requires std::is_same_v&lt;typename P::value_type, typename N::value_type&gt; &amp;&amp; ( N::Size &gt; 2 )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">N Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const P &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N &amp;</td>          <td class="paramname"><span class="paramname"><em>normal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed35007e0c5073bfb1c4ee2dcb6d5dbb" name="aed35007e0c5073bfb1c4ee2dcb6d5dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed35007e0c5073bfb1c4ee2dcb6d5dbb">&#9670;&#160;</a></span>Dot() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneSimdType P, PointSimdType PT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PT Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const P &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PT &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d7a3c2ca0c0e99ed82e08fdc5581c9b" name="a9d7a3c2ca0c0e99ed82e08fdc5581c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7a3c2ca0c0e99ed82e08fdc5581c9b">&#9670;&#160;</a></span>Dot() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneType P, Internal::VectorNormalOrPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const P &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03db02bfb723a9ee8f38466c25a870eb" name="a03db02bfb723a9ee8f38466c25a870eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03db02bfb723a9ee8f38466c25a870eb">&#9670;&#160;</a></span>Dot() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneSimdType P, VectorSimdType V&gt; <br />
requires std::is_same_v&lt;typename P::value_type, typename V::value_type&gt; &amp;&amp; ( V::Size &gt; 2 )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const P &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ed3e7b2f7bcdb1ebea8d4eb3164a0ee" name="a7ed3e7b2f7bcdb1ebea8d4eb3164a0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed3e7b2f7bcdb1ebea8d4eb3164a0ee">&#9670;&#160;</a></span>Dot() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product of two quaternions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>The first quaternion. </td></tr>
    <tr><td class="paramname">q2</td><td>The second quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product between q1 and q2. </dd></dl>

</div>
</div>
<a id="ad7199183ff90ab7a9cb9f547107b15f6" name="ad7199183ff90ab7a9cb9f547107b15f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7199183ff90ab7a9cb9f547107b15f6">&#9670;&#160;</a></span>Dot() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Internal::VectorNormalOrPointSimdType T, PlaneSimdType P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58ef4fecdb929d9eab252bb3ec07f3df" name="a58ef4fecdb929d9eab252bb3ec07f3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ef4fecdb929d9eab252bb3ec07f3df">&#9670;&#160;</a></span>Dot() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product between v1 and v2. </p>

</div>
</div>
<a id="a535a11852e78c12e2e2f04411ea4668c" name="a535a11852e78c12e2e2f04411ea4668c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535a11852e78c12e2e2f04411ea4668c">&#9670;&#160;</a></span>Dot() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#ae8eda03ef4993145c2888150d80a2892">Internal::HasSimdType</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product between v1 and v2. </p>

</div>
</div>
<a id="a89da23e53a5cdd7dd0b69848e1a7d1ec" name="a89da23e53a5cdd7dd0b69848e1a7d1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89da23e53a5cdd7dd0b69848e1a7d1ec">&#9670;&#160;</a></span>Dot() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T, TupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::Simd Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc007fbeb8421fdc50933caf130913cc" name="abc007fbeb8421fdc50933caf130913cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc007fbeb8421fdc50933caf130913cc">&#9670;&#160;</a></span>Dot() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int mask, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product between v1 and v2. </p>

</div>
</div>
<a id="a7c33afe9b1a3559e46c7e720d3b405fd" name="a7c33afe9b1a3559e46c7e720d3b405fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c33afe9b1a3559e46c7e720d3b405fd">&#9670;&#160;</a></span>Dot() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int mask, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#ae8eda03ef4993145c2888150d80a2892">Internal::HasSimdType</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product between v1 and v2. </p>

</div>
</div>
<a id="a2de2193bfc79a047f22aaf2b7a6ba143" name="a2de2193bfc79a047f22aaf2b7a6ba143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de2193bfc79a047f22aaf2b7a6ba143">&#9670;&#160;</a></span>Dot() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product between v1 and v2. </p>

</div>
</div>
<a id="a8c83ecd1022852cb347f6d5e3fced583" name="a8c83ecd1022852cb347f6d5e3fced583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c83ecd1022852cb347f6d5e3fced583">&#9670;&#160;</a></span>Dot() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int mask, SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product between v1 and v2. </p>

</div>
</div>
<a id="a3bda914e3dc04887ca615396e6b8ddbe" name="a3bda914e3dc04887ca615396e6b8ddbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bda914e3dc04887ca615396e6b8ddbe">&#9670;&#160;</a></span>Dot() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product between v1 and v2. </p>

</div>
</div>
<a id="affa0f41540e80c0195e72bc4c7d754cf" name="affa0f41540e80c0195e72bc4c7d754cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa0f41540e80c0195e72bc4c7d754cf">&#9670;&#160;</a></span>Dot() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int mask, ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Dot </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product between v1 and v2. </p>

</div>
</div>
<a id="a7b7ede4f997d25fa6322ee6ecaec82f3" name="a7b7ede4f997d25fa6322ee6ecaec82f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7ede4f997d25fa6322ee6ecaec82f3">&#9670;&#160;</a></span>Equal() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Equal </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of lhs and the corresponding elements of rhs are less or equally apart than the corresponding element of epsilon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second source of values for the comparison. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The source of the maximum difference between the corresponding elements from lhs and rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element of lhs and the corresponding elements of rhs are less or equally apart than the corresponding element of epsilon, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a3786da90ad366be782c78b985b6cb96c" name="a3786da90ad366be782c78b985b6cb96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3786da90ad366be782c78b985b6cb96c">&#9670;&#160;</a></span>Equal() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Equal </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of lhs and the corresponding elements of rhs are less or equally apart than the value of epsilon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second source of values for the comparison. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The maximum difference between the elements from lhs and rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element of lhs and the corresponding elements of rhs are less or equally apart than the value of epsilon, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a447102ec652e2402fbf88cf3d89649ab" name="a447102ec652e2402fbf88cf3d89649ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447102ec652e2402fbf88cf3d89649ab">&#9670;&#160;</a></span>Equal() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Equal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are equal to the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is equal to the corresponding element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a30d983cae78dbec75ca17aeabe925632" name="a30d983cae78dbec75ca17aeabe925632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d983cae78dbec75ca17aeabe925632">&#9670;&#160;</a></span>Equal() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Equal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are equal to value. </p>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is equal to value, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a5923e20f171808bd73077a9e97405f46" name="a5923e20f171808bd73077a9e97405f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5923e20f171808bd73077a9e97405f46">&#9670;&#160;</a></span>Equal() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Equal </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is equal to the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>If value is equal to an element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="ae4f6c4777e84c93e44097c6ba4cad0cc" name="ae4f6c4777e84c93e44097c6ba4cad0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f6c4777e84c93e44097c6ba4cad0cc">&#9670;&#160;</a></span>Erf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Erf </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the error function of x. </p>

</div>
</div>
<a id="a97e70557966a2c5b0b4d31a700e3288d" name="a97e70557966a2c5b0b4d31a700e3288d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e70557966a2c5b0b4d31a700e3288d">&#9670;&#160;</a></span>ErfC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ErfC </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the complementary error function of x,. </p>

</div>
</div>
<a id="ab44d390f796b302e52de71eaebf5c575" name="ab44d390f796b302e52de71eaebf5c575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44d390f796b302e52de71eaebf5c575">&#9670;&#160;</a></span>ErfInv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::ErfInv </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2190472cc7adb81414f6993d6b4e5bf7" name="a2190472cc7adb81414f6993d6b4e5bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2190472cc7adb81414f6993d6b4e5bf7">&#9670;&#160;</a></span>EvaluatePolynomial() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, typename C &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad60f420a7f44c2b0e9ce86950287dbad">IsArithmetic</a>&lt;C&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::EvaluatePolynomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the provided polynomial using Horners method. </p>

</div>
</div>
<a id="a47e302fb6b84bde82518df179fd9d48a" name="a47e302fb6b84bde82518df179fd9d48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e302fb6b84bde82518df179fd9d48a">&#9670;&#160;</a></span>EvaluatePolynomial() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType C&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, C&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::EvaluatePolynomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4d6211a8d07a03ef52fd3097ec3c4c2" name="aa4d6211a8d07a03ef52fd3097ec3c4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d6211a8d07a03ef52fd3097ec3c4c2">&#9670;&#160;</a></span>EvaluatePolynomial() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, typename C , typename... Args&gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad60f420a7f44c2b0e9ce86950287dbad">IsArithmetic</a>&lt;C&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::EvaluatePolynomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>remaining</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5851f79483b25f96c650e89760f0cc0" name="aa5851f79483b25f96c650e89760f0cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5851f79483b25f96c650e89760f0cc0">&#9670;&#160;</a></span>EvaluatePolynomial() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T, typename C , typename... Args&gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad60f420a7f44c2b0e9ce86950287dbad">IsArithmetic</a>&lt;C&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::Simd Harlinn::Math::EvaluatePolynomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>remaining</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0e1d8d127f16b3f44186a7e950c432d" name="ac0e1d8d127f16b3f44186a7e950c432d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e1d8d127f16b3f44186a7e950c432d">&#9670;&#160;</a></span>EvaluatePolynomial() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType C, typename... Args&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, C&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::EvaluatePolynomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>remaining</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad98e2fca6354ae2a10ba9207edad767c" name="ad98e2fca6354ae2a10ba9207edad767c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98e2fca6354ae2a10ba9207edad767c">&#9670;&#160;</a></span>EvaluatePolynomial() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T, SimdType C, typename... Args&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, C&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::Simd Harlinn::Math::EvaluatePolynomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>remaining</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5444782bd8dc7d8a07cd7301d838779d" name="a5444782bd8dc7d8a07cd7301d838779d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5444782bd8dc7d8a07cd7301d838779d">&#9670;&#160;</a></span>EvaluatePolynomial() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, ArithmeticType C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::EvaluatePolynomial </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f960d3c2e0495e046afd61dadaa79e7" name="a3f960d3c2e0495e046afd61dadaa79e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f960d3c2e0495e046afd61dadaa79e7">&#9670;&#160;</a></span>EvaluatePolynomial() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, ArithmeticType C, ArithmeticType ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::EvaluatePolynomial </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>remaining</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a806f968580b0257d965065603809d962" name="a806f968580b0257d965065603809d962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806f968580b0257d965065603809d962">&#9670;&#160;</a></span>Exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Exp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates $$e$$ (Euler's number, 2.7182818...), raised to the power of each element in the argument. </p>

</div>
</div>
<a id="a6428494411c1e568a42260a6fff1a039" name="a6428494411c1e568a42260a6fff1a039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6428494411c1e568a42260a6fff1a039">&#9670;&#160;</a></span>Exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Exp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes <code>e</code>, <code>2.7182818</code>, raised to the given power <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>e</code> raised to the given power <code>x</code>. </dd></dl>

</div>
</div>
<a id="a29845cbe4869b9e544f14827cc6be1df" name="a29845cbe4869b9e544f14827cc6be1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29845cbe4869b9e544f14827cc6be1df">&#9670;&#160;</a></span>Exp10() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Exp10 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the base-10 exponential of each element in the argument. </p>

</div>
</div>
<a id="acbb84f068c23042c9c463b712f33dede" name="acbb84f068c23042c9c463b712f33dede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb84f068c23042c9c463b712f33dede">&#9670;&#160;</a></span>Exp10() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Exp10 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23873c748c37959a4325dfac0e63ca43" name="a23873c748c37959a4325dfac0e63ca43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23873c748c37959a4325dfac0e63ca43">&#9670;&#160;</a></span>Exp2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Exp2 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the base-2 exponential of each element in the argument. </p>

</div>
</div>
<a id="a166010e3997ade67ad719863effd4ee2" name="a166010e3997ade67ad719863effd4ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166010e3997ade67ad719863effd4ee2">&#9670;&#160;</a></span>Exp2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Exp2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4918974e22475001414044815a56fff6" name="a4918974e22475001414044815a56fff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4918974e22475001414044815a56fff6">&#9670;&#160;</a></span>ExpM1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ExpM1 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates $$e$$ (Euler's number, 2.7182818...), raised to the power of each element in the argument, $$-1.0$$. </p>

</div>
</div>
<a id="a110386df7e88bc94c563e0a14aee5874" name="a110386df7e88bc94c563e0a14aee5874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110386df7e88bc94c563e0a14aee5874">&#9670;&#160;</a></span>ExpM1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ExpM1 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2898a3e441771575e51af64629443aa2" name="a2898a3e441771575e51af64629443aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2898a3e441771575e51af64629443aa2">&#9670;&#160;</a></span>FastAbs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FastAbs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of each element held by the argument. </p>

</div>
</div>
<a id="af0e3e2ceb3d61d3caba576478f914b18" name="af0e3e2ceb3d61d3caba576478f914b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e3e2ceb3d61d3caba576478f914b18">&#9670;&#160;</a></span>FastAbs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;UnsignedIntegerType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FastAbs </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44c55b5799f42e0976196d5ad27e9e88" name="a44c55b5799f42e0976196d5ad27e9e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c55b5799f42e0976196d5ad27e9e88">&#9670;&#160;</a></span>FastATan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FastATan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse tangent of each element in the argument, in radians. </p>

</div>
</div>
<a id="a182b6b9d78f9849bfb481babcc85f358" name="a182b6b9d78f9849bfb481babcc85f358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182b6b9d78f9849bfb481babcc85f358">&#9670;&#160;</a></span>FastATan2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FastATan2 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse tangent of each element in x divided by the corresponding element in y, in radians. </p>

</div>
</div>
<a id="a26aa9b0281a6223877e9f1abd15c37f9" name="a26aa9b0281a6223877e9f1abd15c37f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26aa9b0281a6223877e9f1abd15c37f9">&#9670;&#160;</a></span>FastCos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FastCos </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cosine of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="aacdd066b5a9e689f03cb24b5ade46858" name="aacdd066b5a9e689f03cb24b5ade46858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdd066b5a9e689f03cb24b5ade46858">&#9670;&#160;</a></span>FastExp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Harlinn::Math::FastExp </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11ebf37928155c37ee910907857d117e" name="a11ebf37928155c37ee910907857d117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ebf37928155c37ee910907857d117e">&#9670;&#160;</a></span>FastLog2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FastLog2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3322322c3cf836f49ec67026997b6a1" name="ac3322322c3cf836f49ec67026997b6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3322322c3cf836f49ec67026997b6a1">&#9670;&#160;</a></span>FastNormalize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneSimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FastNormalize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9230cc0fe52a8708cdced54d8ddc121" name="af9230cc0fe52a8708cdced54d8ddc121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9230cc0fe52a8708cdced54d8ddc121">&#9670;&#160;</a></span>FastNormalize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::Simd Harlinn::Math::FastNormalize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac649d582494620f306d07ff202ce287a" name="ac649d582494620f306d07ff202ce287a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac649d582494620f306d07ff202ce287a">&#9670;&#160;</a></span>FastPow() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FastPow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a709296e6bc85fea1f90f0c07fe3d2ac3" name="a709296e6bc85fea1f90f0c07fe3d2ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709296e6bc85fea1f90f0c07fe3d2ac3">&#9670;&#160;</a></span>FastPow() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, TupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::Simd Harlinn::Math::FastPow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c5df1ed760186c3526db07be164a95f" name="a1c5df1ed760186c3526db07be164a95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5df1ed760186c3526db07be164a95f">&#9670;&#160;</a></span>FastPow() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FastPow </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05fe4772620490929181e53fe6825abe" name="a05fe4772620490929181e53fe6825abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fe4772620490929181e53fe6825abe">&#9670;&#160;</a></span>FastSin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FastSin </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the sine of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="a4a8aa947ced76e3fafcffd99f974c86b" name="a4a8aa947ced76e3fafcffd99f974c86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8aa947ced76e3fafcffd99f974c86b">&#9670;&#160;</a></span>FastSinCos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FastSinCos </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>cosines</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the sine and cosine of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="ae576d139ee4b7472146cfe608385b089" name="ae576d139ee4b7472146cfe608385b089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae576d139ee4b7472146cfe608385b089">&#9670;&#160;</a></span>FastSinCos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::Simd Harlinn::Math::FastSinCos </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename T::Simd *</td>          <td class="paramname"><span class="paramname"><em>cosines</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the sine and cosine of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="aca8beede0d8813f97fce2e613b4e447a" name="aca8beede0d8813f97fce2e613b4e447a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8beede0d8813f97fce2e613b4e447a">&#9670;&#160;</a></span>FastTan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FastTan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the tangent of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="aea80d9a0e521738b3a6318b731b16a96" name="aea80d9a0e521738b3a6318b731b16a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea80d9a0e521738b3a6318b731b16a96">&#9670;&#160;</a></span>FDim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FDim </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive difference between x and y, that is, if x &gt; y, returns x - y, otherwise (i.e. if x &lt;= y) returns +0. </p>

</div>
</div>
<a id="a516b8f4a37a50a03f4fee69f43d2cd2a" name="a516b8f4a37a50a03f4fee69f43d2cd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516b8f4a37a50a03f4fee69f43d2cd2a">&#9670;&#160;</a></span>FindInterval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Harlinn::Math::FindInterval </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>sz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac619a6c5d7a37ce346ac98a0e829cad5" name="ac619a6c5d7a37ce346ac98a0e829cad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac619a6c5d7a37ce346ac98a0e829cad5">&#9670;&#160;</a></span>First()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::First </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the lowest element of v. </p>

</div>
</div>
<a id="a538a2f0dc4ebc31bc5bb59fc1ce7c0ce" name="a538a2f0dc4ebc31bc5bb59fc1ce7c0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538a2f0dc4ebc31bc5bb59fc1ce7c0ce">&#9670;&#160;</a></span>Floor() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::Floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86191c95207f1ccf8ebeeec6d502b4ab" name="a86191c95207f1ccf8ebeeec6d502b4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86191c95207f1ccf8ebeeec6d502b4ab">&#9670;&#160;</a></span>Floor() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Floor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floor of each element held by the argument. </p>

</div>
</div>
<a id="a4ca557701706f3bde4dbbc1a9fa9e582" name="a4ca557701706f3bde4dbbc1a9fa9e582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca557701706f3bde4dbbc1a9fa9e582">&#9670;&#160;</a></span>Floor() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Floor </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just returns value. </p>
<p>Computes the largest integer value not greater than value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest integer value not greater than value. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value </dd></dl>

</div>
</div>
<a id="a1e716ee76fcedc06477de9f2be173a7a" name="a1e716ee76fcedc06477de9f2be173a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e716ee76fcedc06477de9f2be173a7a">&#9670;&#160;</a></span>Floor() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_point_t.html">Harlinn::Windows::PointT</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cvref_t&lt; T &gt; Harlinn::Math::Floor </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68598df2fe024d131d276cd153efbe9e" name="a68598df2fe024d131d276cd153efbe9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68598df2fe024d131d276cd153efbe9e">&#9670;&#160;</a></span>Floor() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_size_t.html">Harlinn::Windows::SizeT</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cvref_t&lt; T &gt; Harlinn::Math::Floor </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadfbe4e59af9d12e0c9afd4e321412f2" name="aadfbe4e59af9d12e0c9afd4e321412f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfbe4e59af9d12e0c9afd4e321412f2">&#9670;&#160;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47cb5da363ace69a1f680c9bb0ea2d3a" name="a47cb5da363ace69a1f680c9bb0ea2d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cb5da363ace69a1f680c9bb0ea2d3a">&#9670;&#160;</a></span>FMA() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::FMA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab26ed47759c5354a0aee09bfb813a4bf" name="ab26ed47759c5354a0aee09bfb813a4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26ed47759c5354a0aee09bfb813a4bf">&#9670;&#160;</a></span>FMA() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMA </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a281d41749c37640b9c308f5f935516f5" name="a281d41749c37640b9c308f5f935516f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281d41749c37640b9c308f5f935516f5">&#9670;&#160;</a></span>FMA() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMA </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a9094cfad7ecce58dd645c2cb26474021" name="a9094cfad7ecce58dd645c2cb26474021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9094cfad7ecce58dd645c2cb26474021">&#9670;&#160;</a></span>FMA() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMA </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="ab8af2ff67edaadc52bd7f74e654c777e" name="ab8af2ff67edaadc52bd7f74e654c777e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8af2ff67edaadc52bd7f74e654c777e">&#9670;&#160;</a></span>FMA() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMA </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a6d4e3ad7a02f640e47366b6853cacf37" name="a6d4e3ad7a02f640e47366b6853cacf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4e3ad7a02f640e47366b6853cacf37">&#9670;&#160;</a></span>FMA() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMA </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="adc83459380542f5d0a206d5242845ef5" name="adc83459380542f5d0a206d5242845ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc83459380542f5d0a206d5242845ef5">&#9670;&#160;</a></span>FMA() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMA </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a6c89319ecc8dc904aedd0c7b30ad56a8" name="a6c89319ecc8dc904aedd0c7b30ad56a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c89319ecc8dc904aedd0c7b30ad56a8">&#9670;&#160;</a></span>FMA() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMA </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a2a3f0ef08e5b9af0476fb7ef9d395005" name="a2a3f0ef08e5b9af0476fb7ef9d395005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3f0ef08e5b9af0476fb7ef9d395005">&#9670;&#160;</a></span>FMA() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMA </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a6f4d3e0d3dbb72267d64dd998e7daefe" name="a6f4d3e0d3dbb72267d64dd998e7daefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4d3e0d3dbb72267d64dd998e7daefe">&#9670;&#160;</a></span>FMA() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IntegerType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FMA </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes x * y + z. </p>
<p>Computes x * y + z as if to infinite precision and rounded only once to fit the result type. </p>

</div>
</div>
<a id="a43b54d3ee46859cbde89486d392b17fa" name="a43b54d3ee46859cbde89486d392b17fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b54d3ee46859cbde89486d392b17fa">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a844d22a670a4d5feb0442825cf692dd6" name="a844d22a670a4d5feb0442825cf692dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844d22a670a4d5feb0442825cf692dd6">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, TupleType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a6d038320f1e1484d7071b739c97d5c6f" name="a6d038320f1e1484d7071b739c97d5c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d038320f1e1484d7071b739c97d5c6f">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, TupleType T, TupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a23e243ae1456f282199c34591c10ae43" name="a23e243ae1456f282199c34591c10ae43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e243ae1456f282199c34591c10ae43">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a1d030d2e8569d47fdb063b27a53c33d9" name="a1d030d2e8569d47fdb063b27a53c33d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d030d2e8569d47fdb063b27a53c33d9">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , SimdType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="aeb442c09fa65c5dbad4bd1b8ab83961d" name="aeb442c09fa65c5dbad4bd1b8ab83961d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb442c09fa65c5dbad4bd1b8ab83961d">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , TupleType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a08b203902707ebce390b9255a7b7ab94" name="a08b203902707ebce390b9255a7b7ab94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b203902707ebce390b9255a7b7ab94">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="ada06eb08176b89693d95f02bb1d69398" name="ada06eb08176b89693d95f02bb1d69398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada06eb08176b89693d95f02bb1d69398">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , SimdType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a728238ae7ab7958aefe5492d63979d53" name="a728238ae7ab7958aefe5492d63979d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728238ae7ab7958aefe5492d63979d53">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , TupleType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="aa4998e180bead63df218dc87351854f1" name="aa4998e180bead63df218dc87351854f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4998e180bead63df218dc87351854f1">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a0eb4e84b2e36d4607c03d4d703d3c5f8" name="a0eb4e84b2e36d4607c03d4d703d3c5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb4e84b2e36d4607c03d4d703d3c5f8">&#9670;&#160;</a></span>FMAAdjustDown() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FMAAdjustDown </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a963d5366391bf28fad1dc92cef0c8650" name="a963d5366391bf28fad1dc92cef0c8650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963d5366391bf28fad1dc92cef0c8650">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a3fb099a8b9ab60811aea24071d683f89" name="a3fb099a8b9ab60811aea24071d683f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb099a8b9ab60811aea24071d683f89">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, TupleType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a4e18cc03321cdb7178f68efc82edee80" name="a4e18cc03321cdb7178f68efc82edee80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e18cc03321cdb7178f68efc82edee80">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, TupleType T, TupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a3b2138cf0403a76a9f01a069cb8858a2" name="a3b2138cf0403a76a9f01a069cb8858a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2138cf0403a76a9f01a069cb8858a2">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="ad98e3f9abf59e917582f16e7d3749ae9" name="ad98e3f9abf59e917582f16e7d3749ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98e3f9abf59e917582f16e7d3749ae9">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , SimdType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a659dbcd6f443dbcff7d0a9d39dc44f76" name="a659dbcd6f443dbcff7d0a9d39dc44f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659dbcd6f443dbcff7d0a9d39dc44f76">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , TupleType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a4080d1c773e9b29db1dad5cb95f84f49" name="a4080d1c773e9b29db1dad5cb95f84f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4080d1c773e9b29db1dad5cb95f84f49">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a01d6ba1326feac82c6dc11db4110fd49" name="a01d6ba1326feac82c6dc11db4110fd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d6ba1326feac82c6dc11db4110fd49">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , SimdType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="afbcf4e69931fb6948645fa5e67a06fe3" name="afbcf4e69931fb6948645fa5e67a06fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcf4e69931fb6948645fa5e67a06fe3">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , TupleType T, SimdType U&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a32d1a6298de6409171125936f2f120d8" name="a32d1a6298de6409171125936f2f120d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d1a6298de6409171125936f2f120d8">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberT , TupleType T, TupleType U, typename ResultT  = typename T::Simd&gt; <br />
requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c. </p>

</div>
</div>
<a id="a8eb87270bbb9896e7916a87e0ea1847f" name="a8eb87270bbb9896e7916a87e0ea1847f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb87270bbb9896e7916a87e0ea1847f">&#9670;&#160;</a></span>FMAAdjustUp() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FMAAdjustUp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbb45e8eaca792baeb4592644b9952ec" name="adbb45e8eaca792baeb4592644b9952ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb45e8eaca792baeb4592644b9952ec">&#9670;&#160;</a></span>FMAddSub() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMAddSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="aa3e5d5c5c0184c75d21feebab451eed3" name="aa3e5d5c5c0184c75d21feebab451eed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e5d5c5c0184c75d21feebab451eed3">&#9670;&#160;</a></span>FMAddSub() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMAddSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a2c9e089112451c9b388d530770f61e6d" name="a2c9e089112451c9b388d530770f61e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9e089112451c9b388d530770f61e6d">&#9670;&#160;</a></span>FMAddSub() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMAddSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a15ade8f9985f5536c2efc21a9a03921f" name="a15ade8f9985f5536c2efc21a9a03921f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ade8f9985f5536c2efc21a9a03921f">&#9670;&#160;</a></span>FMAddSub() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMAddSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a627eae104458501581a7a87856db3402" name="a627eae104458501581a7a87856db3402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627eae104458501581a7a87856db3402">&#9670;&#160;</a></span>FMAddSub() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMAddSub </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a184f4ddfe3f3c6e73a8038e111009d9d" name="a184f4ddfe3f3c6e73a8038e111009d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184f4ddfe3f3c6e73a8038e111009d9d">&#9670;&#160;</a></span>FMAddSub() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMAddSub </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a7e6edb3132771ea8d34312cd55bd1a2e" name="a7e6edb3132771ea8d34312cd55bd1a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6edb3132771ea8d34312cd55bd1a2e">&#9670;&#160;</a></span>FMAddSub() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMAddSub </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are added to the intermediate results while the even values are subtracted from them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a7fcd184cdeb070c8ddc099fd62c411bf" name="a7fcd184cdeb070c8ddc099fd62c411bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcd184cdeb070c8ddc099fd62c411bf">&#9670;&#160;</a></span>FMod() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMod </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation $x/y$. </p>

</div>
</div>
<a id="a1503d6a59b4562f3c33e6ec1171b9f1c" name="a1503d6a59b4562f3c33e6ec1171b9f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1503d6a59b4562f3c33e6ec1171b9f1c">&#9670;&#160;</a></span>FMod() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMod </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation $x/y$. </p>

</div>
</div>
<a id="afef8e8e0e4ae9d41ef85300aeed0e632" name="afef8e8e0e4ae9d41ef85300aeed0e632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef8e8e0e4ae9d41ef85300aeed0e632">&#9670;&#160;</a></span>FMod() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMod </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation $x/y$. </p>

</div>
</div>
<a id="af900bfc00f653db100dc034d29ff1210" name="af900bfc00f653db100dc034d29ff1210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af900bfc00f653db100dc034d29ff1210">&#9670;&#160;</a></span>FMod() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FMod </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the point remainder of the division operation <code>x / y</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FloatT</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The floating point remainder of the division operation <code>x / y</code>. </dd></dl>

</div>
</div>
<a id="a64a5225e1c7e4e18d30e8d569687fa2a" name="a64a5225e1c7e4e18d30e8d569687fa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a5225e1c7e4e18d30e8d569687fa2a">&#9670;&#160;</a></span>FMSub() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a53e51e7b4b00012bbdfc03b703bc5ef8" name="a53e51e7b4b00012bbdfc03b703bc5ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e51e7b4b00012bbdfc03b703bc5ef8">&#9670;&#160;</a></span>FMSub() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="ae09831378edaed0491c1eaa0d82323fb" name="ae09831378edaed0491c1eaa0d82323fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09831378edaed0491c1eaa0d82323fb">&#9670;&#160;</a></span>FMSub() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a51f69e770f8935264a48c73648b0b3ac" name="a51f69e770f8935264a48c73648b0b3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f69e770f8935264a48c73648b0b3ac">&#9670;&#160;</a></span>FMSub() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a4b6b350c0fb47917b2e777c1911b0e66" name="a4b6b350c0fb47917b2e777c1911b0e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6b350c0fb47917b2e777c1911b0e66">&#9670;&#160;</a></span>FMSub() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSub </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a8d4d2bbd455b44aebae1cb159013bb94" name="a8d4d2bbd455b44aebae1cb159013bb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4d2bbd455b44aebae1cb159013bb94">&#9670;&#160;</a></span>FMSub() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSub </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a87f448711076178ad0de3e3f917f7031" name="a87f448711076178ad0de3e3f917f7031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f448711076178ad0de3e3f917f7031">&#9670;&#160;</a></span>FMSub() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSub </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the infinite precision intermediate results are obtained. From the infinite precision intermediate results, the values in the third operand, c, are subtracted. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="ab822d2ce6b9c686ec76750d89393abcb" name="ab822d2ce6b9c686ec76750d89393abcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab822d2ce6b9c686ec76750d89393abcb">&#9670;&#160;</a></span>FMSubAdd() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSubAdd </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="aef65845d14791025b4830c1c1883d0f2" name="aef65845d14791025b4830c1c1883d0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef65845d14791025b4830c1c1883d0f2">&#9670;&#160;</a></span>FMSubAdd() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSubAdd </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="aa2be679018b3ff35ca04fcb45c32d1f9" name="aa2be679018b3ff35ca04fcb45c32d1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2be679018b3ff35ca04fcb45c32d1f9">&#9670;&#160;</a></span>FMSubAdd() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSubAdd </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a822f6c58d7b89eb84b17e3efa9350ab9" name="a822f6c58d7b89eb84b17e3efa9350ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822f6c58d7b89eb84b17e3efa9350ab9">&#9670;&#160;</a></span>FMSubAdd() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSubAdd </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="aaf32d3342e3592b61143817d17fa01e0" name="aaf32d3342e3592b61143817d17fa01e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf32d3342e3592b61143817d17fa01e0">&#9670;&#160;</a></span>FMSubAdd() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSubAdd </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="ac07bb80fd7c1af62cb74ff72b7731bc2" name="ac07bb80fd7c1af62cb74ff72b7731bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07bb80fd7c1af62cb74ff72b7731bc2">&#9670;&#160;</a></span>FMSubAdd() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSubAdd </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a898ec216277e9f9dea3c60bf27f9c9cc" name="a898ec216277e9f9dea3c60bf27f9c9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898ec216277e9f9dea3c60bf27f9c9cc">&#9670;&#160;</a></span>FMSubAdd() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FMSubAdd </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, c, are subtracted from the intermediate results while the even values are added to them. The final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="adbacf3c8b5359ea3bc2e6a0d106e1638" name="adbacf3c8b5359ea3bc2e6a0d106e1638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbacf3c8b5359ea3bc2e6a0d106e1638">&#9670;&#160;</a></span>FNMAdd() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMAdd </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a6c1a58a6fa3446ad633c965415bd0f55" name="a6c1a58a6fa3446ad633c965415bd0f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1a58a6fa3446ad633c965415bd0f55">&#9670;&#160;</a></span>FNMAdd() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMAdd </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a6798fe5e5d19ac2b7a939263a96ddf25" name="a6798fe5e5d19ac2b7a939263a96ddf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6798fe5e5d19ac2b7a939263a96ddf25">&#9670;&#160;</a></span>FNMAdd() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMAdd </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a7b56cbb4097d6cd7f6cb555aa62b8e5e" name="a7b56cbb4097d6cd7f6cb555aa62b8e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b56cbb4097d6cd7f6cb555aa62b8e5e">&#9670;&#160;</a></span>FNMAdd() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMAdd </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a6ffd73b607497ae6998b78963b074ffd" name="a6ffd73b607497ae6998b78963b074ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffd73b607497ae6998b78963b074ffd">&#9670;&#160;</a></span>FNMAdd() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMAdd </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a66111f12cf6c2119b936c8b27e8a3541" name="a66111f12cf6c2119b936c8b27e8a3541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66111f12cf6c2119b936c8b27e8a3541">&#9670;&#160;</a></span>FNMAdd() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMAdd </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="a76416f4792002a3835be04bbaebdea50" name="a76416f4792002a3835be04bbaebdea50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76416f4792002a3835be04bbaebdea50">&#9670;&#160;</a></span>FNMAdd() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMAdd </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, a and b, are multiplied and the negated infinite precision intermediate results are added to the values in the third operand, c, after which the final results are rounded to the nearest floating point values. </p>

</div>
</div>
<a id="aa39f5bb4c2a5a6bd80cf0cf92dd2254e" name="aa39f5bb4c2a5a6bd80cf0cf92dd2254e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39f5bb4c2a5a6bd80cf0cf92dd2254e">&#9670;&#160;</a></span>FNMSub() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value. </p>

</div>
</div>
<a id="a0fa5b0e9a338d1eac12c24099a357cff" name="a0fa5b0e9a338d1eac12c24099a357cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa5b0e9a338d1eac12c24099a357cff">&#9670;&#160;</a></span>FNMSub() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value. </p>

</div>
</div>
<a id="ab7b1fae16725b6c6912cd7d7dc4adf8b" name="ab7b1fae16725b6c6912cd7d7dc4adf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b1fae16725b6c6912cd7d7dc4adf8b">&#9670;&#160;</a></span>FNMSub() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value. </p>

</div>
</div>
<a id="a3f9fc01fcbb146431b021ad4f5abd786" name="a3f9fc01fcbb146431b021ad4f5abd786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9fc01fcbb146431b021ad4f5abd786">&#9670;&#160;</a></span>FNMSub() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMSub </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value. </p>

</div>
</div>
<a id="ac38b1067ea2bd62e831dfff3a3de6ab9" name="ac38b1067ea2bd62e831dfff3a3de6ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38b1067ea2bd62e831dfff3a3de6ab9">&#9670;&#160;</a></span>FNMSub() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMSub </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value. </p>

</div>
</div>
<a id="a71ef6a65f0303050455f6c0ad677b0f3" name="a71ef6a65f0303050455f6c0ad677b0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ef6a65f0303050455f6c0ad677b0f3">&#9670;&#160;</a></span>FNMSub() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMSub </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value. </p>

</div>
</div>
<a id="aa1af49997109d0c21835c03ed78ddea9" name="aa1af49997109d0c21835c03ed78ddea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af49997109d0c21835c03ed78ddea9">&#9670;&#160;</a></span>FNMSub() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::FNMSub </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, are multiplied and the negated infinite precision intermediate result is obtained. From this negated intermediate result, the value in the third operand, c, is subtracted. The final result is rounded to the nearest floating point value. </p>

</div>
</div>
<a id="a5e1b449cb003cb62aa480994c172b55b" name="a5e1b449cb003cb62aa480994c172b55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1b449cb003cb62aa480994c172b55b">&#9670;&#160;</a></span>FRExp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; T, int &gt; Harlinn::Math::FRExp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decomposes the given floating point value val into a normalized fraction and an integral power of two. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair&lt;&gt;&gt; with the normalized fraction stored in first and the exponent stored in second. </dd></dl>
<p>If val is zero, both first and second are set to zero. </p>
<p>If val is not zero, and no errors occur, the function returns a value, x, in the range( -1; -0.5], [ 0.5; 1 ) in first and stores an integer value in second such that result.first*2^( result.second ) = val. </p>
<p>If the value to be stored in result.second is outside the range of int, the behavior is unspecified. </p>

</div>
</div>
<a id="a19c01122e0f442201ff460957b24c1db" name="a19c01122e0f442201ff460957b24c1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c01122e0f442201ff460957b24c1db">&#9670;&#160;</a></span>FRExp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FRExp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>exp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decomposes the given floating point value val into a normalized fraction and an integral power of two. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">exp</td><td>A reference to an integer value to store the exponent to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If val is zero, returns zero and stores zero in exp. </dd></dl>
<p>If val is not zero, and no errors occur, the function returns a value, x, in the range( -1; -0.5], [ 0.5; 1 ) and stores an integer value in exp such that x*2^( exp ) = val. </p>
<p>If the value to be stored in exp is outside the range of int, the behavior is unspecified. </p>

</div>
</div>
<a id="a10c98610c8fa54047fca2f3c9175bda0" name="a10c98610c8fa54047fca2f3c9175bda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c98610c8fa54047fca2f3c9175bda0">&#9670;&#160;</a></span>FRExp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::FRExp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>exp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decomposes the given floating point value val into a normalized fraction and an integral power of two. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">exp</td><td>A pointer to an integer value to store the exponent to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If val is zero, returns zero and stores zero in *exp. </dd></dl>
<p>If val is not zero, and no errors occur, the function returns a value, x, in the range( -1; -0.5], [ 0.5; 1 ) and stores an integer value in *exp such that x*2^( *exp ) = val. </p>
<p>If the value to be stored in *exp is outside the range of int, the behavior is unspecified. </p>

</div>
</div>
<a id="a2ff294e4dc26a76c07eee6516e24a63b" name="a2ff294e4dc26a76c07eee6516e24a63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff294e4dc26a76c07eee6516e24a63b">&#9670;&#160;</a></span>Gamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Gamma </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00981cc6ae3f1fe8ec89bb3b0bd06cdf" name="a00981cc6ae3f1fe8ec89bb3b0bd06cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00981cc6ae3f1fe8ec89bb3b0bd06cdf">&#9670;&#160;</a></span>Gaussian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::Gaussian </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>mu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>sigma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9be9f5eccd842bad03d6eb9051903a56" name="a9be9f5eccd842bad03d6eb9051903a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be9f5eccd842bad03d6eb9051903a56">&#9670;&#160;</a></span>GaussianIntegral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::GaussianIntegral </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>mu</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>sigma</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad760fa17e2c26f6efacfb3ba4d5fdc91" name="ad760fa17e2c26f6efacfb3ba4d5fdc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad760fa17e2c26f6efacfb3ba4d5fdc91">&#9670;&#160;</a></span>Greater() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Greater </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are greater than the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is greater than the corresponding element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a1c34e84328be30883c2b894854a4c035" name="a1c34e84328be30883c2b894854a4c035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c34e84328be30883c2b894854a4c035">&#9670;&#160;</a></span>Greater() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Greater </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are greater than value. </p>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is greater than value, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="ad84e64e5c7ce56f14e9bfeb7843b2a7f" name="ad84e64e5c7ce56f14e9bfeb7843b2a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84e64e5c7ce56f14e9bfeb7843b2a7f">&#9670;&#160;</a></span>Greater() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Greater </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is greater than the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>If value is greater than an element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="ad231c68da490686a55e3c23d096afd25" name="ad231c68da490686a55e3c23d096afd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad231c68da490686a55e3c23d096afd25">&#9670;&#160;</a></span>GreaterOrEqual() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::GreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are greater than, or equal to, the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is greater than, or equal to, the corresponding element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a64e2b37cadb07e785ed9cb32720c937f" name="a64e2b37cadb07e785ed9cb32720c937f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e2b37cadb07e785ed9cb32720c937f">&#9670;&#160;</a></span>GreaterOrEqual() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::GreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are greater than, or equal to, value. </p>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is greater than, or equal to, value, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a111ba8abb2736af5196dd201bdd82e1a" name="a111ba8abb2736af5196dd201bdd82e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111ba8abb2736af5196dd201bdd82e1a">&#9670;&#160;</a></span>GreaterOrEqual() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::GreaterOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is greater than, or equal to, the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>If value is greater than, or equal to, an element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="aa29cfbabaf6d069066e181e1b2a3f8e2" name="aa29cfbabaf6d069066e181e1b2a3f8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29cfbabaf6d069066e181e1b2a3f8e2">&#9670;&#160;</a></span>Hermite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U, SimdOrTupleType V, SimdOrTupleType W, ArithmeticType X&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U, V, W&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Hermite </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>firstPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>firstTangent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>secondPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const W &amp;</td>          <td class="paramname"><span class="paramname"><em>secondTangent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_h_c_c_com_8cpp.html#ab73683fe9b2b763a892a53615dfae862">X</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Hermite spline interpolation, using the specified arguments. </p>

</div>
</div>
<a id="a732e86eee7896beaa59b9ea998db4d11" name="a732e86eee7896beaa59b9ea998db4d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732e86eee7896beaa59b9ea998db4d11">&#9670;&#160;</a></span>HProd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::HProd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the horizontal product of the elements in the vector. </p>

</div>
</div>
<a id="a8c6df72fca7fa5ed2aaa74caebb48c78" name="a8c6df72fca7fa5ed2aaa74caebb48c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6df72fca7fa5ed2aaa74caebb48c78">&#9670;&#160;</a></span>HProd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::Simd Harlinn::Math::HProd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the horizontal product of the elements in the vector. </p>

</div>
</div>
<a id="ae112399490f33978ac41fb28546acf33" name="ae112399490f33978ac41fb28546acf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae112399490f33978ac41fb28546acf33">&#9670;&#160;</a></span>HSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::HSum </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the horizontal sum of the elements in the vector. </p>

</div>
</div>
<a id="a2c7a2bedd77f82781d27279c2effe863" name="a2c7a2bedd77f82781d27279c2effe863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7a2bedd77f82781d27279c2effe863">&#9670;&#160;</a></span>HSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::Simd Harlinn::Math::HSum </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the horizontal sum of the elements in the vector. </p>

</div>
</div>
<a id="af4646614499840724444a965539095d9" name="af4646614499840724444a965539095d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4646614499840724444a965539095d9">&#9670;&#160;</a></span>Hypot() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Hypot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the square root of the sum of the squares of each corresponding element in x and y, without undue overflow or underflow at intermediate stages of the computation. </p>

</div>
</div>
<a id="afef21ea126690435f04dc76bcc14431c" name="afef21ea126690435f04dc76bcc14431c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef21ea126690435f04dc76bcc14431c">&#9670;&#160;</a></span>Hypot() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Hypot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the square root of the sum of the squares of each corresponding element in x and y, without undue overflow or underflow at intermediate stages of the computation. </p>

</div>
</div>
<a id="a482e782f44215ca6caebade70e35a942" name="a482e782f44215ca6caebade70e35a942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482e782f44215ca6caebade70e35a942">&#9670;&#160;</a></span>Hypot() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Hypot </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the square root of the sum of the squares of each corresponding element in x and y, without undue overflow or underflow at intermediate stages of the computation. </p>

</div>
</div>
<a id="a57af8022b91c4680a4ea068730f4e762" name="a57af8022b91c4680a4ea068730f4e762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57af8022b91c4680a4ea068730f4e762">&#9670;&#160;</a></span>Hypot() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Hypot </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root of the sum of the squares of x and y. </dd></dl>

</div>
</div>
<a id="a16c87903d0bada5562ba3704f627975a" name="a16c87903d0bada5562ba3704f627975a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c87903d0bada5562ba3704f627975a">&#9670;&#160;</a></span>Hypot() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Hypot </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae30f914835c0e82d5f1ab346b96dacbd" name="ae30f914835c0e82d5f1ab346b96dacbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30f914835c0e82d5f1ab346b96dacbd">&#9670;&#160;</a></span>I0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::I0 </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f07c541f9b9d48a0c82e88b61bcebc7" name="a7f07c541f9b9d48a0c82e88b61bcebc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f07c541f9b9d48a0c82e88b61bcebc7">&#9670;&#160;</a></span>ILogB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Math::ILogB </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the value of the unbiased exponent from the floating-point argument x, and returns it as a signed integer value. </p>

</div>
</div>
<a id="a97f7d059971c867d05c14bc274bc1143" name="a97f7d059971c867d05c14bc274bc1143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f7d059971c867d05c14bc274bc1143">&#9670;&#160;</a></span>InBounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::InBounds </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>bounds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects if the elements of a vector are within bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The elements to test against the bounds. </td></tr>
    <tr><td class="paramname">bounds</td><td>The bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An element in the result will have all bits set if the corresponding element of v are greater or equal to the corresponding negated value from bounds, and less or equal to the corresponding value from bounds, otherwise the element will be set to 0. </dd></dl>

</div>
</div>
<a id="a3cff981831af77ad2c52cfea1d466c71" name="a3cff981831af77ad2c52cfea1d466c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cff981831af77ad2c52cfea1d466c71">&#9670;&#160;</a></span>InnerProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT , typename... T&gt; <br />
requires std::conjunction_v&lt;std::is_arithmetic&lt;T&gt;...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::InnerProduct </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>term</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T...</td>          <td class="paramname"><span class="paramname"><em>terms</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d64f9c0d4b1a1fcca98f707dbb94fcf" name="a0d64f9c0d4b1a1fcca98f707dbb94fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d64f9c0d4b1a1fcca98f707dbb94fcf">&#9670;&#160;</a></span>InRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::InRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8c667e872e2767792400a697b3729e5" name="ad8c667e872e2767792400a697b3729e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c667e872e2767792400a697b3729e5">&#9670;&#160;</a></span>InRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::InRange </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interval</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17a588045303691a8c1941c0d8343998" name="a17a588045303691a8c1941c0d8343998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a588045303691a8c1941c0d8343998">&#9670;&#160;</a></span>Intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneType P, PointSimdType PT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PT Harlinn::Math::Intersect </td>
          <td>(</td>
          <td class="paramtype">const P &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PT &amp;</td>          <td class="paramname"><span class="paramname"><em>linePoint1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PT &amp;</td>          <td class="paramname"><span class="paramname"><em>linePoint2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03c7d0cf56edc18072b8b2f0652000e9" name="a03c7d0cf56edc18072b8b2f0652000e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c7d0cf56edc18072b8b2f0652000e9">&#9670;&#160;</a></span>Intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a>, <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a> &gt; Harlinn::Math::Intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_plane.html">Plane</a>&lt; float &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>plane1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_plane.html">Plane</a>&lt; float &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>plane2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a079ea12c2c0d6108e9ae341b965000b9" name="a079ea12c2c0d6108e9ae341b965000b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ea12c2c0d6108e9ae341b965000b9">&#9670;&#160;</a></span>Inverse() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd Harlinn::Math::Inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f1c9328150d1bf8244fdd400c241ef0" name="a8f1c9328150d1bf8244fdd400c241ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1c9328150d1bf8244fdd400c241ef0">&#9670;&#160;</a></span>Inverse() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd *</td>          <td class="paramname"><span class="paramname"><em>determinant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a427ec98ac1ee40c09ee02c50b20476b0" name="a427ec98ac1ee40c09ee02c50b20476b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427ec98ac1ee40c09ee02c50b20476b0">&#9670;&#160;</a></span>Inverse() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd *</td>          <td class="paramname"><span class="paramname"><em>determinant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to invert. </td></tr>
    <tr><td class="paramname">determinant</td><td>Address of a <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;float, 4&gt;::Simd object where each element will be assigned the determinant of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the matrix inverse of <code>matrix</code>. If the provided matrix is singular with a determinant equal to 0, Inverse returns an infinite matrix. </dd></dl>

</div>
</div>
<a id="a8ddad3200d4342e357638ca53f579b0a" name="a8ddad3200d4342e357638ca53f579b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddad3200d4342e357638ca53f579b0a">&#9670;&#160;</a></span>Inverse() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd *</td>          <td class="paramname"><span class="paramname"><em>determinant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to invert. </td></tr>
    <tr><td class="paramname">determinant</td><td>Address of a <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt;float, 4&gt;::Simd object where each element will be assigned the determinant of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the matrix inverse of <code>matrix</code>. If the provided matrix is singular with a determinant equal to 0, Inverse returns an infinite matrix. </dd></dl>

</div>
</div>
<a id="a9398ca7ba986eb00da0a2cf9d51f6c65" name="a9398ca7ba986eb00da0a2cf9d51f6c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9398ca7ba986eb00da0a2cf9d51f6c65">&#9670;&#160;</a></span>Inverse() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuaternionOrQuaternionSimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Inverse </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the inverse of a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse quaternion. </dd></dl>

</div>
</div>
<a id="adeab1d037de4f8c9abc1230c03b9df97" name="adeab1d037de4f8c9abc1230c03b9df97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeab1d037de4f8c9abc1230c03b9df97">&#9670;&#160;</a></span>Inverse() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd Harlinn::Math::Inverse </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd *</td>          <td class="paramname"><span class="paramname"><em>determinant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a245cb392ca77a55109d46c081cdeb855" name="a245cb392ca77a55109d46c081cdeb855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245cb392ca77a55109d46c081cdeb855">&#9670;&#160;</a></span>Inverse() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Inverse </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd *</td>          <td class="paramname"><span class="paramname"><em>determinant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a486d0c6b90afc438145d4a28f35fc7fd" name="a486d0c6b90afc438145d4a28f35fc7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486d0c6b90afc438145d4a28f35fc7fd">&#9670;&#160;</a></span>InverseRotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, QuaternionOrQuaternionSimdType T&gt; <br />
requires ( S::Size == 3 )</div>
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::InverseRotate </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>rotationQuaternion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates a vector using the inverse of a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to rotate. </td></tr>
    <tr><td class="paramname">rotationQuaternion</td><td><a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a> describing the rotation to apply to the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotated vector. </dd></dl>

</div>
</div>
<a id="a0e5e427bddb4cf1199f2adbc65eeced4" name="a0e5e427bddb4cf1199f2adbc65eeced4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5e427bddb4cf1199f2adbc65eeced4">&#9670;&#160;</a></span>InvertBilinear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a639cabf2f826e7b0876ba10529ea9d06">Point2f</a> Harlinn::Math::InvertBilinear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a639cabf2f826e7b0876ba10529ea9d06">Point2f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="#a639cabf2f826e7b0876ba10529ea9d06">Point2f</a>, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vert</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad58ad15cfd89f14fe84fdf1d8cf5902d" name="ad58ad15cfd89f14fe84fdf1d8cf5902d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58ad15cfd89f14fe84fdf1d8cf5902d">&#9670;&#160;</a></span>IsFinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IntegerType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsFinite </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All integers have finite values. </p>
<p>Determines if the given floating point number val has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. </p>

</div>
</div>
<a id="a7192253e7c89dcb7f00e94e68636d12b" name="a7192253e7c89dcb7f00e94e68636d12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7192253e7c89dcb7f00e94e68636d12b">&#9670;&#160;</a></span>IsFinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, ArithmeticType ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsFinite </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if all the arguments are finite. </p>

</div>
</div>
<a id="a1f3ff1abf25b2c73666dfa88c6b23124" name="a1f3ff1abf25b2c73666dfa88c6b23124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3ff1abf25b2c73666dfa88c6b23124">&#9670;&#160;</a></span>IsInf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::IsInf </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines which of the elements of t are Inf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The source of the values for the test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element of t is Inf, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="aeae14fc0c5bab83be58a8081a3658ebe" name="aeae14fc0c5bab83be58a8081a3658ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae14fc0c5bab83be58a8081a3658ebe">&#9670;&#160;</a></span>IsInf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IntegerType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsInf </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integers cannot represent infinite, so this function always returns false. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>An integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false </dd></dl>
<p>Determines if the given floating point number val is positive or negative infinity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if val has an infinite value, otherwise false. </dd></dl>

</div>
</div>
<a id="a95eee7648b97c1a35561fbd02a943b4b" name="a95eee7648b97c1a35561fbd02a943b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95eee7648b97c1a35561fbd02a943b4b">&#9670;&#160;</a></span>IsInf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, ArithmeticType ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsInf </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if any of the given integral or floating point numbers is positive or negative infinity. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integral or floating point type. </td></tr>
    <tr><td class="paramname">...Args</td><td>Integral or floating point types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Integral or floating point value. </td></tr>
    <tr><td class="paramname">...args</td><td>Integral or floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if any of the given integral or floating point numbers is positive or negative infinity, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac8a8d79ae8bbdb3d6d4c1b99f06e84fa" name="ac8a8d79ae8bbdb3d6d4c1b99f06e84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a8d79ae8bbdb3d6d4c1b99f06e84fa">&#9670;&#160;</a></span>IsNaN() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::IsNaN </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines which of the elements of t are NaN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The source of the values for the test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element of t is NaN, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a9aca46f17a1f86c6d38dee21a3849f5c" name="a9aca46f17a1f86c6d38dee21a3849f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aca46f17a1f86c6d38dee21a3849f5c">&#9670;&#160;</a></span>IsNaN() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IntegerType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsNaN </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IsNaN for integer types, always returns false. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false </dd></dl>
<p>Determines if the given floating point number, val, is a not-a-number (NaN) value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if val is a not-a-number (NaN) value. </dd></dl>

</div>
</div>
<a id="a2891fba8823c2abd1d3c9d91cc596655" name="a2891fba8823c2abd1d3c9d91cc596655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2891fba8823c2abd1d3c9d91cc596655">&#9670;&#160;</a></span>IsNaN() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, ArithmeticType ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsNaN </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if any of the given integral or floating point values are a not-a-number (NaN) value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Integral or floating point type. </td></tr>
    <tr><td class="paramname">...Args</td><td>Integral or floating point types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Integral or floating point value. </td></tr>
    <tr><td class="paramname">...args</td><td>Integral or floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if any of the given integral or floating point values is a not-a-number (NaN) value, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a13993e9f81df05382d918ab9d6864cfd" name="a13993e9f81df05382d918ab9d6864cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13993e9f81df05382d918ab9d6864cfd">&#9670;&#160;</a></span>IsNormal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;IntegerType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsNormal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All integers, except 0, are &lt;q&gt;normal&lt;/q&gt;. </p>
<p>Determines if the given floating point number val is normal, i.e. is neither zero, subnormal, infinite, nor NaN. </p>

</div>
</div>
<a id="a0826cff83589dd4b86faf50fd889b6c5" name="a0826cff83589dd4b86faf50fd889b6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0826cff83589dd4b86faf50fd889b6c5">&#9670;&#160;</a></span>IsNormal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, ArithmeticType ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsNormal </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if all the arguments are normal. </p>

</div>
</div>
<a id="a5683565083500bfc43984e6866f7eb85" name="a5683565083500bfc43984e6866f7eb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5683565083500bfc43984e6866f7eb85">&#9670;&#160;</a></span>IsPowerOf4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsPowerOf4 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a237a95b355d0276165d0a5a4d858296a" name="a237a95b355d0276165d0a5a4d858296a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237a95b355d0276165d0a5a4d858296a">&#9670;&#160;</a></span>IsSameValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsSameValue </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether two floating point values holds the same value. This function returns true if both hold the same NaN value. </p>
<p>Tests two integral values for equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">second</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both arguments are binary equivalent, otherwise false. </dd></dl>

</div>
</div>
<a id="a0502341914c9f34101f1a20e366e3799" name="a0502341914c9f34101f1a20e366e3799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0502341914c9f34101f1a20e366e3799">&#9670;&#160;</a></span>IsZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsZero </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if a floating point value is zero. </p>
<p>Tests if an integral value is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the argument is zero, otherwise false. </dd></dl>

</div>
</div>
<a id="a1fc08dabceed2b0fe1d001e8e7fb6433" name="a1fc08dabceed2b0fe1d001e8e7fb6433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc08dabceed2b0fe1d001e8e7fb6433">&#9670;&#160;</a></span>J0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::J0 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Bessel function of the first kind of order 0 for x. </p>

</div>
</div>
<a id="a501ebd9e91fa5c2273c68aa56b78361d" name="a501ebd9e91fa5c2273c68aa56b78361d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501ebd9e91fa5c2273c68aa56b78361d">&#9670;&#160;</a></span>J1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::J1 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Bessel function of the first kind of order 1 for x. </p>

</div>
</div>
<a id="a8ed25e81ab58703dcec8af889c876281" name="a8ed25e81ab58703dcec8af889c876281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed25e81ab58703dcec8af889c876281">&#9670;&#160;</a></span>JN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::JN </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Bessel function of the first kind of order n for x. </p>

</div>
</div>
<a id="af6ae646ff1e802e9701420136bd99355" name="af6ae646ff1e802e9701420136bd99355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ae646ff1e802e9701420136bd99355">&#9670;&#160;</a></span>Length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; T, N &gt; Harlinn::Math::Length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_harlinn_1_1_math_1_1_segment_simd.html">SegmentSimd</a>&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segment</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad629bd0baac90c81107449235c3c2bcd" name="ad629bd0baac90c81107449235c3c2bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad629bd0baac90c81107449235c3c2bcd">&#9670;&#160;</a></span>Length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Length </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the length of v. </p>
<p>Calculates the magnitude of a quaternion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The magnitude of the quaternion. </dd></dl>

</div>
</div>
<a id="a844c2009d9ced9f68ebd1b38de558e3c" name="a844c2009d9ced9f68ebd1b38de558e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844c2009d9ced9f68ebd1b38de558e3c">&#9670;&#160;</a></span>LengthSquared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::LengthSquared </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the squared length of v. </p>
<p>Calculates the square of the magnitude of a quaternion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square of the magnitude of the quaternion. </dd></dl>

</div>
</div>
<a id="a1877c8a257d3484b8b084a14bf5e8838" name="a1877c8a257d3484b8b084a14bf5e8838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1877c8a257d3484b8b084a14bf5e8838">&#9670;&#160;</a></span>Lerp() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType NumberT1, ArithmeticType NumberT2, SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp </td>
          <td>(</td>
          <td class="paramtype">const NumberT1</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumberT2</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the linear interpolation between a and b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1). </p>

</div>
</div>
<a id="a7eb8e4dcd30188f3c41547a86592804e" name="a7eb8e4dcd30188f3c41547a86592804e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb8e4dcd30188f3c41547a86592804e">&#9670;&#160;</a></span>Lerp() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1). </p>

</div>
</div>
<a id="a7710f85bb42fbace0dfdc824a693a278" name="a7710f85bb42fbace0dfdc824a693a278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7710f85bb42fbace0dfdc824a693a278">&#9670;&#160;</a></span>Lerp() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1). </p>

</div>
</div>
<a id="a1f3a726e8e8a0f78639e3449d5d0a80b" name="a1f3a726e8e8a0f78639e3449d5d0a80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3a726e8e8a0f78639e3449d5d0a80b">&#9670;&#160;</a></span>Lerp() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType U, ArithmeticType NumberT&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1). </p>

</div>
</div>
<a id="a09eee9364af811e5092786e092894aa8" name="a09eee9364af811e5092786e092894aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09eee9364af811e5092786e092894aa8">&#9670;&#160;</a></span>Lerp() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U, ArithmeticType NumberT&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumberT</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1). </p>

</div>
</div>
<a id="a60123fd2b94a5ca1fb5fd36ec0417e8a" name="a60123fd2b94a5ca1fb5fd36ec0417e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60123fd2b94a5ca1fb5fd36ec0417e8a">&#9670;&#160;</a></span>Lerp() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_point_t.html">Harlinn::Windows::PointT</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cvref_t&lt; T &gt; Harlinn::Math::Lerp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d46344daea2b5c5760e49134f88732a" name="a8d46344daea2b5c5760e49134f88732a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d46344daea2b5c5760e49134f88732a">&#9670;&#160;</a></span>Lerp() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_size_t.html">Harlinn::Windows::SizeT</a>&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cvref_t&lt; T &gt; Harlinn::Math::Lerp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15c0aa22d6e25b08bae0a587fd16aa0f" name="a15c0aa22d6e25b08bae0a587fd16aa0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c0aa22d6e25b08bae0a587fd16aa0f">&#9670;&#160;</a></span>Lerp() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the linear interpolation between a and b, if the parameter t is inside [0, 1), the linear extrapolation otherwise, i.e. the result of a + t * ( b - a ) with accounting for floating point calculation imprecision. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An arithmetic type.</td></tr>
    <tr><td class="paramname">b</td><td>An arithmetic type.</td></tr>
    <tr><td class="paramname">t</td><td>An arithmetic type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated or extrapolated result. </dd></dl>

</div>
</div>
<a id="a09afe22d93f315729fd816d05f67653e" name="a09afe22d93f315729fd816d05f67653e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09afe22d93f315729fd816d05f67653e">&#9670;&#160;</a></span>Lerp() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; <br />
requires (<a class="el" href="namespace_harlinn_1_1_windows_1_1_internal.html#aab66c86df43fb33747675a6e5ff24656">Harlinn::Windows::Internal::IsSpecializationOf</a>&lt;std::remove_cvref_t&lt;T&gt;, <a class="el" href="class_harlinn_1_1_windows_1_1_point_t.html">Harlinn::Windows::PointT</a>&gt; &amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;U&gt; )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_cvref_t&lt; T &gt; Harlinn::Math::Lerp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="addf5114ff469a76bffa31b3a1b9d704f" name="addf5114ff469a76bffa31b3a1b9d704f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf5114ff469a76bffa31b3a1b9d704f">&#9670;&#160;</a></span>Lerp2() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp2 </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1). </p>

</div>
</div>
<a id="af40f2c54ea569bcecca90950672a4022" name="af40f2c54ea569bcecca90950672a4022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40f2c54ea569bcecca90950672a4022">&#9670;&#160;</a></span>Lerp2() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp2 </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1). </p>

</div>
</div>
<a id="adfc9adb55560176bbc914246f856b861" name="adfc9adb55560176bbc914246f856b861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc9adb55560176bbc914246f856b861">&#9670;&#160;</a></span>Lerp2() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp2 </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the linear interpolation between a and b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1). </p>

</div>
</div>
<a id="a2b8c7533947f76c5aaae8300e5c534d7" name="a2b8c7533947f76c5aaae8300e5c534d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8c7533947f76c5aaae8300e5c534d7">&#9670;&#160;</a></span>Lerp2() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp2 </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1). </p>

</div>
</div>
<a id="aae10123fa318e9709049895127f3ba28" name="aae10123fa318e9709049895127f3ba28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae10123fa318e9709049895127f3ba28">&#9670;&#160;</a></span>Lerp2() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp2 </td>
          <td>(</td>
          <td class="paramtype">const S</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the linear interpolation between the the elements of a and the elements of b, for elements of t is inside [0,1), or the linear extrapolation for elements in t outside [0,1). </p>

</div>
</div>
<a id="a38e5e7d3d8874ca6e89a9049fdbe3e86" name="a38e5e7d3d8874ca6e89a9049fdbe3e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e5e7d3d8874ca6e89a9049fdbe3e86">&#9670;&#160;</a></span>Lerp2() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Lerp2 </td>
          <td>(</td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac45b92fd9dab20f18f6620b09983d80c" name="ac45b92fd9dab20f18f6620b09983d80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45b92fd9dab20f18f6620b09983d80c">&#9670;&#160;</a></span>Less() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Less </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are less than the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is less than the corresponding element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a564420353fd0ec267254b3406df31618" name="a564420353fd0ec267254b3406df31618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564420353fd0ec267254b3406df31618">&#9670;&#160;</a></span>Less() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Less </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are less than value. </p>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is less than value, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="aebe7a458441b6c1d60682968d0eb91d6" name="aebe7a458441b6c1d60682968d0eb91d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe7a458441b6c1d60682968d0eb91d6">&#9670;&#160;</a></span>Less() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Less </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is less than the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>If value is less than an element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="aeb48c39d98d6162f742e2d9d764999f8" name="aeb48c39d98d6162f742e2d9d764999f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb48c39d98d6162f742e2d9d764999f8">&#9670;&#160;</a></span>LessOrEqual() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::LessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are less than, or equal to, the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is less than, or equal to, the corresponding element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a277c424e0405a5207a8630f18cf33974" name="a277c424e0405a5207a8630f18cf33974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277c424e0405a5207a8630f18cf33974">&#9670;&#160;</a></span>LessOrEqual() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::LessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are less than, or equal to, value. </p>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is less than, or equal to, value, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a3f7e09b58f180ada023c449fdba460e8" name="a3f7e09b58f180ada023c449fdba460e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7e09b58f180ada023c449fdba460e8">&#9670;&#160;</a></span>LessOrEqual() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::LessOrEqual </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is less than, or equal to, the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>If value is less than, or equal to, an element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="af05d7353c0a884ee1a8ed360c06d31ed" name="af05d7353c0a884ee1a8ed360c06d31ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05d7353c0a884ee1a8ed360c06d31ed">&#9670;&#160;</a></span>LGamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::LGamma </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the natural logarithm of the absolute value of the gamma function of x. </p>

</div>
</div>
<a id="a4eda795c9a79228776bc7b0a7047fd24" name="a4eda795c9a79228776bc7b0a7047fd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eda795c9a79228776bc7b0a7047fd24">&#9670;&#160;</a></span>LinePointDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointOrPointSimdType S, PointOrPointSimdType T, PointOrPointSimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;&amp;&amp; <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::LinePointDistance </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>linePoint1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>linePoint2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the minimum distance between a line and a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linePoint1</td><td>First point on the line. </td></tr>
    <tr><td class="paramname">linePoint2</td><td>Second point on the line. </td></tr>
    <tr><td class="paramname">point</td><td>The reference point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum distance between a line and a point. </dd></dl>

</div>
</div>
<a id="a3360f8684fa170bcb63d44ad9005b014" name="a3360f8684fa170bcb63d44ad9005b014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3360f8684fa170bcb63d44ad9005b014">&#9670;&#160;</a></span>Log() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Log </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the natural logarithm of each element in the argument. </p>
<p>Calculates the natural logarithm of a unit quaternion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The unit quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural logarithm of q1. </dd></dl>

</div>
</div>
<a id="a383035a626dc08e038f62ba81a0733c9" name="a383035a626dc08e038f62ba81a0733c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383035a626dc08e038f62ba81a0733c9">&#9670;&#160;</a></span>Log() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Log </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the natural, base e, logarithm of <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural, base e, logarithm of <code>x</code>. </dd></dl>

</div>
</div>
<a id="a80a5ad775d4811bff132b7e8a7e8b63e" name="a80a5ad775d4811bff132b7e8a7e8b63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a5ad775d4811bff132b7e8a7e8b63e">&#9670;&#160;</a></span>Log10() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Log10 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the base-10 logarithm of each element in the argument. </p>

</div>
</div>
<a id="acae347a158854527883628eeee6216f5" name="acae347a158854527883628eeee6216f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae347a158854527883628eeee6216f5">&#9670;&#160;</a></span>Log10() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Log10 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the common, base 10, logarithm of x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common, base 10, logarithm of x. </dd></dl>

</div>
</div>
<a id="a46fd41f558e13f68d037f037ceae96fd" name="a46fd41f558e13f68d037f037ceae96fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fd41f558e13f68d037f037ceae96fd">&#9670;&#160;</a></span>Log1P() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Log1P </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the natural logarithm of 1 + each element in the argument. </p>

</div>
</div>
<a id="a0becfa6a2399a8362895e28cde842cde" name="a0becfa6a2399a8362895e28cde842cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0becfa6a2399a8362895e28cde842cde">&#9670;&#160;</a></span>Log1P() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Log1P </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ce8e1e47b5b4a0c3dcdbbb88ffffcd2" name="a8ce8e1e47b5b4a0c3dcdbbb88ffffcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce8e1e47b5b4a0c3dcdbbb88ffffcd2">&#9670;&#160;</a></span>Log2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Log2 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the base-2 logarithm, $$log_{2}_$$, of each element in the argument. </p>

</div>
</div>
<a id="af9bfcf2df6a90c553b8382702d8f18e1" name="af9bfcf2df6a90c553b8382702d8f18e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bfcf2df6a90c553b8382702d8f18e1">&#9670;&#160;</a></span>Log2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Log2 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the binary, base-2, logarithm of x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binary, base-2, logarithm of x. </dd></dl>

</div>
</div>
<a id="af6658c049e2f62c3d470d32a214e9c66" name="af6658c049e2f62c3d470d32a214e9c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6658c049e2f62c3d470d32a214e9c66">&#9670;&#160;</a></span>Log2Int() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Math::Log2Int </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64f86debde39dc16f64a157265d77700" name="a64f86debde39dc16f64a157265d77700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f86debde39dc16f64a157265d77700">&#9670;&#160;</a></span>Log2Int() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Math::Log2Int </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d0fee20a8f86793106767abb1088385" name="a2d0fee20a8f86793106767abb1088385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0fee20a8f86793106767abb1088385">&#9670;&#160;</a></span>Log2Int() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Math::Log2Int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common.html#a77b0045551d73ca9f4fb32769fa84426">Int32</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a420ec10538a1b01f25fc46d2b02e03a3" name="a420ec10538a1b01f25fc46d2b02e03a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420ec10538a1b01f25fc46d2b02e03a3">&#9670;&#160;</a></span>Log2Int() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Math::Log2Int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common.html#a5a63a6a5f3e67cefd19fb0873208989d">Int64</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cbf8872f8a0d4d9cc93bbda69ae249c" name="a3cbf8872f8a0d4d9cc93bbda69ae249c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbf8872f8a0d4d9cc93bbda69ae249c">&#9670;&#160;</a></span>Log2Int() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Math::Log2Int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common.html#af3ce862d19ad61e7bef7ba1566ed81ef">UInt32</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7045ebdf960a71823ac55392805c93cc" name="a7045ebdf960a71823ac55392805c93cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7045ebdf960a71823ac55392805c93cc">&#9670;&#160;</a></span>Log2Int() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Math::Log2Int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common.html#aeaa56507a02c6cfabe794d1df81a442a">UInt64</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa37735b1dec272dc3c997e13e402c3e3" name="aa37735b1dec272dc3c997e13e402c3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37735b1dec272dc3c997e13e402c3e3">&#9670;&#160;</a></span>Log4Int()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires std::is_arithmetic_v&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Harlinn::Math::Log4Int </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b8da5fdeb7cdce22ff47e860552b72" name="aa3b8da5fdeb7cdce22ff47e860552b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b8da5fdeb7cdce22ff47e860552b72">&#9670;&#160;</a></span>LogB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::LogB </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the value of the unbiased radix-independent exponent from the floating-point argument x, and returns it as a floating-point value. </p>

</div>
</div>
<a id="a91cf4c3f7c5688ffaddb00d62dd2de97" name="a91cf4c3f7c5688ffaddb00d62dd2de97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cf4c3f7c5688ffaddb00d62dd2de97">&#9670;&#160;</a></span>LogI0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::LogI0 </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8aabce1f77ad6a81ff997a7d9510aa0b" name="a8aabce1f77ad6a81ff997a7d9510aa0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aabce1f77ad6a81ff997a7d9510aa0b">&#9670;&#160;</a></span>Logistic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::Logistic </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89e80a962d96d83c3d005c65decc3b93" name="a89e80a962d96d83c3d005c65decc3b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e80a962d96d83c3d005c65decc3b93">&#9670;&#160;</a></span>LogisticCDF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::LogisticCDF </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3c8a2682c3f9ca44bf2b39c1bc65365" name="ab3c8a2682c3f9ca44bf2b39c1bc65365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c8a2682c3f9ca44bf2b39c1bc65365">&#9670;&#160;</a></span>LookAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt; &amp;&amp; ( S::Size == 3 )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; typenameS::value_type, 4 &gt;::Simd Harlinn::Math::LookAt </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>cameraPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>focusPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>upDirection</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view matrix using the left-handed coordinate system for the provided camera position, focal point, and up direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraPosition</td><td>The camera position. </td></tr>
    <tr><td class="paramname">focusPosition</td><td>The focal point. </td></tr>
    <tr><td class="paramname">upDirection</td><td>The up direction of the camera, often [0 1 0] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The view matrix transforming coordinates from world space to view space. </dd></dl>

</div>
</div>
<a id="a5dbd8de9377706d9a75eca81c33b3740" name="a5dbd8de9377706d9a75eca81c33b3740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbd8de9377706d9a75eca81c33b3740">&#9670;&#160;</a></span>LookTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt; &amp;&amp; ( S::Size == 3 )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; typenameS::value_type, 4 &gt;::Simd Harlinn::Math::LookTo </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>cameraPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>cameraDirection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>upDirection</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view matrix using the left-handed coordinate system for the provided camera position, camera direction, and up direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraPosition</td><td>The camera position. </td></tr>
    <tr><td class="paramname">cameraDirection</td><td>The camera direction. </td></tr>
    <tr><td class="paramname">upDirection</td><td>The up direction of the camera, often [0 1 0] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The view matrix transforming coordinates from world space to view space. </dd></dl>

</div>
</div>
<a id="abdec897d69d6865dcb74849e4a630781" name="abdec897d69d6865dcb74849e4a630781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdec897d69d6865dcb74849e4a630781">&#9670;&#160;</a></span>Max() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a> Harlinn::Math::Max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a066c9764bb82bbb23ba88bb5215ded01" name="a066c9764bb82bbb23ba88bb5215ded01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066c9764bb82bbb23ba88bb5215ded01">&#9670;&#160;</a></span>Max() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a> Harlinn::Math::Max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1aa49e0c3b68be42b68b4232b4322b72" name="a1aa49e0c3b68be42b68b4232b4322b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa49e0c3b68be42b68b4232b4322b72">&#9670;&#160;</a></span>Max() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a> Harlinn::Math::Max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad80a0ffc11f73133b75b31634a05807c" name="ad80a0ffc11f73133b75b31634a05807c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80a0ffc11f73133b75b31634a05807c">&#9670;&#160;</a></span>Max() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a> Harlinn::Math::Max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31a077f0e4bc1fc55873d076bf9eb371" name="a31a077f0e4bc1fc55873d076bf9eb371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a077f0e4bc1fc55873d076bf9eb371">&#9670;&#160;</a></span>Max() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::Max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace5f96ca6bd61ad7d54aed47dc274c7f" name="ace5f96ca6bd61ad7d54aed47dc274c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5f96ca6bd61ad7d54aed47dc274c7f">&#9670;&#160;</a></span>Max() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a comparison between the elements held by the two arguments, and returns a <a class="el" href="class_harlinn_1_1_math_1_1_tuple_simd.html">TupleSimd</a> containing the largest elements. </p>

</div>
</div>
<a id="abf04d08d7e21956153df4683e43e1ec6" name="abf04d08d7e21956153df4683e43e1ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf04d08d7e21956153df4683e43e1ec6">&#9670;&#160;</a></span>Max() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Max </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of the given values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first floating point value. </td></tr>
    <tr><td class="paramname">second</td><td>The second floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the larger of <code>first</code> and <code>second</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first integer value. </td></tr>
    <tr><td class="paramname">second</td><td>The second integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the larger of <code>first</code> and <code>second</code>. </dd></dl>

</div>
</div>
<a id="a1bedec25a886855135109e10405e969f" name="a1bedec25a886855135109e10405e969f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bedec25a886855135109e10405e969f">&#9670;&#160;</a></span>Max() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T, FloatingPointType ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Max </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>second</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>remaining</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a584ff6c249acb5c9937b9c15f9af3094" name="a584ff6c249acb5c9937b9c15f9af3094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584ff6c249acb5c9937b9c15f9af3094">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71b567e29868c58fa11a7686d59fedd1" name="a71b567e29868c58fa11a7686d59fedd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b567e29868c58fa11a7686d59fedd1">&#9670;&#160;</a></span>MaxComponentIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Harlinn::Math::MaxComponentIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the offset of the highest value held by the argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset of the highest value held by the argument. </dd></dl>

</div>
</div>
<a id="a8ed19a24e36207be2f169e7cc9bd5a76" name="a8ed19a24e36207be2f169e7cc9bd5a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed19a24e36207be2f169e7cc9bd5a76">&#9670;&#160;</a></span>MaxComponentValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::MaxComponentValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the highest value held by the argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest value held by the argument. </dd></dl>

</div>
</div>
<a id="a80f4ae5005618854ec9e301326189950" name="a80f4ae5005618854ec9e301326189950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f4ae5005618854ec9e301326189950">&#9670;&#160;</a></span>MaxComponentValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::MaxComponentValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the highest value held by the argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest value held by the argument. </dd></dl>

</div>
</div>
<a id="a269b27b08bf6a21ba5cc074dc6687725" name="a269b27b08bf6a21ba5cc074dc6687725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269b27b08bf6a21ba5cc074dc6687725">&#9670;&#160;</a></span>Min() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a> Harlinn::Math::Min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aec69f7ea09d7cbed7338823bf4e5528a">Harlinn::Windows::Graphics::PointF</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56bbd01608f5091cd678efdd56b216b3" name="a56bbd01608f5091cd678efdd56b216b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56bbd01608f5091cd678efdd56b216b3">&#9670;&#160;</a></span>Min() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a> Harlinn::Math::Min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows_1_1_graphics.html#aaf15c4296458a4ad1b4705453a3b7181">Harlinn::Windows::Graphics::SizeF</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a7ac8e15ecd635df241596bc5500b24" name="a5a7ac8e15ecd635df241596bc5500b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7ac8e15ecd635df241596bc5500b24">&#9670;&#160;</a></span>Min() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a> Harlinn::Math::Min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows.html#ad4d54637f7ab77ac7e90b713907d781a">Harlinn::Windows::Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32c6141c2fd2f95514007f63427018d4" name="a32c6141c2fd2f95514007f63427018d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c6141c2fd2f95514007f63427018d4">&#9670;&#160;</a></span>Min() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a> Harlinn::Math::Min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_harlinn_1_1_windows.html#aadde21be79a209443deef7b032698691">Harlinn::Windows::Size</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81fe9032f5b3ca782d8676ec32e8c522" name="a81fe9032f5b3ca782d8676ec32e8c522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fe9032f5b3ca782d8676ec32e8c522">&#9670;&#160;</a></span>Min() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::Min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97cd21ee70823a7f54274949ab7c514c" name="a97cd21ee70823a7f54274949ab7c514c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cd21ee70823a7f54274949ab7c514c">&#9670;&#160;</a></span>Min() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a comparison between the elements held by the two arguments, and returns a <a class="el" href="class_harlinn_1_1_math_1_1_tuple_simd.html">TupleSimd</a> derived object containing the smallest elements. </p>

</div>
</div>
<a id="ae83de7c527b5116ccb856eaaf3d6aeeb" name="ae83de7c527b5116ccb856eaaf3d6aeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83de7c527b5116ccb856eaaf3d6aeeb">&#9670;&#160;</a></span>Min() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Min </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of the given values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first floating point value. </td></tr>
    <tr><td class="paramname">second</td><td>The second floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the smaller of <code>first</code> and <code>second</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first integer value. </td></tr>
    <tr><td class="paramname">second</td><td>The second integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the smaller of <code>first</code> and <code>second</code>. </dd></dl>

</div>
</div>
<a id="a9bf5f42de91c1412b43ab27f9ed71e35" name="a9bf5f42de91c1412b43ab27f9ed71e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf5f42de91c1412b43ab27f9ed71e35">&#9670;&#160;</a></span>Min() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T, FloatingPointType ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Min </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>second</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>remaining</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b48c2bc648a9044d8d25824a37d332b" name="a7b48c2bc648a9044d8d25824a37d332b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b48c2bc648a9044d8d25824a37d332b">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea2407366affb46f16caaf16edb37864" name="aea2407366affb46f16caaf16edb37864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2407366affb46f16caaf16edb37864">&#9670;&#160;</a></span>MinComponentIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Harlinn::Math::MinComponentIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the offset of the lowest value held by the argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset of the lowest value held by the argument. </dd></dl>

</div>
</div>
<a id="ae6010f678c8459ac1c6211e6cca8da1e" name="ae6010f678c8459ac1c6211e6cca8da1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6010f678c8459ac1c6211e6cca8da1e">&#9670;&#160;</a></span>MinComponentIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, typename ResultT  = typename T::value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Harlinn::Math::MinComponentIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the offset of the lowest value held by the argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset of the lowest value held by the argument. </dd></dl>

</div>
</div>
<a id="a8e9f5a30b8f0743f6ae2a8298a2176c8" name="a8e9f5a30b8f0743f6ae2a8298a2176c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9f5a30b8f0743f6ae2a8298a2176c8">&#9670;&#160;</a></span>MinComponentValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::MinComponentValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the lowest value held by the argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowest value held by the argument. </dd></dl>

</div>
</div>
<a id="a01b71ee867b56992571eafaa17d3c3c6" name="a01b71ee867b56992571eafaa17d3c3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b71ee867b56992571eafaa17d3c3c6">&#9670;&#160;</a></span>MinComponentValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::MinComponentValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the lowest value held by the argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowest value held by the argument. </dd></dl>

</div>
</div>
<a id="a07509bb6ccb3ed10316ac97c6694f4f5" name="a07509bb6ccb3ed10316ac97c6694f4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07509bb6ccb3ed10316ac97c6694f4f5">&#9670;&#160;</a></span>Mod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Mod </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a771a7558deecb257a45b252229b48510" name="a771a7558deecb257a45b252229b48510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771a7558deecb257a45b252229b48510">&#9670;&#160;</a></span>ModAngles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ModAngles </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>angles</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the angle modulo 2PI. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A TupleN <a class="el" href="concept_harlinn_1_1_math_1_1_simd_type.html">SimdType</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angles</td><td>The angles in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="concept_harlinn_1_1_math_1_1_simd_type.html">SimdType</a> holding the angles modulo 2PI. </dd></dl>

</div>
</div>
<a id="ab396b56264fa6d74e80f149358c321c6" name="ab396b56264fa6d74e80f149358c321c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab396b56264fa6d74e80f149358c321c6">&#9670;&#160;</a></span>ModF() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; T, T &gt; Harlinn::Math::ModF </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decomposes floating-point value val into its integral and fractional parts, each with the same type and sign as val. </p>
<p>This implementation can also be constexpr evaluated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueT</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair&lt;T,T&gt; where first holds the integral part of the result and second holds the fractional part. </dd></dl>

</div>
</div>
<a id="ac7ce2b213fa59b2fc14b7d7a6142d421" name="ac7ce2b213fa59b2fc14b7d7a6142d421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ce2b213fa59b2fc14b7d7a6142d421">&#9670;&#160;</a></span>ModF() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ModF </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>integerPart</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decomposes floating-point value val into its integral and fractional parts, each with the same type and sign as val. </p>
<p>This implementation can also be constexpr evaluated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueT</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">integerPart</td><td>A reference to a variable of the ValueT floating point type that receives the integral part of val. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fractional part of val. </dd></dl>

</div>
</div>
<a id="a61ac718ba3e3255c9123ec96d6ad4b30" name="a61ac718ba3e3255c9123ec96d6ad4b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ac718ba3e3255c9123ec96d6ad4b30">&#9670;&#160;</a></span>ModF() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ModF </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>integerPart</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decomposes floating-point value val into its integral and fractional parts, each with the same type and sign as val. </p>
<p>This implementation can also be constexpr evaluated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueT</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">integerPart</td><td>A pointer to a variable of the ValueT floating point type that receives the integral part of val. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fractional part of val. </dd></dl>

</div>
</div>
<a id="a2831472ebd0b5253938bd4af13be125f" name="a2831472ebd0b5253938bd4af13be125f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2831472ebd0b5253938bd4af13be125f">&#9670;&#160;</a></span>MulAdjustDown() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::MulAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5012fda809dfc71f79505811e149427b" name="a5012fda809dfc71f79505811e149427b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5012fda809dfc71f79505811e149427b">&#9670;&#160;</a></span>MulAdjustDown() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::MulAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a038223a68090555ae7602da11b1a9ac3" name="a038223a68090555ae7602da11b1a9ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038223a68090555ae7602da11b1a9ac3">&#9670;&#160;</a></span>MulAdjustDown() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S::Simd Harlinn::Math::MulAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae73d72979429033d3cce706c4cd8bcaa" name="ae73d72979429033d3cce706c4cd8bcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73d72979429033d3cce706c4cd8bcaa">&#9670;&#160;</a></span>MulAdjustDown() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::MulAdjustDown </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01bf712f5b1a53e2e7211cb8e6e097ba" name="a01bf712f5b1a53e2e7211cb8e6e097ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bf712f5b1a53e2e7211cb8e6e097ba">&#9670;&#160;</a></span>MulAdjustUp() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::MulAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81563787853df304ae0c1048141b9fd6" name="a81563787853df304ae0c1048141b9fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81563787853df304ae0c1048141b9fd6">&#9670;&#160;</a></span>MulAdjustUp() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::MulAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1758b6a82a702c0ff58e4ecfab9f5c2b" name="a1758b6a82a702c0ff58e4ecfab9f5c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1758b6a82a702c0ff58e4ecfab9f5c2b">&#9670;&#160;</a></span>MulAdjustUp() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S::Simd Harlinn::Math::MulAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aafc183fa5b72c01ba711f24aeacc7f0c" name="aafc183fa5b72c01ba711f24aeacc7f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc183fa5b72c01ba711f24aeacc7f0c">&#9670;&#160;</a></span>MulAdjustUp() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::MulAdjustUp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33d90e559811788807d0b98f0f34b452" name="a33d90e559811788807d0b98f0f34b452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d90e559811788807d0b98f0f34b452">&#9670;&#160;</a></span>MulPow2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::MulPow2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2e7fe8d6be7d35f5d4cbbb2f0cddd65" name="ab2e7fe8d6be7d35f5d4cbbb2f0cddd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e7fe8d6be7d35f5d4cbbb2f0cddd65">&#9670;&#160;</a></span>MulPow2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::MulPow2 </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7ba5d43d7b7958445997a610993dfbf" name="ae7ba5d43d7b7958445997a610993dfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ba5d43d7b7958445997a610993dfbf">&#9670;&#160;</a></span>Multiply() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimpleSpanLike T&gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad60f420a7f44c2b0e9ce86950287dbad">IsArithmetic</a>&lt;typename T::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::value_type Harlinn::Math::Multiply </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55c2203568f640ece6355f4c7c410e5f" name="a55c2203568f640ece6355f4c7c410e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c2203568f640ece6355f4c7c410e5f">&#9670;&#160;</a></span>Multiply() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd Harlinn::Math::Multiply </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a68c1e5b9df24737ba75503b9c28f99e4" name="a68c1e5b9df24737ba75503b9c28f99e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c1e5b9df24737ba75503b9c28f99e4">&#9670;&#160;</a></span>Multiply() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Multiply </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd38be8b38c54a3d95d6aec83210fe72" name="abd38be8b38c54a3d95d6aec83210fe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd38be8b38c54a3d95d6aec83210fe72">&#9670;&#160;</a></span>Multiply() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Multiply </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92a767eb20f2828f140fa235bd4f1c3a" name="a92a767eb20f2828f140fa235bd4f1c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a767eb20f2828f140fa235bd4f1c3a">&#9670;&#160;</a></span>NewtonBisection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename FloatT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::NewtonBisection </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>xEps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">static_cast&lt;&#160;FloatT&#160;&gt;(&#160;1e-6&#160;)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>fEps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">static_cast&lt;&#160;FloatT&#160;&gt;(&#160;1e-6&#160;)</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b8d31268db3285ea02c6ae7bd376410" name="a1b8d31268db3285ea02c6ae7bd376410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8d31268db3285ea02c6ae7bd376410">&#9670;&#160;</a></span>NextAfter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Harlinn::Math::NextAfter </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next representable value of x in the direction of y. If x equals to y, y is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A double precision floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>A double precision floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next representable value of x in the direction of y. is returned. If x equals y, then y is returned </dd></dl>

</div>
</div>
<a id="a4c6ce9b75eaa5934febe7f16e55a117e" name="a4c6ce9b75eaa5934febe7f16e55a117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6ce9b75eaa5934febe7f16e55a117e">&#9670;&#160;</a></span>NextAfter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Harlinn::Math::NextAfter </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next representable value of x in the direction of y. If x equals to y, y is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A single precision floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>A single precision floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next representable value of x in the direction of y. is returned. If x equals y, then y is returned </dd></dl>

</div>
</div>
<a id="acf30bdb0da01190ccc7ca313a4e9cf89" name="acf30bdb0da01190ccc7ca313a4e9cf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf30bdb0da01190ccc7ca313a4e9cf89">&#9670;&#160;</a></span>NextDown() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::NextDown </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a01ac49db5a05c270cde3e4d6ec52ef7d" name="a01ac49db5a05c270cde3e4d6ec52ef7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ac49db5a05c270cde3e4d6ec52ef7d">&#9670;&#160;</a></span>NextDown() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::NextDown </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the largest floating point number y of the same type as x such that y &lt; x. If no such y exists, e.g. if x is -Inf or NaN, then return x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest floating point number y of the same type as x such that y &lt; x. </dd></dl>

</div>
</div>
<a id="ae874ad9152102733a556467751941bf5" name="ae874ad9152102733a556467751941bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae874ad9152102733a556467751941bf5">&#9670;&#160;</a></span>NextFloatDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::NextFloatDown </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a939ca8cd91bba4d403003680873c25eb" name="a939ca8cd91bba4d403003680873c25eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939ca8cd91bba4d403003680873c25eb">&#9670;&#160;</a></span>NextFloatUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::NextFloatUp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16f134b133253b52c7e8b904af5237c1" name="a16f134b133253b52c7e8b904af5237c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f134b133253b52c7e8b904af5237c1">&#9670;&#160;</a></span>NextUp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::NextUp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9d55f4aa51cc5dd0b27597015b85732" name="ac9d55f4aa51cc5dd0b27597015b85732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d55f4aa51cc5dd0b27597015b85732">&#9670;&#160;</a></span>NextUp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::NextUp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the smallest floating point number y of the same type as x such that x &lt; y. If no such y exists, e.g. if x is Inf or NaN, then return x. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest floating point number y of the same type as x such that x &lt; y. </dd></dl>

</div>
</div>
<a id="a9e39bf90eb8a112d92e3e5f3aebf4d5e" name="a9e39bf90eb8a112d92e3e5f3aebf4d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e39bf90eb8a112d92e3e5f3aebf4d5e">&#9670;&#160;</a></span>Normalize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneSimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Normalize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dc72b4e27e5b2be1f9a01ad12373a59" name="a7dc72b4e27e5b2be1f9a01ad12373a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc72b4e27e5b2be1f9a01ad12373a59">&#9670;&#160;</a></span>Normalize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::Simd Harlinn::Math::Normalize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06bd724e99db6ccfcb40062a81912b07" name="a06bd724e99db6ccfcb40062a81912b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bd724e99db6ccfcb40062a81912b07">&#9670;&#160;</a></span>Normalize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Normalize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes v. </p>
<p>Normalizes a quaternion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized quaternion. </dd></dl>

</div>
</div>
<a id="acbb919ec73ee5827a6f491390c85c5f1" name="acbb919ec73ee5827a6f491390c85c5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb919ec73ee5827a6f491390c85c5f1">&#9670;&#160;</a></span>NotEqual() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::NotEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are not equal to the corresponding elements of v2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source of values for the comparison. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source of values for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is not equal to the corresponding element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="aefacbda0085e4ea966b45f03adebe957" name="aefacbda0085e4ea966b45f03adebe957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefacbda0085e4ea966b45f03adebe957">&#9670;&#160;</a></span>NotEqual() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::NotEqual </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of v1 are not equal to value. </p>
<dl class="section return"><dt>Returns</dt><dd>If an element of v1 is not equal to value, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a6853be37c269e5dee60e9d6ea322c93a" name="a6853be37c269e5dee60e9d6ea322c93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6853be37c269e5dee60e9d6ea322c93a">&#9670;&#160;</a></span>NotEqual() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::NotEqual </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether value is not equal to the elements of v2. </p>
<dl class="section return"><dt>Returns</dt><dd>If value is not equal to an element of v2, the corresponding element in the result will be set to 0xFFFFFFFF, otherwise the corresponding element in the result will be set to 0. </dd></dl>

</div>
</div>
<a id="a5a49b78aeae4d390313225ae45a1d7b2" name="a5a49b78aeae4d390313225ae45a1d7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a49b78aeae4d390313225ae45a1d7b2">&#9670;&#160;</a></span>operator*() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a693f28aa5d9d036abf1009bc4676c05c" name="a693f28aa5d9d036abf1009bc4676c05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693f28aa5d9d036abf1009bc4676c05c">&#9670;&#160;</a></span>operator*() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d636e6dd4e1f567716d110933253392" name="a0d636e6dd4e1f567716d110933253392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d636e6dd4e1f567716d110933253392">&#9670;&#160;</a></span>operator*() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae053ddb366ca16ded34b11d8c9ffc68c" name="ae053ddb366ca16ded34b11d8c9ffc68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae053ddb366ca16ded34b11d8c9ffc68c">&#9670;&#160;</a></span>operator*() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b4885d377d4fc579d579d6e1736ac1d" name="a1b4885d377d4fc579d579d6e1736ac1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4885d377d4fc579d579d6e1736ac1d">&#9670;&#160;</a></span>operator*() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe4813d8bf729860f3143562f695770d" name="afe4813d8bf729860f3143562f695770d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4813d8bf729860f3143562f695770d">&#9670;&#160;</a></span>operator*() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22c27345e36bab562bb6400257e6bf9f" name="a22c27345e36bab562bb6400257e6bf9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c27345e36bab562bb6400257e6bf9f">&#9670;&#160;</a></span>operator*() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SquareMatrixSimdType T1, ArithmeticType T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81703e59f6620bdff2dda6e9d49ad673" name="a81703e59f6620bdff2dda6e9d49ad673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81703e59f6620bdff2dda6e9d49ad673">&#9670;&#160;</a></span>operator*() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SquareMatrixSimdType T1, SquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afea6cd95aab758c786a09b0cbdb80469" name="afea6cd95aab758c786a09b0cbdb80469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea6cd95aab758c786a09b0cbdb80469">&#9670;&#160;</a></span>operator*() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SquareMatrixOrSquareMatrixSimdType T1, SquareMatrixOrSquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a7fa2d00d342443c20580e84a3b0801af">Internal::HasSquareMatrixType</a>&lt;T1, T2&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97582e6b0faba54403efe1a447814e15" name="a97582e6b0faba54403efe1a447814e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97582e6b0faba54403efe1a447814e15">&#9670;&#160;</a></span>operator*() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T1, SquareMatrixSimdType T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad5fc3ae8a4ad401ec839e8b0edc4fa7" name="aad5fc3ae8a4ad401ec839e8b0edc4fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5fc3ae8a4ad401ec839e8b0edc4fa7">&#9670;&#160;</a></span>operator*() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::operator* </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d63fa830edbf36f11d655adca722e8d" name="a3d63fa830edbf36f11d655adca722e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d63fa830edbf36f11d655adca722e8d">&#9670;&#160;</a></span>operator+() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a726582658d819e2fe9058a29585a1d01" name="a726582658d819e2fe9058a29585a1d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726582658d819e2fe9058a29585a1d01">&#9670;&#160;</a></span>operator+() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61df58af6d114274fa4e6f58e8d32dee" name="a61df58af6d114274fa4e6f58e8d32dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61df58af6d114274fa4e6f58e8d32dee">&#9670;&#160;</a></span>operator+() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2f8064476de8b0b807097abeee2c069" name="ab2f8064476de8b0b807097abeee2c069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f8064476de8b0b807097abeee2c069">&#9670;&#160;</a></span>operator+() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fdc7f1c5e4d3611321bcbc9413e6660" name="a8fdc7f1c5e4d3611321bcbc9413e6660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fdc7f1c5e4d3611321bcbc9413e6660">&#9670;&#160;</a></span>operator+() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8a0e2d9c465eaed946fa1ba63188357" name="ae8a0e2d9c465eaed946fa1ba63188357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a0e2d9c465eaed946fa1ba63188357">&#9670;&#160;</a></span>operator+() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a48babd24dcb46b99a6ced9df03584318" name="a48babd24dcb46b99a6ced9df03584318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48babd24dcb46b99a6ced9df03584318">&#9670;&#160;</a></span>operator+() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SquareMatrixSimdType T1, SquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1e0eba6c3d8532ebfb469ed5b261949" name="aa1e0eba6c3d8532ebfb469ed5b261949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e0eba6c3d8532ebfb469ed5b261949">&#9670;&#160;</a></span>operator+() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SquareMatrixOrSquareMatrixSimdType T1, SquareMatrixOrSquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a7fa2d00d342443c20580e84a3b0801af">Internal::HasSquareMatrixType</a>&lt;T1, T2&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a409278e466d1ef6f3d50a79b843f8064" name="a409278e466d1ef6f3d50a79b843f8064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409278e466d1ef6f3d50a79b843f8064">&#9670;&#160;</a></span>operator+() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::operator+ </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d3f1550c8d3db01137c5174708107db" name="a7d3f1550c8d3db01137c5174708107db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3f1550c8d3db01137c5174708107db">&#9670;&#160;</a></span>operator-() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0934259447700358bac589f28321b16" name="af0934259447700358bac589f28321b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0934259447700358bac589f28321b16">&#9670;&#160;</a></span>operator-() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f77eb3a070c947954a5fa9c7244f104" name="a4f77eb3a070c947954a5fa9c7244f104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f77eb3a070c947954a5fa9c7244f104">&#9670;&#160;</a></span>operator-() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e5c4266a6a4b1b74522d2eb5b28327c" name="a4e5c4266a6a4b1b74522d2eb5b28327c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5c4266a6a4b1b74522d2eb5b28327c">&#9670;&#160;</a></span>operator-() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58296b0814d43e5623976d0be580bf22" name="a58296b0814d43e5623976d0be580bf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58296b0814d43e5623976d0be580bf22">&#9670;&#160;</a></span>operator-() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7ac4e94c4b95ab8f35d7d581403624d" name="ab7ac4e94c4b95ab8f35d7d581403624d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ac4e94c4b95ab8f35d7d581403624d">&#9670;&#160;</a></span>operator-() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator- </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac180780e4dbe64adc7088be7c8e4064c" name="ac180780e4dbe64adc7088be7c8e4064c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac180780e4dbe64adc7088be7c8e4064c">&#9670;&#160;</a></span>operator-() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SquareMatrixSimdType T1, SquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator- </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6527d7bd8ca484e1803e0666742e6bf7" name="a6527d7bd8ca484e1803e0666742e6bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6527d7bd8ca484e1803e0666742e6bf7">&#9670;&#160;</a></span>operator-() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SquareMatrixOrSquareMatrixSimdType T1, SquareMatrixOrSquareMatrixSimdType T2&gt; <br />
requires <a class="el" href="#a9ee661002deccc8f6242fe3fca873f99">IsCompatibleMatrix</a>&lt;T1, T2&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a7fa2d00d342443c20580e84a3b0801af">Internal::HasSquareMatrixType</a>&lt;T1, T2&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator- </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21c836d3a9f25f6a173c5b889b020539" name="a21c836d3a9f25f6a173c5b889b020539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c836d3a9f25f6a173c5b889b020539">&#9670;&#160;</a></span>operator-() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::operator- </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa16a4fb74752628dce94403bfba49c45" name="aa16a4fb74752628dce94403bfba49c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16a4fb74752628dce94403bfba49c45">&#9670;&#160;</a></span>operator/() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5c7218a4b3feea511862264078294f9" name="ab5c7218a4b3feea511862264078294f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c7218a4b3feea511862264078294f9">&#9670;&#160;</a></span>operator/() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d36583ca6c26c073b51f79c97df27cd" name="a1d36583ca6c26c073b51f79c97df27cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d36583ca6c26c073b51f79c97df27cd">&#9670;&#160;</a></span>operator/() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a3794418110c118e237017c29bcd385b3">Internal::HasTupleType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab53260d61952353ca33ae8d09f7be8e2" name="ab53260d61952353ca33ae8d09f7be8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53260d61952353ca33ae8d09f7be8e2">&#9670;&#160;</a></span>operator/() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a774ebaa0c8da50338c8fb89c745b63e1" name="a774ebaa0c8da50338c8fb89c745b63e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774ebaa0c8da50338c8fb89c745b63e1">&#9670;&#160;</a></span>operator/() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abfd5c844d002cef4d06056aa2eac4e96" name="abfd5c844d002cef4d06056aa2eac4e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd5c844d002cef4d06056aa2eac4e96">&#9670;&#160;</a></span>operator/() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SquareMatrixSimdType T1, ArithmeticType T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78e5e0f74f67e0adce00d8354d407ce6" name="a78e5e0f74f67e0adce00d8354d407ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e5e0f74f67e0adce00d8354d407ce6">&#9670;&#160;</a></span>operator/() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::operator/ </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3caf8691a3ed0400c953a09da1bb9662" name="a3caf8691a3ed0400c953a09da1bb9662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caf8691a3ed0400c953a09da1bb9662">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a143be99ef80f59c7e7df93ce159ed93d" name="a143be99ef80f59c7e7df93ce159ed93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143be99ef80f59c7e7df93ce159ed93d">&#9670;&#160;</a></span>Orthogonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Orthogonal </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a vector perpendicular to the argument vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The argument vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector orthogonal to <code>v</code>. </dd></dl>

</div>
</div>
<a id="a84e2868527464f65e7e09ce4743a8a42" name="a84e2868527464f65e7e09ce4743a8a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e2868527464f65e7e09ce4743a8a42">&#9670;&#160;</a></span>Permute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int shuffleMask, SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Permute </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab50a969107d9e9d2fcefa2d004b1f883" name="ab50a969107d9e9d2fcefa2d004b1f883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50a969107d9e9d2fcefa2d004b1f883">&#9670;&#160;</a></span>PerspectiveFovProjection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; T, 4 &gt;::Simd Harlinn::Math::PerspectiveFovProjection </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>fovAngleY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>aspectRatio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>nearZ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>farZ</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a left-handed perspective projection matrix based on a field of view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fovAngleY</td><td>The top-down field-of-view angle in radians. </td></tr>
    <tr><td class="paramname">aspectRatio</td><td>The aspect ratio of the view-space X/Y. </td></tr>
    <tr><td class="paramname">nearZ</td><td>The distance to the nearest clipping plane. Cannot be equal to <code>farZ</code> and must be greater than zero. </td></tr>
    <tr><td class="paramname">farZ</td><td>The distance to the far clipping plane. Cannot be equal to <code>nearZ</code> and must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The perspective projection matrix. </dd></dl>

</div>
</div>
<a id="a45359349a6edc0cd6ef5d06e67768da9" name="a45359349a6edc0cd6ef5d06e67768da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45359349a6edc0cd6ef5d06e67768da9">&#9670;&#160;</a></span>PerspectiveProjection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; T, 4 &gt;::Simd Harlinn::Math::PerspectiveProjection </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>viewWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>viewHeight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>nearZ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>farZ</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a left-handed perspective projection matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewWidth</td><td>The width of the frustum at the nearest clipping plane. </td></tr>
    <tr><td class="paramname">viewHeight</td><td>The height of the frustum at the nearest clipping plane. </td></tr>
    <tr><td class="paramname">nearZ</td><td>The distance to the nearest clipping plane. Cannot be equal to <code>farZ</code> and must be greater than zero. </td></tr>
    <tr><td class="paramname">farZ</td><td>The distance to the far clipping plane. Cannot be equal to <code>nearZ</code> and must be greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The perspective projection matrix. </dd></dl>

</div>
</div>
<a id="a9108e5e3a74180c9c1c0f2e73aabcc84" name="a9108e5e3a74180c9c1c0f2e73aabcc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9108e5e3a74180c9c1c0f2e73aabcc84">&#9670;&#160;</a></span>Pow() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the elements in base raised to the corresponding element in exponent. </p>

</div>
</div>
<a id="a37f5edb148bde50ba186189d742735ba" name="a37f5edb148bde50ba186189d742735ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f5edb148bde50ba186189d742735ba">&#9670;&#160;</a></span>Pow() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ArithmeticType T, SimdOrTupleType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of base raised to the corresponding elements in exponent. </p>

</div>
</div>
<a id="afe1b60f9e68148505f1efbabd53d485d" name="afe1b60f9e68148505f1efbabd53d485d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1b60f9e68148505f1efbabd53d485d">&#9670;&#160;</a></span>Pow() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, ArithmeticType U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the elements in base raised to the value of exponent. </p>

</div>
</div>
<a id="ae43fa5edb4f1f8360183f1047240d338" name="ae43fa5edb4f1f8360183f1047240d338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43fa5edb4f1f8360183f1047240d338">&#9670;&#160;</a></span>Pow() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Pow </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of x raised to the power y. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x raised to the power y. </dd></dl>

</div>
</div>
<a id="a180c8349b261c441cc6daa689307d41e" name="a180c8349b261c441cc6daa689307d41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180c8349b261c441cc6daa689307d41e">&#9670;&#160;</a></span>Project()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, typename FloatT  = S::value_type, typename MatrixT  = typename SquareMatrix&lt;FloatT, 4&gt;::Simd&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::Project </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>viewportX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>viewportY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>viewportWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>viewportHeight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>viewportMinZ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>viewportMaxZ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixT &amp;</td>          <td class="paramname"><span class="paramname"><em>projection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixT &amp;</td>          <td class="paramname"><span class="paramname"><em>viewTransform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixT &amp;</td>          <td class="paramname"><span class="paramname"><em>WorldTransform</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects a 3D coordinate from object space into screen space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The 3D coordinate. </td></tr>
    <tr><td class="paramname">viewportX</td><td>The x-coordinate of the upper-left corner of the viewport. Assign 0 to this parameter, unless you only need to render to a subset of the surface, </td></tr>
    <tr><td class="paramname">viewportY</td><td>The y-coordinate of the upper-left corner of the viewport. Assign 0 to this parameter, unless you only need to render to a subset of the surface. </td></tr>
    <tr><td class="paramname">viewportWidth</td><td>The width of the clip volume, Assign the width of the render target surface to this parameter, unless you only need to render to a subset of the surface. </td></tr>
    <tr><td class="paramname">viewportHeight</td><td>The height of the clip volume, Assign the height of the render target surface to this parameter, unless you only need to render to a subset of the surface. </td></tr>
    <tr><td class="paramname">viewportMinZ</td><td>The minimum depth of the clip volume, usually 0.0f. </td></tr>
    <tr><td class="paramname">viewportMaxZ</td><td>The maximum depth of the clip volume, usually 1.0f. </td></tr>
    <tr><td class="paramname">projection</td><td>The projection matrix. </td></tr>
    <tr><td class="paramname">viewTransform</td><td>The view transform matrix. </td></tr>
    <tr><td class="paramname">WorldTransform</td><td>The world transform matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the coordinate projected into screen space. </dd></dl>

</div>
</div>
<a id="a1d8dc8ddc9e5ec45310f4757a2c792ff" name="a1d8dc8ddc9e5ec45310f4757a2c792ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8dc8ddc9e5ec45310f4757a2c792ff">&#9670;&#160;</a></span>Quadratic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::Quadratic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; *</td>          <td class="paramname"><span class="paramname"><em>t0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; *</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae89bfa35a14bde7c41205d954259fd7e" name="ae89bfa35a14bde7c41205d954259fd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89bfa35a14bde7c41205d954259fd7e">&#9670;&#160;</a></span>Quadratic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT , typename... T&gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::Quadratic </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT *</td>          <td class="paramname"><span class="paramname"><em>t0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT *</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fbd57c7f8e57182db9e1032ea95b378" name="a9fbd57c7f8e57182db9e1032ea95b378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbd57c7f8e57182db9e1032ea95b378">&#9670;&#160;</a></span>Rad2Deg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Rad2Deg </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>angleInRadians</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an angle in radians into the corresponding angle in degrees. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angleInRadians</td><td>The angle in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle in degrees. </dd></dl>

</div>
</div>
<a id="a18052b90b8098ed23fce3a0b97483b9d" name="a18052b90b8098ed23fce3a0b97483b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18052b90b8098ed23fce3a0b97483b9d">&#9670;&#160;</a></span>Radians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Radians </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>deg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cfbefd30b64589dce07bb4e5beab3ed" name="a3cfbefd30b64589dce07bb4e5beab3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfbefd30b64589dce07bb4e5beab3ed">&#9670;&#160;</a></span>Reciprocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Reciprocal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the reciprocal of each element in the argument. </p>

</div>
</div>
<a id="a9a0cd83fd88311738365f0bd98ec0542" name="a9a0cd83fd88311738365f0bd98ec0542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0cd83fd88311738365f0bd98ec0542">&#9670;&#160;</a></span>ReciprocalLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ReciprocalLength </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the reciprocal length of v. </p>
<p>Calculates the reciprocal of the magnitude of a quaternion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reciprocal of the magnitude of the quaternion. </dd></dl>

</div>
</div>
<a id="ac3f5da606d0092af0b5e584235bf5a31" name="ac3f5da606d0092af0b5e584235bf5a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f5da606d0092af0b5e584235bf5a31">&#9670;&#160;</a></span>ReciprocalSqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ReciprocalSqrt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the reciprocal square root of each element in the argument. </p>

</div>
</div>
<a id="a828c285223f0bbac53ee3c0e44ccbcc3" name="a828c285223f0bbac53ee3c0e44ccbcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828c285223f0bbac53ee3c0e44ccbcc3">&#9670;&#160;</a></span>ReciprocalSqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::ReciprocalSqrt </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58046c6eca712fe150048fbecd5be33a" name="a58046c6eca712fe150048fbecd5be33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58046c6eca712fe150048fbecd5be33a">&#9670;&#160;</a></span>Reflect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Reflect </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>incident</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>normal</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reflects an incident vector across a normal vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incident</td><td>Incident vector to reflect. </td></tr>
    <tr><td class="paramname">normal</td><td><a class="el" href="class_harlinn_1_1_math_1_1_normal.html">Normal</a> vector to reflect the incident vector across. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reflected incident angle. </dd></dl>

</div>
</div>
<a id="a83f796b6818233e750bca755da590405" name="a83f796b6818233e750bca755da590405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f796b6818233e750bca755da590405">&#9670;&#160;</a></span>Refract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Refract </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>incident</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>normal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>refractionIndex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refracts an incident vector across a normal vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incident</td><td>The incident vector to refract. </td></tr>
    <tr><td class="paramname">normal</td><td>The normal vector to refract the incident vector through. </td></tr>
    <tr><td class="paramname">refractionIndex</td><td>A vector whose elements are equal to the index of refraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the refracted incident vector. If the refraction index and the angle between the incident vector and the normal are such that the result is a total internal reflection, the function will return a vector with all elements set to zero. </dd></dl>

</div>
</div>
<a id="a409a32cb5df447b5bc7bcc9747f2e798" name="a409a32cb5df447b5bc7bcc9747f2e798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409a32cb5df447b5bc7bcc9747f2e798">&#9670;&#160;</a></span>Refract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, ArithmeticType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Refract </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>incident</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>normal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U</td>          <td class="paramname"><span class="paramname"><em>refractionIndex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refracts an incident vector across a normal vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incident</td><td>The incident vector to refract. </td></tr>
    <tr><td class="paramname">normal</td><td>The normal vector to refract the incident vector through. </td></tr>
    <tr><td class="paramname">refractionIndex</td><td>The index of refraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the refracted incident vector. If the refraction index and the angle between the incident vector and the normal are such that the result is a total internal reflection, the function will return a vector with all elements set to zero. </dd></dl>

</div>
</div>
<a id="a4d433eed4b8c44d932a9ba4fb70158c7" name="a4d433eed4b8c44d932a9ba4fb70158c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d433eed4b8c44d932a9ba4fb70158c7">&#9670;&#160;</a></span>Remainder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Remainder </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the IEEE remainder of the floating point division operation x / y. </p>

</div>
</div>
<a id="a940c3e3c41ec9b4f2dcb7c58d7fee037" name="a940c3e3c41ec9b4f2dcb7c58d7fee037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940c3e3c41ec9b4f2dcb7c58d7fee037">&#9670;&#160;</a></span>RemQuo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::RemQuo </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>quo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the floating-point remainder of the division operation x / y like Remainder. Additionally, the sign and at least the three of the last bits of x / y will be stored in quo, sufficient to determine the octant of the result within a period. </p>

</div>
</div>
<a id="abc0bb61b81c4d1b1a92ae52f0e3d23e3" name="abc0bb61b81c4d1b1a92ae52f0e3d23e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0bb61b81c4d1b1a92ae52f0e3d23e3">&#9670;&#160;</a></span>Rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, QuaternionOrQuaternionSimdType T&gt; <br />
requires ( S::Size == 3 )</div>
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Rotate </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>rotationQuaternion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates a vector using a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to rotate. </td></tr>
    <tr><td class="paramname">rotationQuaternion</td><td><a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a> describing the rotation to apply to the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotated vector. </dd></dl>

</div>
</div>
<a id="ac3028f2700ba6f376096a060dc0cdc00" name="ac3028f2700ba6f376096a060dc0cdc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3028f2700ba6f376096a060dc0cdc00">&#9670;&#160;</a></span>Rotation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Rotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a>&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rotation matrix from a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion that defines the rotation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a id="afaf9abd7b8eed5202cbacba56d49627d" name="afaf9abd7b8eed5202cbacba56d49627d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf9abd7b8eed5202cbacba56d49627d">&#9670;&#160;</a></span>Rotation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Rotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a>&lt; float &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rotation matrix from a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion that defines the rotation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a id="ad5cf1666ad5fb3e80caadaf396f12e85" name="ad5cf1666ad5fb3e80caadaf396f12e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cf1666ad5fb3e80caadaf396f12e85">&#9670;&#160;</a></span>Rotation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S&gt; <br />
requires ( S::Size &gt; 2 )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Rotation </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a transformation matrix that rotates about the y-axis, then the x-axis, and finally the z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The angles of rotation around the x-axis, y-axis and z-axis, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

</div>
</div>
<a id="ab6ba4b5556e837c9fb76989979bbbad8" name="ab6ba4b5556e837c9fb76989979bbbad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ba4b5556e837c9fb76989979bbbad8">&#9670;&#160;</a></span>Rotation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Rotation </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>xAxisRotation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>yAxisRotation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>zAxisRotation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a transformation matrix that rotates about the y-axis, then the x-axis, and finally the z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xAxisRotation</td><td>The angle of rotation around the x-axis, in radians. </td></tr>
    <tr><td class="paramname">yAxisRotation</td><td>The angle of rotation around the y-axis, in radians. </td></tr>
    <tr><td class="paramname">zAxisRotation</td><td>The angle of rotation around the z-axis, in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

</div>
</div>
<a id="a34e20fa3c7b4ab363aafbc4796d52d1c" name="a34e20fa3c7b4ab363aafbc4796d52d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e20fa3c7b4ab363aafbc4796d52d1c">&#9670;&#160;</a></span>RotationAxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S&gt; <br />
requires ( S::Size &gt; 2 )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::RotationAxis </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>axis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>angle</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a matrix that rotates around an arbitrary axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The axis of rotation. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle of rotation in radians, measured clockwise when looking along the rotation axis toward the origin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a id="aa1f1abed5223b2f5db7aca783ee50a4d" name="aa1f1abed5223b2f5db7aca783ee50a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f1abed5223b2f5db7aca783ee50a4d">&#9670;&#160;</a></span>RotationNormal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S&gt; <br />
requires ( S::Size &gt; 2 )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::RotationNormal </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>normalizedAxis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>angle</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a matrix that rotates around a normalized vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalizedAxis</td><td>Normalized vector defining the axis of rotation. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle of rotation in radians, measured clockwise when looking along the rotation axis toward the origin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalizedAxis</td><td>Normalized vector defining the axis of rotation. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle of rotation in radians, measured clockwise when looking along the rotation axis toward the origin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a id="a676b83fba8557911e19e9fe55bd9bb7b" name="a676b83fba8557911e19e9fe55bd9bb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676b83fba8557911e19e9fe55bd9bb7b">&#9670;&#160;</a></span>RotationQuaternion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::RotationQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a>&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rotation matrix from a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion that defines the rotation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a id="aad2641419ead7bb00457bd4d84eccb4b" name="aad2641419ead7bb00457bd4d84eccb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2641419ead7bb00457bd4d84eccb4b">&#9670;&#160;</a></span>RotationQuaternion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::RotationQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_quaternion.html">Quaternion</a>&lt; float &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rotation matrix from a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion that defines the rotation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a id="ab76601f15559c23bc8a25706bab103e6" name="ab76601f15559c23bc8a25706bab103e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76601f15559c23bc8a25706bab103e6">&#9670;&#160;</a></span>RotationX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::RotationX </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>angle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a matrix that rotates around the x-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Thw clockwise angle of rotation, in radians, around the x-axis when looking along the rotation axis toward the origin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a id="accb97478680f9efe69655e750d4af94c" name="accb97478680f9efe69655e750d4af94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb97478680f9efe69655e750d4af94c">&#9670;&#160;</a></span>RotationY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::RotationY </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>angle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a matrix that rotates around the y-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Thw clockwise angle of rotation, in radians, around the y-axis when looking along the rotation axis toward the origin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a id="a085be3848f9e107b57849f9ebc6cc351" name="a085be3848f9e107b57849f9ebc6cc351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085be3848f9e107b57849f9ebc6cc351">&#9670;&#160;</a></span>RotationZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::RotationZ </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>angle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a matrix that rotates around the z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Thw clockwise angle of rotation, in radians, around the z-axis when looking along the rotation axis toward the origin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a id="a911600f1f74a037d060c0bbb4c790f20" name="a911600f1f74a037d060c0bbb4c790f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911600f1f74a037d060c0bbb4c790f20">&#9670;&#160;</a></span>Round() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Round </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds each element held by the argument towards the nearest even integer. </p>

</div>
</div>
<a id="a20b03b2cb6214d5450c019fbc6296e7b" name="a20b03b2cb6214d5450c019fbc6296e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b03b2cb6214d5450c019fbc6296e7b">&#9670;&#160;</a></span>Round() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Round </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just returns value. </p>
<p>Computes the nearest integer to value, in floating-point format, rounding halfway cases away from zero. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest integer to value. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value </dd></dl>

</div>
</div>
<a id="ab108521bc793a505b9d93d50f1db0eaf" name="ab108521bc793a505b9d93d50f1db0eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab108521bc793a505b9d93d50f1db0eaf">&#9670;&#160;</a></span>RoundUpPow2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common.html#a77b0045551d73ca9f4fb32769fa84426">Int32</a> Harlinn::Math::RoundUpPow2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common.html#a77b0045551d73ca9f4fb32769fa84426">Int32</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a37e37e862367f901968ae1f0e7400176" name="a37e37e862367f901968ae1f0e7400176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e37e862367f901968ae1f0e7400176">&#9670;&#160;</a></span>RoundUpPow2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_harlinn_1_1_common.html#a5a63a6a5f3e67cefd19fb0873208989d">Int64</a> Harlinn::Math::RoundUpPow2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_harlinn_1_1_common.html#a5a63a6a5f3e67cefd19fb0873208989d">Int64</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c1ea54e3924007682ae3b77ba499e69" name="a7c1ea54e3924007682ae3b77ba499e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1ea54e3924007682ae3b77ba499e69">&#9670;&#160;</a></span>RoundUpPow4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::RoundUpPow4 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fc13a292cba2405c45b85d031b77514" name="a9fc13a292cba2405c45b85d031b77514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc13a292cba2405c45b85d031b77514">&#9670;&#160;</a></span>SafeACos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SafeACos </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a595908c27d79b6389435e1ffbb27d23f" name="a595908c27d79b6389435e1ffbb27d23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595908c27d79b6389435e1ffbb27d23f">&#9670;&#160;</a></span>SafeASin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SafeASin </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9489effee421440e6b4b0351e93dab1" name="ad9489effee421440e6b4b0351e93dab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9489effee421440e6b4b0351e93dab1">&#9670;&#160;</a></span>SafeSqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::SafeSqrt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the square root of each element greater or equal to 0.f in the argument. For elements less than 0.f, the result is 0.f. </p>

</div>
</div>
<a id="a195cd91b0542e3d22137b7ec949100c0" name="a195cd91b0542e3d22137b7ec949100c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195cd91b0542e3d22137b7ec949100c0">&#9670;&#160;</a></span>SafeSqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SafeSqrt </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c4899c3646b6723f75494a142dbf805" name="a3c4899c3646b6723f75494a142dbf805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4899c3646b6723f75494a142dbf805">&#9670;&#160;</a></span>Saturate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Saturate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saturates the elements of v to the range 0.0 to 1.0. </p>

</div>
</div>
<a id="a6b71e6c04f9d4206d02650a3a6510e7c" name="a6b71e6c04f9d4206d02650a3a6510e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b71e6c04f9d4206d02650a3a6510e7c">&#9670;&#160;</a></span>ScalarAbsDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ScalarAbsDot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the absolute value of the dot product between v1 and v2. </p>

</div>
</div>
<a id="a30b5fc6c7c9034cd605b23d36c997b15" name="a30b5fc6c7c9034cd605b23d36c997b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b5fc6c7c9034cd605b23d36c997b15">&#9670;&#160;</a></span>ScalarAngleBetween() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ScalarAngleBetween </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad81a7492e799828f6e7d4be05dae1d13" name="ad81a7492e799828f6e7d4be05dae1d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81a7492e799828f6e7d4be05dae1d13">&#9670;&#160;</a></span>ScalarAngleBetween() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename FloatT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::ScalarAngleBetween </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a>&lt; DerivedT, FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html">Tuple3</a>&lt; DerivedT, FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98ff1e24f0318f885a4f0f824059b647" name="a98ff1e24f0318f885a4f0f824059b647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ff1e24f0318f885a4f0f824059b647">&#9670;&#160;</a></span>ScalarAvg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::value_type Harlinn::Math::ScalarAvg </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the average value of the elements in the argument. </p>

</div>
</div>
<a id="ad6986744d3bf3a56eb85a861eaeea751" name="ad6986744d3bf3a56eb85a861eaeea751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6986744d3bf3a56eb85a861eaeea751">&#9670;&#160;</a></span>ScalarDeterminant() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Harlinn::Math::ScalarDeterminant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05d536fa51dd08c4f743adccffa86db8" name="a05d536fa51dd08c4f743adccffa86db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d536fa51dd08c4f743adccffa86db8">&#9670;&#160;</a></span>ScalarDeterminant() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Harlinn::Math::ScalarDeterminant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af27380204bf720dc4efefa91a93cb606" name="af27380204bf720dc4efefa91a93cb606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27380204bf720dc4efefa91a93cb606">&#9670;&#160;</a></span>ScalarDeterminant() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Harlinn::Math::ScalarDeterminant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the determinant of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix that the determinant will be calculated for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the matrix. </dd></dl>

</div>
</div>
<a id="a01094c311b40f985bde98581f7dfc177" name="a01094c311b40f985bde98581f7dfc177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01094c311b40f985bde98581f7dfc177">&#9670;&#160;</a></span>ScalarDeterminant() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Harlinn::Math::ScalarDeterminant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the determinant of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix that the determinant will be calculated for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the matrix. </dd></dl>

</div>
</div>
<a id="af51cf618cee5a168c1fb2cc47f41af6c" name="af51cf618cee5a168c1fb2cc47f41af6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51cf618cee5a168c1fb2cc47f41af6c">&#9670;&#160;</a></span>ScalarDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ScalarDistance </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0232e9d00987e9fc0013d4eb0c610a31" name="a0232e9d00987e9fc0013d4eb0c610a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0232e9d00987e9fc0013d4eb0c610a31">&#9670;&#160;</a></span>ScalarDistanceSquared() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#ae8eda03ef4993145c2888150d80a2892">Internal::HasSimdType</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ScalarDistanceSquared </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the squared distance between p1 and p2. </p>

</div>
</div>
<a id="af5936a2b50a56de122afc7b9b32b41c2" name="af5936a2b50a56de122afc7b9b32b41c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5936a2b50a56de122afc7b9b32b41c2">&#9670;&#160;</a></span>ScalarDistanceSquared() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T, TupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ScalarDistanceSquared </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the squared distance between p1 and p2. </p>

</div>
</div>
<a id="aa4a6ee17ae410663b02855e1e8f2f82a" name="aa4a6ee17ae410663b02855e1e8f2f82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a6ee17ae410663b02855e1e8f2f82a">&#9670;&#160;</a></span>ScalarDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ScalarDot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product of two quaternions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>The first quaternion. </td></tr>
    <tr><td class="paramname">q2</td><td>The second quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product between q1 and q2. </dd></dl>

</div>
</div>
<a id="a4eca8e0eca1deb0b0d310317b9e57afa" name="a4eca8e0eca1deb0b0d310317b9e57afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eca8e0eca1deb0b0d310317b9e57afa">&#9670;&#160;</a></span>ScalarDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T, SimdType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::value_type Harlinn::Math::ScalarDot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeeb28e7719c078f85e0ae98290c01570" name="aeeb28e7719c078f85e0ae98290c01570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb28e7719c078f85e0ae98290c01570">&#9670;&#160;</a></span>ScalarHProd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ScalarHProd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08699ba23118f73ba7ad0ae6039806d5" name="a08699ba23118f73ba7ad0ae6039806d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08699ba23118f73ba7ad0ae6039806d5">&#9670;&#160;</a></span>ScalarHProd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T, typename ResultT  = typename T::value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultT Harlinn::Math::ScalarHProd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the horizontal product of the elements in the vector. </p>

</div>
</div>
<a id="a4484fd1e7e6afea47401f08ba170db8d" name="a4484fd1e7e6afea47401f08ba170db8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4484fd1e7e6afea47401f08ba170db8d">&#9670;&#160;</a></span>ScalarHSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::value_type Harlinn::Math::ScalarHSum </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the horizontal sum of the elements in the vector. </p>

</div>
</div>
<a id="afbb677fdd2d3818f18c641b0979867e2" name="afbb677fdd2d3818f18c641b0979867e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb677fdd2d3818f18c641b0979867e2">&#9670;&#160;</a></span>ScalarLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ScalarLength </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the length of v. </p>
<p>Calculates the magnitude of a quaternion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The magnitude of the quaternion. </dd></dl>

</div>
</div>
<a id="a845a18f6d14abfb760de3a704fdecb91" name="a845a18f6d14abfb760de3a704fdecb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845a18f6d14abfb760de3a704fdecb91">&#9670;&#160;</a></span>ScalarLengthSquared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ScalarLengthSquared </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the square of the magnitude of a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square of the magnitude of the quaternion. </dd></dl>

</div>
</div>
<a id="ad0f4468eca5feda1c1d36d561e0bd15e" name="ad0f4468eca5feda1c1d36d561e0bd15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f4468eca5feda1c1d36d561e0bd15e">&#9670;&#160;</a></span>ScalarReciprocalLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ScalarReciprocalLength </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the reciprocal length of v. </p>
<p>Calculates the reciprocal of the magnitude of a quaternion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reciprocal of the magnitude of the quaternion. </dd></dl>

</div>
</div>
<a id="add198978b31fa2f9b124057521d6bb07" name="add198978b31fa2f9b124057521d6bb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add198978b31fa2f9b124057521d6bb07">&#9670;&#160;</a></span>ScaleBN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Harlinn::Math::ScaleBN </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies a double precision floating point value <code>x</code> multplied by <code>FLT_RADIX</code> raised to power <code>n</code>. </p>
<p>FLT_RADIX is the radix used by the representation of the floating point types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A double precision floating point value. </td></tr>
    <tr><td class="paramname">n</td><td>An integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> multiplied by <code>FLT_RADIX</code> raised to power <code>n</code> </dd></dl>

</div>
</div>
<a id="a1117ad0a3fb50451d847edb702f0096e" name="a1117ad0a3fb50451d847edb702f0096e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1117ad0a3fb50451d847edb702f0096e">&#9670;&#160;</a></span>ScaleBN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Harlinn::Math::ScaleBN </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies a double precision floating point value <code>x</code> multplied by <code>FLT_RADIX</code> raised to power <code>n</code>. </p>
<p>FLT_RADIX is the radix used by the representation of the floating point types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A double precision floating point value. </td></tr>
    <tr><td class="paramname">n</td><td>An integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>x</code> multplied by <code>FLT_RADIX</code> raised to power <code>n</code> </dd></dl>

</div>
</div>
<a id="aeb67684dc0e1c65a5551f8182f6bc7f1" name="aeb67684dc0e1c65a5551f8182f6bc7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb67684dc0e1c65a5551f8182f6bc7f1">&#9670;&#160;</a></span>Scaling() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S&gt; <br />
requires ( S::Size &gt; 2 )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Scaling </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a transformation matrix for scaling along the x-axis, y-axis, and z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Scaling factors along the x-axis, y-axis, and z-axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaling matrix. </dd></dl>

</div>
</div>
<a id="a958995f0dfc1740ec052cc91d158b4bb" name="a958995f0dfc1740ec052cc91d158b4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958995f0dfc1740ec052cc91d158b4bb">&#9670;&#160;</a></span>Scaling() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Scaling </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a transformation matrix for scaling along the x-axis, y-axis, and z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Scaling factor along the x-axis, y-axis, and z-axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaling matrix. </dd></dl>

</div>
</div>
<a id="a34301223edef4910b4f41aa676e1e3fe" name="a34301223edef4910b4f41aa676e1e3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34301223edef4910b4f41aa676e1e3fe">&#9670;&#160;</a></span>Scaling() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Scaling </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scaleX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scaleY</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b42a2a600b71648715f5a4aa24f7658" name="a6b42a2a600b71648715f5a4aa24f7658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b42a2a600b71648715f5a4aa24f7658">&#9670;&#160;</a></span>Scaling() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Scaling </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scaleX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scaleY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scaleZ</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a transformation matrix for scaling along the x-axis, y-axis, and z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>Scaling factor along the x-axis. </td></tr>
    <tr><td class="paramname">scaleY</td><td>Scaling factor along the y-axis. </td></tr>
    <tr><td class="paramname">scaleZ</td><td>Scaling factor along the z-axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaling matrix. </dd></dl>

</div>
</div>
<a id="aa9a8a0fb7499de63d548081dc4233918" name="aa9a8a0fb7499de63d548081dc4233918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a8a0fb7499de63d548081dc4233918">&#9670;&#160;</a></span>Select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType S, SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::Select </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>control</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a per-component selection between two input vectors and returns the resulting vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first source to select elements from. </td></tr>
    <tr><td class="paramname">v2</td><td>The second source to select elements from. </td></tr>
    <tr><td class="paramname">control</td><td>Mask used to select an element from either v1 or v2. If an element in control is zero, the corresponding element in the result will be from v1, if an element control is 0xFFFFFFFF, the corresponding element in the result will be from v2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac241719bf1efad28424d9bf63041785d" name="ac241719bf1efad28424d9bf63041785d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac241719bf1efad28424d9bf63041785d">&#9670;&#160;</a></span>ShortestArc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt; &amp;&amp; ( T::Size == 3 )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::ShortestArc </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>fromDir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>toDir</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the shortest-arc rotation between two directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromDir</td><td>The from direction. </td></tr>
  </table>
  </dd>
</dl>
<p>/// </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toDir</td><td>The to direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation quaternion. </dd></dl>

</div>
</div>
<a id="a8a7363afb76b6078844e9e73225f9e73" name="a8a7363afb76b6078844e9e73225f9e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7363afb76b6078844e9e73225f9e73">&#9670;&#160;</a></span>SignBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SignedIntegerType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::SignBit </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given signed integer value is negative. </p>
<p>An Implementation of SignBit for unsigned integers that always returns false.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any signed integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A signed integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns true if the value is signed, otherwise false. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>An unsigned integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false </dd></dl>
<p>Determines if the given floating point number is negative. </p>
<p>Currently this implementation is 70 % faster than std::signbit, and it can also be constexpr evaluated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if val is less than 0.0. </dd></dl>

</div>
</div>
<a id="af7fca65484972bed23f0608446920cd2" name="af7fca65484972bed23f0608446920cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fca65484972bed23f0608446920cd2">&#9670;&#160;</a></span>signum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;UnsignedIntegerOrBooleanType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::signum </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sign of a value for a signed integer type. </p>
<p>Returns the sign of a value for a floating point type.</p>
<p>Returns the sign of a value for a bool or an unsigned integer type. </p>
<p>This function treats bool as an unsigned integer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>bool or an unsigned integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If invoked with a bool this function returns true if the value is not false, otherwise false. </dd></dl>
<p>If invoked with an unsigned integer type this function returns 1 if the value is greater than 0, otherwise 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any signed integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns: <ul>
<li>
-1 if val is less than zero. </li>
<li>
0 if val is equal to zero. </li>
<li>
1 if val is greater than zero. </li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns: <ul>
<li>
-1.0 if val is less than zero. </li>
<li>
0.0 if val is equal to zero. </li>
<li>
1.0 if val is greater than zero. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5ed3ad7f508d48826bb791e737cca7b0" name="a5ed3ad7f508d48826bb791e737cca7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed3ad7f508d48826bb791e737cca7b0">&#9670;&#160;</a></span>Sin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::Sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b81740275833db47fce3675780ffb67" name="a8b81740275833db47fce3675780ffb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b81740275833db47fce3675780ffb67">&#9670;&#160;</a></span>Sin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Sin </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the sine of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="a2cda4c9af933ba7b46204284ce8351e7" name="a2cda4c9af933ba7b46204284ce8351e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cda4c9af933ba7b46204284ce8351e7">&#9670;&#160;</a></span>Sin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Sin </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the sine of x given in radians. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sine of x given in radians. </dd></dl>

</div>
</div>
<a id="afe47c199d5e608fe1b01ccdecd75537e" name="afe47c199d5e608fe1b01ccdecd75537e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe47c199d5e608fe1b01ccdecd75537e">&#9670;&#160;</a></span>Sinc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Sinc </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71849e3814aba993a77ffc5186e9164c" name="a71849e3814aba993a77ffc5186e9164c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71849e3814aba993a77ffc5186e9164c">&#9670;&#160;</a></span>SinCos() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Math::SinCos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; *</td>          <td class="paramname"><span class="paramname"><em>sine</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; *</td>          <td class="paramname"><span class="paramname"><em>cosine</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a701492ad1f13932a750e33478d1b94e4" name="a701492ad1f13932a750e33478d1b94e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701492ad1f13932a750e33478d1b94e4">&#9670;&#160;</a></span>SinCos() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SinCos </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>cosines</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the sine and cosine of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="afc4d39644295d3bd1b454e43dfe22673" name="afc4d39644295d3bd1b454e43dfe22673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4d39644295d3bd1b454e43dfe22673">&#9670;&#160;</a></span>SinCos() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::Simd Harlinn::Math::SinCos </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename T::Simd *</td>          <td class="paramname"><span class="paramname"><em>cosines</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the sine and cosine of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="a4951f89b4120b9fd896b8fa11587d1b8" name="a4951f89b4120b9fd896b8fa11587d1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4951f89b4120b9fd896b8fa11587d1b8">&#9670;&#160;</a></span>SinCos() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Math::SinCos </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>sinResult</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>cosResult</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simultaneously compute the sine and cosine of x, where x is in radians, returning the sine in the variable referenced by sinResult, and the cosine in the variable referenced by cosResult. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">sinResult</td><td></td></tr>
    <tr><td class="paramname">cosResult</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2b40bd264eba167ec8cf689504cf762" name="ad2b40bd264eba167ec8cf689504cf762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b40bd264eba167ec8cf689504cf762">&#9670;&#160;</a></span>SinCos() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Harlinn::Math::SinCos </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>sinResult</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>cosResult</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simultaneously compute the sine and cosine of x, where x is in radians, returning the sine in the variable referenced by sinResult, and the cosine in the variable referenced by cosResult. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
    <tr><td class="paramname">sinResult</td><td></td></tr>
    <tr><td class="paramname">cosResult</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6878772c2f5fec34d65f22f07291de1" name="ae6878772c2f5fec34d65f22f07291de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6878772c2f5fec34d65f22f07291de1">&#9670;&#160;</a></span>SinH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::SinH </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the hyperbolic sine of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="a9ca64a6a4c5815e4a1505c462998dbd7" name="a9ca64a6a4c5815e4a1505c462998dbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca64a6a4c5815e4a1505c462998dbd7">&#9670;&#160;</a></span>SinH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SinH </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the hyperbolic sine of x. </p>

</div>
</div>
<a id="a3dae882956db203d2d86a1beb21de149" name="a3dae882956db203d2d86a1beb21de149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dae882956db203d2d86a1beb21de149">&#9670;&#160;</a></span>SinXOverX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SinXOverX </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6884f244221cfbec2986a8052bdbb20f" name="a6884f244221cfbec2986a8052bdbb20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6884f244221cfbec2986a8052bdbb20f">&#9670;&#160;</a></span>Slerp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U, SimdOrTupleType V&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt; &amp;&amp; ( V::Size == 4 )</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Slerp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spherical linear interpolation between two unit quaternions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>The unit quaternion to interpolate from. </td></tr>
    <tr><td class="paramname">q2</td><td>The unit quaternion to interpolate to. </td></tr>
    <tr><td class="paramname">t</td><td>Interpolation control factor. Every element of this vector must be set to the same value. When the elements of t is 0.0, the function returns q1, and when the elements of t is 1.0, the function returns q2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9cb07950d74b4056483380a8912c2c07" name="a9cb07950d74b4056483380a8912c2c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb07950d74b4056483380a8912c2c07">&#9670;&#160;</a></span>Slerp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType U, ArithmeticType V&gt; <br />
requires <a class="el" href="#ada36e8b3cd1f8901977574f25c1ec5f1">IsCompatibleQuaternion</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Slerp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spherical linear interpolation between two unit quaternions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>The unit quaternion to interpolate from. </td></tr>
    <tr><td class="paramname">q2</td><td>The unit quaternion to interpolate to. </td></tr>
    <tr><td class="paramname">t</td><td>Interpolation control factor. When the value of t is 0.0, the function returns q1, and when the value of t is 1.0, the function returns q2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a5b1cef4f733e6ea947b5f4ebe2d9e8c8" name="a5b1cef4f733e6ea947b5f4ebe2d9e8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1cef4f733e6ea947b5f4ebe2d9e8c8">&#9670;&#160;</a></span>SmoothStep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SmoothStep </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d758869a4905dc59b83cd1d6adbf250" name="a3d758869a4905dc59b83cd1d6adbf250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d758869a4905dc59b83cd1d6adbf250">&#9670;&#160;</a></span>Sqr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::Sqr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>interval</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1e536a3cb0839f61145068e8287c7c7" name="ae1e536a3cb0839f61145068e8287c7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e536a3cb0839f61145068e8287c7c7">&#9670;&#160;</a></span>Sqr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Sqr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the square value of each element held by the argument. </p>

</div>
</div>
<a id="aa8d281aa4ef59aa712d1d660f3174236" name="aa8d281aa4ef59aa712d1d660f3174236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d281aa4ef59aa712d1d660f3174236">&#9670;&#160;</a></span>Sqr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad60f420a7f44c2b0e9ce86950287dbad">IsArithmetic</a>&lt;T&gt; || <a class="el" href="namespace_harlinn_1_1_math_1_1_internal.html#a6d561311e1d4391071493f487c17876d">Internal::IsComplex</a>&lt;T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Sqr </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae378941c4232854a169b595cac51f8b6" name="ae378941c4232854a169b595cac51f8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae378941c4232854a169b595cac51f8b6">&#9670;&#160;</a></span>Sqrt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::Sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7666b593d30618e1a95398e789f3b1c" name="ab7666b593d30618e1a95398e789f3b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7666b593d30618e1a95398e789f3b1c">&#9670;&#160;</a></span>Sqrt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Sqrt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the square root of each element in the argument. </p>

</div>
</div>
<a id="a0e3f8fdcb1da1e0e79143bd71f1e128d" name="a0e3f8fdcb1da1e0e79143bd71f1e128d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3f8fdcb1da1e0e79143bd71f1e128d">&#9670;&#160;</a></span>Sqrt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Sqrt </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the square root of x. <br  />
 </p>
<p>The runtime performance of this implementation is equivalent to the runtime performance of std::sqrt. </p>
<p>Unlike std::sqrt this implementation can be constexpr evaluated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the square root of x. </dd></dl>

</div>
</div>
<a id="a6e1b92832070c2e8e400e5b27076067f" name="a6e1b92832070c2e8e400e5b27076067f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1b92832070c2e8e400e5b27076067f">&#9670;&#160;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad93ba39b1fd7996108093248f2da5b02" name="ad93ba39b1fd7996108093248f2da5b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93ba39b1fd7996108093248f2da5b02">&#9670;&#160;</a></span>SqrtAdjustDown() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::SqrtAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0839a63c1f94a51660d37e2f6305cb5" name="ac0839a63c1f94a51660d37e2f6305cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0839a63c1f94a51660d37e2f6305cb5">&#9670;&#160;</a></span>SqrtAdjustDown() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S::Simd Harlinn::Math::SqrtAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32fc2a3d45bd254b655d6b90b623f78d" name="a32fc2a3d45bd254b655d6b90b623f78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fc2a3d45bd254b655d6b90b623f78d">&#9670;&#160;</a></span>SqrtAdjustDown() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SqrtAdjustDown </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fed943c191fac14f41b20c994f1d83b" name="a6fed943c191fac14f41b20c994f1d83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fed943c191fac14f41b20c994f1d83b">&#9670;&#160;</a></span>SqrtAdjustUp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::SqrtAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc765d2ea0f51551231ce5e0c056f4f9" name="afc765d2ea0f51551231ce5e0c056f4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc765d2ea0f51551231ce5e0c056f4f9">&#9670;&#160;</a></span>SqrtAdjustUp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S::Simd Harlinn::Math::SqrtAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a084d90500487f34529e59fd7e373de9e" name="a084d90500487f34529e59fd7e373de9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084d90500487f34529e59fd7e373de9e">&#9670;&#160;</a></span>SqrtAdjustUp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SqrtAdjustUp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9122d0438e18a03261d45460ba892eb8" name="a9122d0438e18a03261d45460ba892eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9122d0438e18a03261d45460ba892eb8">&#9670;&#160;</a></span>SubAdjustDown() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::SubAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70830bc95de2dd87f85e16122098531c" name="a70830bc95de2dd87f85e16122098531c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70830bc95de2dd87f85e16122098531c">&#9670;&#160;</a></span>SubAdjustDown() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SubAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a580ff114a60306df67376f15eaa8727a" name="a580ff114a60306df67376f15eaa8727a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580ff114a60306df67376f15eaa8727a">&#9670;&#160;</a></span>SubAdjustDown() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S::Simd Harlinn::Math::SubAdjustDown </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08144ad5b613b4d2de2710a4706c99a5" name="a08144ad5b613b4d2de2710a4706c99a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08144ad5b613b4d2de2710a4706c99a5">&#9670;&#160;</a></span>SubAdjustDown() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SubAdjustDown </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb2def5a3d62d220f756af1fd9eb9d49" name="adb2def5a3d62d220f756af1fd9eb9d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2def5a3d62d220f756af1fd9eb9d49">&#9670;&#160;</a></span>SubAdjustUp() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S Harlinn::Math::SubAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2e81baab7edbc21f3b0167ca2c580ae" name="ad2e81baab7edbc21f3b0167ca2c580ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e81baab7edbc21f3b0167ca2c580ae">&#9670;&#160;</a></span>SubAdjustUp() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, SimdType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SubAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f465768111b8acec4c637c68c3415b6" name="a1f465768111b8acec4c637c68c3415b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f465768111b8acec4c637c68c3415b6">&#9670;&#160;</a></span>SubAdjustUp() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TupleType S, TupleType T&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;S, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">S::Simd Harlinn::Math::SubAdjustUp </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabe0d52f39ed6609f80823d4e1e13da0" name="aabe0d52f39ed6609f80823d4e1e13da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe0d52f39ed6609f80823d4e1e13da0">&#9670;&#160;</a></span>SubAdjustUp() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::SubAdjustUp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7f1a977bd237afc8a98de60c9b50a18" name="ab7f1a977bd237afc8a98de60c9b50a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f1a977bd237afc8a98de60c9b50a18">&#9670;&#160;</a></span>SubtractAngles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::SubtractAngles </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the angles in v2 from the corresponding elements of v1. The argument angles must be in the range [-PI,PI), and the computed angles will be in the range [-PI,PI) </p>

</div>
</div>
<a id="a421921bcf9992b0f27dbb0a513a5f2ee" name="a421921bcf9992b0f27dbb0a513a5f2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421921bcf9992b0f27dbb0a513a5f2ee">&#9670;&#160;</a></span>SumOfProducts() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::SumOfProducts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a244585ee75d84b3a2da60a7b7cff3231" name="a244585ee75d84b3a2da60a7b7cff3231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244585ee75d84b3a2da60a7b7cff3231">&#9670;&#160;</a></span>SumOfProducts() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdTupleOrArithmeticType S, SimdOrTupleType T, SimdTupleOrArithmeticType U, SimdTupleOrArithmeticType V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::SumOfProducts </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;</td>          <td class="paramname"><span class="paramname"><em>v4</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the sum of the product of the first and the second argument, and the product of the third and fourth argument. </p>

</div>
</div>
<a id="a8794de781c29b9ead14f92f70fa60a4a" name="a8794de781c29b9ead14f92f70fa60a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8794de781c29b9ead14f92f70fa60a4a">&#9670;&#160;</a></span>SumOfProducts() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ta , typename Tb , typename Tc , typename Td &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Ta&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Tb&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Tc&gt;&amp;&amp; <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;Td&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::SumOfProducts </td>
          <td>(</td>
          <td class="paramtype">Ta</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tb</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tc</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Td</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62868ab4274547369265ecd49fb53c48" name="a62868ab4274547369265ecd49fb53c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62868ab4274547369265ecd49fb53c48">&#9670;&#160;</a></span>SumSquares() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::SumSquares </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af987177f961161198080296c3753949d" name="af987177f961161198080296c3753949d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af987177f961161198080296c3753949d">&#9670;&#160;</a></span>SumSquares() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT , typename... Args&gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; Harlinn::Math::SumSquares </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_interval.html">Interval</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3d486627e18042d3cb0d35aa4ccace4" name="aa3d486627e18042d3cb0d35aa4ccace4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d486627e18042d3cb0d35aa4ccace4">&#9670;&#160;</a></span>Tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Tan </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the tangent of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="a66c05610ff1785a8a11044eb8365c4d4" name="a66c05610ff1785a8a11044eb8365c4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c05610ff1785a8a11044eb8365c4d4">&#9670;&#160;</a></span>Tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Tan </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the tangent of x given in radians. </p>
<p>This implementation can be constexpr evaluated, and at runtime calls std::tan. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tangent of x given in radians. </dd></dl>

</div>
</div>
<a id="a09340bd80cd86c491c3091922b9acb80" name="a09340bd80cd86c491c3091922b9acb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09340bd80cd86c491c3091922b9acb80">&#9670;&#160;</a></span>TanH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::TanH </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the hyperbolic tangent of each element in the argument expressed in radians. </p>

</div>
</div>
<a id="a556d81635f87c44de6b739a7144f0309" name="a556d81635f87c44de6b739a7144f0309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556d81635f87c44de6b739a7144f0309">&#9670;&#160;</a></span>TanH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::TanH </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the hyperbolic tangent of x. </p>

</div>
</div>
<a id="a739d328385f050bbe3f0b7f7fe65a44a" name="a739d328385f050bbe3f0b7f7fe65a44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739d328385f050bbe3f0b7f7fe65a44a">&#9670;&#160;</a></span>TGamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::TGamma </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the gamma function of x. </p>

</div>
</div>
<a id="a87fb33758c5743a91b4a7eac45313d40" name="a87fb33758c5743a91b4a7eac45313d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fb33758c5743a91b4a7eac45313d40">&#9670;&#160;</a></span>Transform() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a43e3e7d66212411e17fb90bdadba1354">Normal3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a normal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The normal. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="a224fc718e1811160e2ff02db34d2f07d" name="a224fc718e1811160e2ff02db34d2f07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224fc718e1811160e2ff02db34d2f07d">&#9670;&#160;</a></span>Transform() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a43e3e7d66212411e17fb90bdadba1354">Normal3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a normal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The normal. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="ac65c6ba4435a6c75062be956ec90026f" name="ac65c6ba4435a6c75062be956ec90026f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65c6ba4435a6c75062be956ec90026f">&#9670;&#160;</a></span>Transform() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a normal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The normal. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="ad36fea0bb34d938288620a56829fae22" name="ad36fea0bb34d938288620a56829fae22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36fea0bb34d938288620a56829fae22">&#9670;&#160;</a></span>Transform() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a normal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The normal. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="ab861d58fd40d8bbbb9e5277b384410be" name="ab861d58fd40d8bbbb9e5277b384410be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab861d58fd40d8bbbb9e5277b384410be">&#9670;&#160;</a></span>Transform() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a normal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The normal. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="a27b0f7ad7e7c00da3461736b995b13dc" name="a27b0f7ad7e7c00da3461736b995b13dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b0f7ad7e7c00da3461736b995b13dc">&#9670;&#160;</a></span>Transform() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a normal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The normal. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="a922f783d63c073da7ef485f264f875dd" name="a922f783d63c073da7ef485f264f875dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922f783d63c073da7ef485f264f875dd">&#9670;&#160;</a></span>Transform() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_plane.html">Plane</a>&lt; float &gt;::Simd Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_plane.html">Plane</a>&lt; float &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>transformationMatrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5b38f8116123a40bc6f2016787deca2" name="ac5b38f8116123a40bc6f2016787deca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b38f8116123a40bc6f2016787deca2">&#9670;&#160;</a></span>Transform() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple2.html#aec4a2899d234894c2f377ea8e5a33857">Point2f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple2.html#aec4a2899d234894c2f377ea8e5a33857">Point2f::Simd</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a 2D coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The 2D coordinate. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="a1eb29887a16e7d057515d7695eedf40b" name="a1eb29887a16e7d057515d7695eedf40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb29887a16e7d057515d7695eedf40b">&#9670;&#160;</a></span>Transform() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3e227c35130c9e7e322ead53eeff7b6e">Point3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a 3D coordinate. </p>
<p>Applies a transformation matrix to a normal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The 3D coordinate. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The normal. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="a450ad7a7a92c53a0695da972870db6d8" name="a450ad7a7a92c53a0695da972870db6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450ad7a7a92c53a0695da972870db6d8">&#9670;&#160;</a></span>Transform() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Normal3f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3e227c35130c9e7e322ead53eeff7b6e">Point3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a 3D coordinate. </p>
<p>Applies a transformation matrix to a normal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The 3D coordinate. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The normal. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="ae851e035a0e3787898e33ef6900738d2" name="ae851e035a0e3787898e33ef6900738d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae851e035a0e3787898e33ef6900738d2">&#9670;&#160;</a></span>Transform() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a 3D coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The 3D coordinate. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="aba1d5383f7ec894eb0ef95eea5fe83ed" name="aba1d5383f7ec894eb0ef95eea5fe83ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1d5383f7ec894eb0ef95eea5fe83ed">&#9670;&#160;</a></span>Transform() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a> Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_tuple3.html#ac21b5b72116042645ecc4d644483c1fc">Point3f::Simd</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a 3D coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The 3D coordinate. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="ada263e6c5f2aeb53798c204ccb03c95d" name="ada263e6c5f2aeb53798c204ccb03c95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada263e6c5f2aeb53798c204ccb03c95d">&#9670;&#160;</a></span>Transform() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 2 &gt;::Simd Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 2 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a 2D vector by a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
    <tr><td class="paramname">matrix</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a752a3cc24e6d697bea03ab245bc15bf9" name="a752a3cc24e6d697bea03ab245bc15bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752a3cc24e6d697bea03ab245bc15bf9">&#9670;&#160;</a></span>Transform() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a 3D vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="aad7ba1c29b1bb2b88b48c4b446211b0d" name="aad7ba1c29b1bb2b88b48c4b446211b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7ba1c29b1bb2b88b48c4b446211b0d">&#9670;&#160;</a></span>Transform() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a 3D vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="a0d0027cca999b58c2dfa35f96bf7ed54" name="a0d0027cca999b58c2dfa35f96bf7ed54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0027cca999b58c2dfa35f96bf7ed54">&#9670;&#160;</a></span>Transform() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a 3D vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="a931e9f6b261bebeab93e34fab710bca1" name="a931e9f6b261bebeab93e34fab710bca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931e9f6b261bebeab93e34fab710bca1">&#9670;&#160;</a></span>Transform() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a transformation matrix to a 3D vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector. </td></tr>
    <tr><td class="paramname">matrix</td><td>The transformation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation result. </dd></dl>

</div>
</div>
<a id="a5fe7a244ec792a5e5f027c7ffd85987c" name="a5fe7a244ec792a5e5f027c7ffd85987c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe7a244ec792a5e5f027c7ffd85987c">&#9670;&#160;</a></span>Transform() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_vector.html">Vector</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4eb60720db709f8ac7ea776c95bed89" name="ab4eb60720db709f8ac7ea776c95bed89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eb60720db709f8ac7ea776c95bed89">&#9670;&#160;</a></span>TransformationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointOrPointSimdType PointT, QuaternionOrQuaternionSimdType QuaternionT, VectorOrVectorSimdType VectorT&gt; <br />
requires ( PointT::Size == 3 ) &amp;&amp; ( VectorT::Size == 3 ) &amp;&amp; std::is_same_v&lt;typename PointT::value_type, typename QuaternionT::value_type&gt;&amp;&amp; std::is_same_v&lt;typename PointT::value_type, typename VectorT::value_type&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; typenamePointT::value_type, 4 &gt;::Simd Harlinn::Math::TransformationMatrix </td>
          <td>(</td>
          <td class="paramtype">const PointT &amp;</td>          <td class="paramname"><span class="paramname"><em>scalingOrigin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuaternionT &amp;</td>          <td class="paramname"><span class="paramname"><em>scalingOrientationQuaternion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorT &amp;</td>          <td class="paramname"><span class="paramname"><em>scaling</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointT &amp;</td>          <td class="paramname"><span class="paramname"><em>rotationOrigin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuaternionT &amp;</td>          <td class="paramname"><span class="paramname"><em>rotationQuaternion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorT &amp;</td>          <td class="paramname"><span class="paramname"><em>translation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a transformation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalingOrigin</td><td>The center of the scaling. </td></tr>
    <tr><td class="paramname">scalingOrientationQuaternion</td><td>The orientation of the scaling. </td></tr>
    <tr><td class="paramname">scaling</td><td>The scaling factors for the x-axis, y-axis, and z-axis. </td></tr>
    <tr><td class="paramname">rotationOrigin</td><td>The center of the rotation. </td></tr>
    <tr><td class="paramname">rotationQuaternion</td><td>The rotation around the origin provided by rotationOrigin parameter. </td></tr>
    <tr><td class="paramname">translation</td><td>The translations along the x-axis, y-axis, and z-axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformation matrix. </dd></dl>

</div>
</div>
<a id="a2108dc0b27fba4880795227e5b8941d9" name="a2108dc0b27fba4880795227e5b8941d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2108dc0b27fba4880795227e5b8941d9">&#9670;&#160;</a></span>Translation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdType S&gt; <br />
requires ( S::Size &gt; 2 ) &amp;&amp; std::is_same_v&lt;typename S::value_type, float&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Translation </td>
          <td>(</td>
          <td class="paramtype">const S &amp;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a translation matrix using the provided offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>Translations along the x, y and z axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translation matrix. </dd></dl>

</div>
</div>
<a id="a98716baa55ecf7bff99a5b2b12fc5077" name="a98716baa55ecf7bff99a5b2b12fc5077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98716baa55ecf7bff99a5b2b12fc5077">&#9670;&#160;</a></span>Translation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Translation </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>offsetX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>offsetY</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec715c57979a3c11c339e26c248e6794" name="aec715c57979a3c11c339e26c248e6794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec715c57979a3c11c339e26c248e6794">&#9670;&#160;</a></span>Translation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Translation </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>offsetX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>offsetY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>offsetZ</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a translation matrix using the provided offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsetX</td><td>Translation along the x-axis. </td></tr>
    <tr><td class="paramname">offsetY</td><td>Translation along the y-axis. </td></tr>
    <tr><td class="paramname">offsetZ</td><td>Translation along the z-axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translation matrix. </dd></dl>

</div>
</div>
<a id="aef9562e78d43d89db1bd94214055e5a2" name="aef9562e78d43d89db1bd94214055e5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9562e78d43d89db1bd94214055e5a2">&#9670;&#160;</a></span>Transpose() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd Harlinn::Math::Transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac16aadd31879ae5f4690efbcd41a4cb9" name="ac16aadd31879ae5f4690efbcd41a4cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16aadd31879ae5f4690efbcd41a4cb9">&#9670;&#160;</a></span>Transpose() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a939e394d0b8ff88f3a49916e6a61613e" name="a939e394d0b8ff88f3a49916e6a61613e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939e394d0b8ff88f3a49916e6a61613e">&#9670;&#160;</a></span>Transpose() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd Harlinn::Math::Transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 3 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4c85009aa20ed3fbd0ccdce93996ca0" name="af4c85009aa20ed3fbd0ccdce93996ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c85009aa20ed3fbd0ccdce93996ca0">&#9670;&#160;</a></span>Transpose() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the transpose of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to transpose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transposed matrix. </dd></dl>

</div>
</div>
<a id="af5d770c36bd8c255dc890c69dde5c3db" name="af5d770c36bd8c255dc890c69dde5c3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d770c36bd8c255dc890c69dde5c3db">&#9670;&#160;</a></span>Transpose() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd Harlinn::Math::Transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 4 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the transpose of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to transpose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transposed matrix. </dd></dl>

</div>
</div>
<a id="a42eb9b47d3f2bf259f6ae5718e4561fe" name="a42eb9b47d3f2bf259f6ae5718e4561fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42eb9b47d3f2bf259f6ae5718e4561fe">&#9670;&#160;</a></span>Transpose() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd Harlinn::Math::Transpose </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_harlinn_1_1_math_1_1_square_matrix.html">SquareMatrix</a>&lt; float, 2 &gt;::Simd &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a115d953bebc17484e40b616eab6baeae" name="a115d953bebc17484e40b616eab6baeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115d953bebc17484e40b616eab6baeae">&#9670;&#160;</a></span>TrimmedLogistic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT Harlinn::Math::TrimmedLogistic </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a803a32aac6d2a6ab3a6e2e29a32be563" name="a803a32aac6d2a6ab3a6e2e29a32be563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803a32aac6d2a6ab3a6e2e29a32be563">&#9670;&#160;</a></span>Trunc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::Trunc </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds each element held by the argument to the nearest integer in the direction of zero. </p>

</div>
</div>
<a id="a0b30f7526b7049bb02d78f55f91cdfc6" name="a0b30f7526b7049bb02d78f55f91cdfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b30f7526b7049bb02d78f55f91cdfc6">&#9670;&#160;</a></span>Trunc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Trunc </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just returns value. </p>
<p>Computes the nearest integer not greater in magnitude than value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A floating point value with the nearest integer not greater in magnitude than value. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An integer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>An integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value </dd></dl>

</div>
</div>
<a id="a88433afa7fe7737d2f6a5d25c1f7c8e2" name="a88433afa7fe7737d2f6a5d25c1f7c8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88433afa7fe7737d2f6a5d25c1f7c8e2">&#9670;&#160;</a></span>TwoProd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_compensated_float.html">CompensatedFloat</a>&lt; FloatT &gt; Harlinn::Math::TwoProd </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad603311032dd7770227e6a71e021e0a7" name="ad603311032dd7770227e6a71e021e0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad603311032dd7770227e6a71e021e0a7">&#9670;&#160;</a></span>TwoSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT &gt; <br />
requires <a class="el" href="namespace_harlinn_1_1_common.html#ad98b9213de8a5f9a726a18f5ca651c6a">IsFloatingPoint</a>&lt;FloatT&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_harlinn_1_1_math_1_1_compensated_float.html">CompensatedFloat</a>&lt; FloatT &gt; Harlinn::Math::TwoSum </td>
          <td>(</td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FloatT</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2b72c4a04cc88f914c316703d3c9df4" name="aa2b72c4a04cc88f914c316703d3c9df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b72c4a04cc88f914c316703d3c9df4">&#9670;&#160;</a></span>UnitCross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SimdOrTupleType T, SimdOrTupleType U&gt; <br />
requires <a class="el" href="#aa6771851bd5f804c8fb6f047cd24af7a">IsCompatible</a>&lt;T, U&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Harlinn::Math::UnitCross </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the normalized cross product between v1 and v2. </p>

</div>
</div>
<a id="adbe09d2dc50c41f4f228d4d17c461b94" name="adbe09d2dc50c41f4f228d4d17c461b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe09d2dc50c41f4f228d4d17c461b94">&#9670;&#160;</a></span>WindowedSinc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::WindowedSinc </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>tau</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af430cdbdcbef67455f126323b1801d26" name="af430cdbdcbef67455f126323b1801d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af430cdbdcbef67455f126323b1801d26">&#9670;&#160;</a></span>Y0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Y0 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Bessel function of the second kind of order 0 for x. </p>

</div>
</div>
<a id="aa8cedf1c5b8e7a5fed78c288367779db" name="aa8cedf1c5b8e7a5fed78c288367779db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cedf1c5b8e7a5fed78c288367779db">&#9670;&#160;</a></span>Y1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::Y1 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Bessel function of the second kind of order 1 for x. </p>

</div>
</div>
<a id="aea91c7434d4165907c15de2a82b01383" name="aea91c7434d4165907c15de2a82b01383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea91c7434d4165907c15de2a82b01383">&#9670;&#160;</a></span>YN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;FloatingPointType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Harlinn::Math::YN </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Bessel function of the second kind of order n for x. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa6771851bd5f804c8fb6f047cd24af7a" name="aa6771851bd5f804c8fb6f047cd24af7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6771851bd5f804c8fb6f047cd24af7a">&#9670;&#160;</a></span>IsCompatible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsCompatible = ( std::is_same_v&lt;typename T::Traits, typename Other::Traits&gt; &amp;&amp; ... )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ee661002deccc8f6242fe3fca873f99" name="a9ee661002deccc8f6242fe3fca873f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee661002deccc8f6242fe3fca873f99">&#9670;&#160;</a></span>IsCompatibleMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsCompatibleMatrix = ( ( std::is_same_v&lt;typename T::Traits, typename Other::Traits&gt; &amp;&amp; ( T::Size == Other::Size ) ) &amp;&amp; ... )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5279366f91fd5443f161eb3cf06e221a" name="a5279366f91fd5443f161eb3cf06e221a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5279366f91fd5443f161eb3cf06e221a">&#9670;&#160;</a></span>IsCompatiblePlane</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PlaneOrPlaneSimdType T, PlaneOrPlaneSimdType ... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsCompatiblePlane = ( std::is_same_v&lt;typename T::Traits, typename Other::Traits&gt; &amp;&amp; ... )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada36e8b3cd1f8901977574f25c1ec5f1" name="ada36e8b3cd1f8901977574f25c1ec5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada36e8b3cd1f8901977574f25c1ec5f1">&#9670;&#160;</a></span>IsCompatibleQuaternion</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;QuaternionOrQuaternionSimdType T, QuaternionOrQuaternionSimdType ... Other&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Harlinn::Math::IsCompatibleQuaternion = ( std::is_same_v&lt;typename T::Traits, typename Other::Traits&gt; &amp;&amp; ... )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_harlinn.html">Harlinn</a></li><li class="navelem"><a class="el" href="namespace_harlinn_1_1_math.html">Math</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>

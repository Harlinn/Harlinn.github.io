<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Harlinn.OCI | Harlinn</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Harlinn.OCI" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is my personal Github site," />
<meta property="og:description" content="This is my personal Github site," />
<link rel="canonical" href="https://harlinn.github.io/Cpp/Harlinn.Windows/Harlinn.OCI/Harlinn.OCI.html" />
<meta property="og:url" content="https://harlinn.github.io/Cpp/Harlinn.Windows/Harlinn.OCI/Harlinn.OCI.html" />
<meta property="og:site_name" content="Harlinn" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Harlinn.OCI" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"This is my personal Github site,","headline":"Harlinn.OCI","url":"https://harlinn.github.io/Cpp/Harlinn.Windows/Harlinn.OCI/Harlinn.OCI.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://harlinn.github.io/feed.xml" title="Harlinn" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Harlinn</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/Cpp/Cpp.html">C++</a><a class="page-link" href="/Dart/Dart.html">Dart</a><a class="page-link" href="/DotNet/DotNet.html">.Net</a><a class="page-link" href="/Cpp/Harlinn.Windows/Harlinn.Windows.html">Harlinn.Windows</a><a class="page-link" href="/Java/Java.html">Java</a><a class="page-link" href="/Julia/Julia.html">Julia</a><a class="page-link" href="/Python/Python.html">Python</a><a class="page-link" href="/R/R.html">R</a><a class="page-link" href="/Rust/Rust.html">Rust</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Harlinn.OCI</h1>
  </header>

  <div class="post-content">
    <h1 id="harlinnoci">Harlinn.OCI</h1>

<p>The primary advantage of using the Oracle Call Interface and C++ is performance. This advantage 
is not something we achieve just because we are using C++ and OCI, it is something we may 
achieve through a well-reasoned design. With the Harlinn.OCI library, I’ve tried to achieve two goals:</p>

<ol>
  <li>Ease of use.</li>
  <li>Fine-grained control of how data is exchanged with the Oracle RDBMS through the Oracle Call Interface. 
This can make a huge difference in the performance of your OCI client application.</li>
</ol>

<p>To use the Harlinn.OCI library, include the <code class="language-plaintext highlighter-rouge">HOCI.h</code> header file.</p>

<pre><code class="language-C++">#include &lt;HOCI.h&gt;
using namespace Harlinn::OCI;
</code></pre>

<h2 id="ease-of-use">Ease of Use</h2>

<p>Harlinn.OCI provides an API that’s easy to use:</p>

<pre><code class="language-C++">EnvironmentOptions options;
Environment environment( options );
auto server = environment.CreateServer( );
auto serviceContext = server.CreateServiceContext( Username, Password, Alias );

serviceContext.SessionBegin( );

WideString sql =
    L"SELECT * FROM ALL_USERS";

auto statement = serviceContext.CreateStatement( sql );
auto reader = statement.ExecuteReader&lt;DataReader&gt;( );

while ( reader-&gt;Read( ) )
{
    auto userName = reader-&gt;As&lt;WideString&gt;( 0 );
    auto userId = reader-&gt;As&lt;Int64&gt;( 1 );
    auto created = reader-&gt;As&lt;DateTime&gt;( 2 );
}

serviceContext.SessionEnd( );
</code></pre>

<p>Calling a server-side function:</p>

<pre><code class="language-C++">WideString sql =
    L"BEGIN"\
    L" :result := SYSTIMESTAMP();" \
    L"END;";
   
auto statement = serviceContext.CreateStatement( sql );
auto result = statement.Bind&lt;DateTime&gt;( 1 );

statement.Execute( 1 );

auto dateTime = result-&gt;As&lt;DateTime&gt;( );
</code></pre>

<p>or inserting a row:</p>

<pre><code class="language-C++">std::optional&lt;WideString&gt; description;
if ( ownedObjectType.Description( ).length( ) )
{
    description = ownedObjectType.Description( );
}

constexpr wchar_t SQL[] = L"INSERT INTO OwnedObjectType(Id, Name, OptimisticLock, "
    L"Created, Description) "\
    L"VALUES(:1,:2,0,:3,:4)";

static WideString sql( SQL );
auto statement = serviceContext_.CreateStatement( sql,
    ownedObjectType.Id( ),
    ownedObjectType.Name( ),
    ownedObjectType.Created( ),
    description );

statement.Execute( );

</code></pre>

<p>are all operations that can be easily implemented with the library. Harlinn.OCI implements 
a thin, yet feature rich, layer around the OCI C API. Harlinn.OCI depends on the 
<a href="../Harlinn.Common.Core/Harlinn.Common.Core.html">Harlinn.Common.Core library</a>, for implementations 
of basic datatypes such as <code class="language-plaintext highlighter-rouge">WideString</code>, <code class="language-plaintext highlighter-rouge">Guid</code>, <code class="language-plaintext highlighter-rouge">DateTime</code> and <code class="language-plaintext highlighter-rouge">TimeSpan</code>.</p>

<h2 id="create-retrieve-update-and-delete-crud">Create, Retrieve, Update and Delete (CRUD)</h2>

<p>Basic CRUD is the heart and soul of many applications, and this is a simple, yet typical, table:</p>

<pre><code class="language-SQL">CREATE TABLE SimpleTest1
(
  Id NUMBER(19) NOT NULL,
  OptimisticLock NUMBER(19) DEFAULT 0 NOT NULL,
  Name NVARCHAR2(128) NOT NULL,
  Description NVARCHAR2(1024),
  CONSTRAINT PK_SimpleTest1 PRIMARY KEY(Id),
  CONSTRAINT UNQ_SimpleTest1 UNIQUE(Name)
);
</code></pre>
<p>Description:</p>

<ol>
  <li>The <em>Id</em> column is the primary key for the table, mandating that a unique value must be stored for each row in the table.</li>
  <li>The <em>OptimisticLock</em> column is used to implement optimistic locking, a widely used technique for guarding against inadvertent overwrites by multiple concurrent users. If an application can do the following:
    <ol type="a">
     <li>User1 retrieves a row of data.</li> 
     <li>User2 retrieves the same row of data.</li> 
     <li>User2 updates column value and updates the row in the database.</li> 
     <li>User1 updates the same column value and updates the row in the database, overwriting the change made by User2.</li> 
 </ol>

    <p>then this is almost always a design bug.</p>
  </li>
  <li>The <em>Name</em> column provides an alternative key to the rows in the table.</li>
  <li>The <em>Description</em> column holds data that is of interest to the solution that uses the database to manage its data.</li>
</ol>

<p>A numeric primary key is often generated using an Oracle database sequence object:</p>

<pre><code class="language-SQL">CREATE SEQUENCE SimpleTest1Seq;
</code></pre>

<p>Which can be used to ensure that unique keys will be created for concurrent inserts by multiple database client applications.</p>

<h3 id="optimistic-locking">Optimistic Locking</h3>

<p>Nearly all software solutions that use a database server to store data must be able to handle 
multiple concurrent sessions. At any point in time, you can expect multiple processes or 
users to retrieve and update the database. Since multiple processes or users are updating the 
information in the database, it is only a matter of time before two separate processes or users 
will try to update the same piece of data concurrently.</p>

<p>Optimistic Locking is a minimalistic strategy for preventing unintentional updates to a row 
based on a version number stored in one of the columns of the row. When the software attempts 
to update or delete a row, it is filtered on the version number to make sure the row has not 
been updated between time the row was retrieved from the database, and the update or delete. 
Updates must ensure that changes to the column for the version number are atomic.</p>

<p>It is called optimistic locking because it assumes that most updates and deletes will 
succeed; and when they do not, the software must be able to handle this appropriately.</p>

<p>How to correctly handle situations where the optimistic lock prevents an update, or a delete, 
depends on the use-case. An interactive solution may retrieve the updated row from the database 
and let the user decide whether to overwrite it or abandon her modifications, while an automated 
system may implement a more complex solution, or store the rejected update elsewhere for manual 
intervention. The important thing is to maintain consistency while making sure that information 
is not inadvertently lost.</p>

<p>Optimistic locking is particularly useful for high-volume solutions; and web, and other 
multitier-tier architectures where the software is unable to maintain a dedicated connection 
to the database on behalf of the user. In these situations, the client cannot maintain database 
locks as the connections are taken from a pool and the client may not be using the same connection 
from one server request to the next.</p>

<p>The main downside of optimistic locking is that it is row oriented, and many real-world solutions 
requires synchronization that goes beyond a single row.</p>

<p>Even when you end up using a more powerful lock management solution, optimistic locking will 
almost certainly help to uncover programming errors during development, deployment, and operation.</p>

<p>The alternative to optimistic locking in called pessimistic locking, it is not last write wins. 
Pessimistic locking requires an active system component that maintains the locks, such as table 
or row level locking implemented by the database server, or a dedicated distributed lock server. 
Database locks are usually tied to the database session but can also be under control of a 
distributed transaction manager.</p>

<p>The Oracle database provides the DBMS_LOCK package, which can be used to implement pessimistic 
locking. The maximum lifetime of a lock is limited to the lifetime of the session used to create it.</p>

<h3 id="basic-crud-using-harlinnoci">Basic CRUD using Harlinn.OCI</h3>

<p>Implementing basic CRUD using Harlinn.OCI is also a straightforward process, and the code again 
illustrates how to properly implement optimistic locking using atomic operations in plain DML.</p>

<h4 id="create">Create</h4>

<p>To insert a new record into the database, we must perform the following steps:</p>

<ul>
  <li>
    <p>Create an <code class="language-plaintext highlighter-rouge">OCI::Statement</code> object by calling <code class="language-plaintext highlighter-rouge">CreateStatement(...)</code> on the service 
context. The first argument is the <code class="language-plaintext highlighter-rouge">INSERT</code> <a href="https://en.wikipedia.org/wiki/Data_manipulation_language">data manipulation language</a> (DML) 
statement with variable placeholders for the <em>Name</em>, <em>Description</em> and finally the server generated 
value for the <em>Id</em> column. The second and third parameters are automatically bound to the two first variable placeholders.</p>
  </li>
  <li>
    <p>Bind the third variable placeholder to a 64-bit integer, that will receive the server generated primary key, using an <code class="language-plaintext highlighter-rouge">Int64Bind</code> object.</p>
  </li>
  <li>
    <p>Call the <code class="language-plaintext highlighter-rouge">ExecuteNonQuery()</code> member function of the <code class="language-plaintext highlighter-rouge">OCI::Statement</code> object to execute the DML statement on the database server.</p>
  </li>
</ul>

<p>The two first placeholders <code class="language-plaintext highlighter-rouge">:1</code> and <code class="language-plaintext highlighter-rouge">:2</code> are created for the <em>Name</em> and <em>Description</em> column, respectively; while the third 
placeholder is for the value of the <em>Id</em> column that will be generated by the call to <code class="language-plaintext highlighter-rouge">SimpleTest1Seq.NextVal</code> inside the DML 
as specified by the trailing <code class="language-plaintext highlighter-rouge">RETURNING Id INTO :3</code>. The <em>OptimisticLock</em> column gets assigned 0 marking this as the initial 
version of the row:</p>

<pre><code class="language-C++">std::unique_ptr&lt;SimpleTestData&gt; Insert( const WideString&amp; name,
                    const WideString&amp; description = WideString( ) ) const
{
    auto&amp; serviceContext = ServiceContext( );
    std::optional&lt;WideString&gt; descr;
    if ( description.size( ) )
    {
        descr = description;
    }

    constexpr wchar_t sql[] =
        L"INSERT INTO SimpleTest1(Id, OptimisticLock, Name, Description ) "
        L"VALUES(SimpleTest1Seq.NextVal,0,:1,:2) RETURNING Id INTO :3";

    auto statement = serviceContext.CreateStatement( sql, name, descr );
    auto* idBind = statement.Bind&lt;Int64&gt;( 3 );
    auto transaction = serviceContext.BeginTransaction( );
    statement.ExecuteNonQuery( );
    transaction.Commit( );
    auto id = idBind-&gt;AsInt64( );
    return std::make_unique&lt;SimpleTestData&gt;( id, 0, name, description );
}
</code></pre>

<h4 id="retrieve">Retrieve</h4>

<p>The steps for preparing an <code class="language-plaintext highlighter-rouge">OCI::Statement</code> object for retrieving the data for a particular 
row are nearly identical to those used to insert a new record, except that this time, we 
must pass the <a href="https://en.wikipedia.org/wiki/SQL">structured query language</a> (SQL) statement 
with a single variable placeholder as the first parameter to the <code class="language-plaintext highlighter-rouge">CreateStatement(...)</code> 
function, and the value to assign to this placeholder as the second argument.</p>

<p>Call <code class="language-plaintext highlighter-rouge">ExecuteReader</code> on the <code class="language-plaintext highlighter-rouge">OCI::Statement</code> object to execute the query on the database 
server. <code class="language-plaintext highlighter-rouge">ExecuteReader</code> returns an <code class="language-plaintext highlighter-rouge">OCI::DataReader</code> that provides access to the query results.</p>

<p>Since we already know the value of the <em>Id</em> column, we only ask for the <em>OptimisticLock</em>, 
<em>Name</em> and <em>Description</em> columns. The value of the <em>Id</em> column is guaranteed to uniquely 
identify a single row in the SimpleTest1 table, so we only execute <code class="language-plaintext highlighter-rouge">reader-&gt;Read()</code> 
once, and if it returns <code class="language-plaintext highlighter-rouge">true</code>, we know that the query was able to locate the requested 
row. The <em>OptimisticLock</em> and <em>Name</em> columns cannot be NULL, while the <em>Description</em> column 
can - which we check by calling <code class="language-plaintext highlighter-rouge">IsDBNull</code>. Each column for the current row is identified 
by its 0 based offset into the select-list:</p>

<pre><code class="language-C++">std::unique_ptr&lt;SimpleTestData&gt; Select( Int64 id ) const
{
    auto&amp; serviceContext = ServiceContext( );
    constexpr wchar_t sql[] = 
        L"SELECT OptimisticLock, Name, Description FROM SimpleTest1 "
        L"WHERE Id = :1";

    auto statement = serviceContext.CreateStatement( sql, id );
    auto reader = statement.ExecuteReader( );
    if ( reader-&gt;Read( ) )
    {
        auto optimisticLock = reader-&gt;GetInt64( 0 );
        auto name = reader-&gt;GetString( 1 );
        WideString description;
        if ( reader-&gt;IsDBNull( 2 ) == false )
        {
            description = reader-&gt;GetString( 2 );
        }
        return std::make_unique&lt;SimpleTestData&gt;( id, optimisticLock, 
            name, description );
    }
    else
    {
        return nullptr;
    }
}

</code></pre>

<h4 id="update">Update</h4>

<p>Again, we use an <code class="language-plaintext highlighter-rouge">OCI::Statement</code> object, passing an <code class="language-plaintext highlighter-rouge">UPDATE</code> DML statement as the first parameter to the 
<code class="language-plaintext highlighter-rouge">CreateStatement(...)</code> function. This time, the variable placeholders are only for input variables and 
the variables holding the values are passed as the additional arguments.</p>

<p>The row is not updated unless the <em>Id</em> column matches the value bound to the third variable placeholder 
and the <em>OptimisticLock</em> column matches the value bound to the fourth variable placeholder. This will 
prevent the DML from updating the row if it has been updated by another user or process; and as a 
side effect, we also know that the next value for the <em>OptimisticLock</em> column, after a successful update, 
will be the previous value incremented by 1.</p>

<p>The DML statement can at most update a single row in the <code class="language-plaintext highlighter-rouge">SimpleTest1</code> table and since <code class="language-plaintext highlighter-rouge">ExecuteNonQuery()</code> 
returns the number of rows that was altered by the DML statement, we can safely assume that a return 
value greater than <code class="language-plaintext highlighter-rouge">0</code> means that the update succeeded, while <code class="language-plaintext highlighter-rouge">0</code> means that either the row is deleted or 
the value for the <em>OptimisticLock</em> column has been changed by another update:</p>

<pre><code class="language-C++">bool Update( SimpleTestData&amp; data )
{
    auto id = data.Id();
    auto optimisticLock = data.OptimisticLock();
    auto&amp; name = data.Name();
    auto&amp; description = data.Description();

    auto&amp; serviceContext = ServiceContext( );
    std::optional&lt;WideString&gt; descr;
    if ( description.size( ) )
    {
        descr = description;
    }
    constexpr wchar_t sql[] = L"UPDATE SimpleTest1 " 
        L"SET OptimisticLock=OptimisticLock+1, Name=:1, Description=:2 " 
        L"WHERE Id=:3 AND OptimisticLock=:4";

    auto statement = serviceContext.CreateStatement( sql, name, descr, 
                                    id, optimisticLock );
    if ( statement.ExecuteNonQuery( ) &gt; 0 )
    {
        data.SetOptimisticLock( optimisticLock + 1 );
        return true;
    }
    else
    {
        return false;
    }
}
</code></pre>

<h4 id="delete">Delete</h4>

<p>The logic behind the DELETE DML statement is nearly identical to the logic for updating a row:</p>

<pre><code class="language-C++">bool Delete( const SimpleTestData&amp; data )
{
    auto id = data.Id( );
    auto optimisticLock = data.OptimisticLock( );
    auto&amp; serviceContext = ServiceContext( );

    constexpr wchar_t sql[] = L"DELETE FROM SimpleTest1 "
        L"WHERE Id=:1 AND OptimisticLock=:2";

    auto statement = serviceContext.CreateStatement( sql, id, optimisticLock );
    if ( statement.ExecuteNonQuery( ) &gt; 0 )
    {
        return true;
    }
    else
    {
        return false;
    }
}
</code></pre>

<h2 id="oci-program-initialization">OCI Program Initialization</h2>

<p>Just about every operation that can be done using OCI is performed through handles to OCI 
resources. Each application that uses OCI must create a handle to an OCI environment, defining 
a context for executing OCI functions. The environment handle establishes a memory cache for 
fast memory access, and all memory used by the environment comes from this cache.</p>

<h3 id="environment">Environment</h3>

<p>The <code class="language-plaintext highlighter-rouge">Environment</code> class provides access to the functionality of the OCI environment handle.</p>

<p>OCI applications use an error handle as a conduit for error information between the client 
application and the API, and the <code class="language-plaintext highlighter-rouge">ErrorHandle</code> class provides access to the functionality 
for this handle type.</p>

<p>Creating an <code class="language-plaintext highlighter-rouge">Environment</code> is the first step performed when creating and application using 
the Harlinn.OCI library:</p>

<pre><code class="language-C++">EnvironmentOptions options;
Environment environment( options );
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">Environment</code> constructor calls <code class="language-plaintext highlighter-rouge">CreateEnvironment( )</code> which creates the handle for the object.</p>

<pre><code class="language-C++">void* Environment::CreateEnvironment( )
{
    void* handle = nullptr;
    auto rc = OCIEnvCreate( (OCIEnv**)&amp;handle,
        (UInt32)DefaultEnvironmentMode( ),
        nullptr, nullptr, nullptr, nullptr, (size_t)0, (dvoid**)0 );

    if ( rc &lt; OCI::Result::Success )
    {
        ThrowOracleExceptionOnError( handle, rc );
    }
    return handle;
}
</code></pre>
<h3 id="errorhandle">ErrorHandle</h3>

<p>Once the <code class="language-plaintext highlighter-rouge">Environment</code> object has a valid handle, it creates an <code class="language-plaintext highlighter-rouge">ErrorHandle</code> object that is used 
for all error handling, except for calls to <code class="language-plaintext highlighter-rouge">OCIHandleAlloc</code>, related to this Environment object.</p>

<pre><code class="language-C++">OCI::ErrorHandle Environment::CreateError( ) const
{
    void* errorHandle = nullptr;

    auto rc = OCIHandleAlloc( (dvoid*)Handle( ),
        (dvoid**)&amp;errorHandle,
        OCI_HTYPE_ERROR, 0, (dvoid**)0 );

    if ( rc &lt; OCI_SUCCESS )
    {
        ThrowOracleExceptionOnError( Handle( ), rc );
    }
    return OCI::ErrorHandle( *this, errorHandle, true );
}
</code></pre>

<h3 id="servicecontext-server-and-session">ServiceContext, Server and Session</h3>

<p>Next, we need to establish a handle to the service context that is required for most operational calls through OCI.</p>

<p>The service context handle contains three handles, representing the server connection, the user session, and the transaction:</p>

<p><img src="assets/ociservicecontext.png" alt="ServiceContext, Server, Session and transaction handles." width="400" /></p>

<ul>
  <li>The server handle represents a physical connection in a connection-oriented transport mechanism between the 
client and the database server.</li>
  <li>The user session defines the roles and privileges of the user.</li>
  <li>The transaction handle represents the transaction context used to perform operations against the server. 
This includes user session state information, including fetch state and package instantiation.</li>
</ul>

<p>To establish a service context handle that can be used to execute SQL statement against an Oracle database, we need 
to perform a number of steps:</p>

<ol>
  <li>Allocate a sever handle using <code class="language-plaintext highlighter-rouge">OCIHandleAlloc</code>.</li>
  <li>Initialize the server handle using <code class="language-plaintext highlighter-rouge">OCIServerAttach</code>.</li>
  <li>Allocate the service context handle using <code class="language-plaintext highlighter-rouge">OCIHandleAlloc</code>.</li>
  <li>Assign the server handle to the service context handle using <code class="language-plaintext highlighter-rouge">OCIAttrSet</code>.</li>
  <li>Allocate the user session handle using <code class="language-plaintext highlighter-rouge">OCIHandleAlloc</code>.</li>
  <li>Assign the user session handle to the service context using <code class="language-plaintext highlighter-rouge">OCIAttrSet</code>.</li>
  <li>Assign the user name to the user session using <code class="language-plaintext highlighter-rouge">OCIAttrSet</code>.</li>
  <li>Assign the password to the user session using <code class="language-plaintext highlighter-rouge">OCIAttrSet</code>.</li>
  <li>Initialize the service context using <code class="language-plaintext highlighter-rouge">OCISessionBegin</code>.</li>
</ol>

<p>Harlinn.OCI simplifies this to:</p>

<pre><code class="language-C++">auto server = environment.CreateServer( );
auto serviceContext = server.CreateServiceContext( Username, Password, Alias );
serviceContext.SessionBegin( );
</code></pre>
<p>But also allows each step to be performed separately:</p>

<pre><code class="language-C++">auto server = environment.CreateServer( );
server.Attach( Alias );
auto serviceContext = environment.CreateServiceContext( );
serviceContext.SetServer( server );
auto session = environment.CreateSession( );
serviceContext.SetSession( std::move( session ) );
session.SetUserName( Username );
session.SetPassword( Password );
serviceContext.SessionBegin( );
</code></pre>

<p>This is useful when you need better control of how you want to configure the options for the various handle types provided by OCI.</p>

<h2 id="executing-sql-against-the-oracle-database">Executing SQL against the Oracle Database</h2>

<p>Now, that we have established a valid service context, we are ready to execute SQL statements against the 
Oracle database. To execute a SQL statement using OCI, the client application performs the following steps:</p>

<ol>
  <li>Allocate a statement handle for the SQL statement using <code class="language-plaintext highlighter-rouge">OCIStmtPrepare2</code>().</li>
  <li>For statements with input, or output, variables, each placeholder in the 
statement must be bound to an address in the client application using <code class="language-plaintext highlighter-rouge">OCIBindByPos2</code>(), 
<code class="language-plaintext highlighter-rouge">OCIBindByName2()</code>, <code class="language-plaintext highlighter-rouge">OCIBindObject()</code>, <code class="language-plaintext highlighter-rouge">OCIBindDynamic()</code> or <code class="language-plaintext highlighter-rouge">OCIBindArrayOfStruct()</code>.</li>
  <li>Execute the statement by calling <code class="language-plaintext highlighter-rouge">OCIStmtExecute()</code>.</li>
</ol>

<p>The remaining steps are only required for SQL queries:</p>

<ol>
  <li>Describe the select-list items using <code class="language-plaintext highlighter-rouge">OCIParamGet()</code> and <code class="language-plaintext highlighter-rouge">OCIAttrGet()</code>. This step is not required 
if the elements of the select list are known at compile-time.</li>
  <li>Define output variables using <code class="language-plaintext highlighter-rouge">OCIDefineByPos2()</code> or <code class="language-plaintext highlighter-rouge">OCIDefineByPos()</code>, <code class="language-plaintext highlighter-rouge">OCIDefineObject()</code>, 
<code class="language-plaintext highlighter-rouge">OCIDefineDynamic()</code>, or <code class="language-plaintext highlighter-rouge">OCIDefineArrayOfStruct()</code> for each item in the select list.</li>
  <li>Fetch the results of the query using <code class="language-plaintext highlighter-rouge">OCIStmtFetch2()</code>.</li>
</ol>

<p>The code below shows the easiest way to execute an SQL query with bound input variables:</p>

<pre><code class="language-C++">WideString sql =
    L"SELECT * FROM ALL_USERS WHERE USERNAME&lt;&gt;:1";

WideString myName( L"ESPEN" );
auto statement = serviceContext.CreateStatement( sql, myName );
auto reader = statement.ExecuteReader( );
while ( reader-&gt;Read( ) )
{
    auto userName = reader-&gt;As&lt;WideString&gt;( 0 );
    auto userId = reader-&gt;As&lt;Int64&gt;( 1 );
    auto created = reader-&gt;As&lt;DateTime&gt;( 2 );
}
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">CreateStatement(...)</code> function binds all but the first argument automatically, and is able to perform 
this for the following C++ types:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bool</code> and <code class="language-plaintext highlighter-rouge">std::optional&lt;bool&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">SByte</code> (signed char) and <code class="language-plaintext highlighter-rouge">std::optional&lt;SByte&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">Byte</code> (unsigned char) and <code class="language-plaintext highlighter-rouge">std::optional&lt;Byte&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">Int16</code> (short) and <code class="language-plaintext highlighter-rouge">std::optional&lt;Int16&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">UInt16</code> (unsigned short) and <code class="language-plaintext highlighter-rouge">std::optional&lt;UInt16&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">Int32</code> (int) and <code class="language-plaintext highlighter-rouge">std::optional&lt;Int32&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">UInt32</code> (unsigned int) and <code class="language-plaintext highlighter-rouge">std::optional&lt;UInt32&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">Int64</code> (long long) and <code class="language-plaintext highlighter-rouge">std::optional&lt;Int64&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">UInt64</code> (unsigned long long) and <code class="language-plaintext highlighter-rouge">std::optional&lt;UInt64&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">Single</code> (float) and <code class="language-plaintext highlighter-rouge">std::optional&lt;Single&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">Double</code> (double) and <code class="language-plaintext highlighter-rouge">std::optional&lt;Double&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">DateTime</code> and <code class="language-plaintext highlighter-rouge">std::optional&lt;DateTime&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">Guid</code> and <code class="language-plaintext highlighter-rouge">std::optional&lt;Guid&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">WideString</code> and <code class="language-plaintext highlighter-rouge">std::optional&lt;WideString&gt;</code></li>
</ul>

<p>If the argument is passed as one of the supported <code class="language-plaintext highlighter-rouge">std::optional&lt;&gt;</code> types, then <code class="language-plaintext highlighter-rouge">std::optional&lt;&gt;::has_value()</code> 
is used to control the NULL indicator for the bind.</p>

<p>This way of binding variables is intended for input variables only. The <code class="language-plaintext highlighter-rouge">CreateStatement</code> function is implemented 
as a variadic template function, which is why it is able to bind the arguments based on their type:</p>

<pre><code class="language-C++">template&lt;WideStringLike StringT, typename ...BindableTypes&gt;
    requires ( sizeof...( BindableTypes ) &gt; 0 )
inline OCI::Statement ServiceContext::CreateStatement( const StringT&amp; sql,
    BindableTypes&amp;&amp; ...bindableArgs ) const
{
    auto result = CreateStatement( sql );
    Internal::BindArgs( result, 1, 
        std::forward&lt;BindableTypes&gt;( bindableArgs )... );
    return result;
}
</code></pre>
<p>Where <code class="language-plaintext highlighter-rouge">CreateStatement( sql )</code>just calls:</p>

<pre><code class="language-C++">template&lt;WideStringLike StringT&gt;
OCI::Statement CreateStatement( const StringT&amp; sql ) const
{
    return CreateStatement( sql.c_str(), sql.size() );
}
</code></pre>
<p>Calling the real <code class="language-plaintext highlighter-rouge">CreateStatement</code> implementation which creates the statement handle using <code class="language-plaintext highlighter-rouge">OCIStmtPrepare2</code> and 
checks for errors:</p>

<pre><code class="language-C++">OCI::Statement ServiceContext::CreateStatement( const wchar_t* sql, size_t sqlLength ) const
{
    auto&amp; environment = Environment( );
    if ( environment.IsValid( ) )
    {
        OCIStmt* ociStatement = nullptr;
        auto&amp; error = Error( );
        auto errorHandle = (OCIError*)error.Handle( );
        auto rc = OCIStmtPrepare2( (OCISvcCtx*)Handle( ), &amp;ociStatement, errorHandle, 
            (OraText*)sql, static_cast&lt;UInt32&gt;( sqlLength * sizeof( wchar_t ) ),
            nullptr, 0, OCI_NTV_SYNTAX, OCI_DEFAULT );
        error.CheckResult( rc );
        return Statement( *this, ociStatement, true );
    }
    else
    {
        ThrowInvalidEnvironment( );
    }
}
</code></pre>
<p>While the internal implementation of <code class="language-plaintext highlighter-rouge">BindArgs</code> processes each of the variadic template arguments:</p>

<pre><code class="language-C++">template&lt;typename Arg, typename ...OtherArgsTypes&gt;
void BindArgs( OCI::Statement&amp; statement, UInt32 position, 
    const Arg&amp; arg, OtherArgsTypes&amp;&amp; ...otherArgsTypes )
{
    if constexpr ( IsAnyOf_v&lt;Arg, WideString, std::wstring&gt; )
    {
        auto newBind = statement.Bind&lt;Arg&gt;( position, arg.length( ) );
        newBind-&gt;Assign( arg );
    }
    else if constexpr ( IsSpecializationOf&lt;Arg, std::optional&gt; )
    {
        using BintT = typename Arg::value_type;
        if ( arg.has_value( ) )
        {
            if constexpr ( IsAnyOf_v&lt; BintT, WideString, std::wstring&gt; )
            {
                auto newBind = statement.Bind&lt;BintT&gt;( position, arg.value( ).length( ) );
                newBind-&gt;Assign( arg.value() );
            }
            else
            {
                auto newBind = statement.Bind&lt;BintT&gt;( position );
                newBind-&gt;Assign( arg.value( ) );
            }
        }
        else
        {
            if constexpr ( IsAnyOf_v&lt;BintT, WideString, std::wstring&gt; )
            {
                auto newBind = statement.Bind&lt;BintT&gt;( position, static_cast&lt;size_t&gt;(0) );
                newBind-&gt;SetDBNull( );
            }
            else
            {
                auto newBind = statement.Bind&lt;BintT&gt;( position );
                newBind-&gt;SetDBNull( );
            }
        }
    }
    else
    {
        auto newBind = statement.Bind&lt;Arg&gt;( position );
        newBind-&gt;Assign( arg );
    }
    if constexpr ( sizeof...( otherArgsTypes ) &gt; 0 )
    {
        BindArgs( statement, position + 1, std::forward&lt;OtherArgsTypes&gt;( otherArgsTypes )... );
    }
}
</code></pre>

<p>This shows how C++ can perform complex compile-time logic while ensuring that the code can still 
be debugged, where <code class="language-plaintext highlighter-rouge">if constexpr</code> is used to control the code generation. Before C++ 17, debugging 
code involving compile-time logic could be rather confusing.</p>

<p>The <code class="language-plaintext highlighter-rouge">ExecuteReader</code> function is where all the magic happens, and so far <code class="language-plaintext highlighter-rouge">OCIStmtPrepare2</code> is the only 
OCI function that has been called.</p>

<pre><code class="language-C++">auto reader = statement.ExecuteReader( );
</code></pre>

<p>ExecuteReader performs three interesting operations:</p>

<ol>
  <li>Creates the DataReader object, or an object of a type derived from DataReader</li>
  <li>Calls the InitializeDefines() function on the newly created object</li>
  <li>Executes the SQL statement</li>
</ol>

<pre><code class="language-C++">template&lt;typename DataReaderType&gt;
    requires std::is_base_of_v&lt;OCI::DataReader, DataReaderType&gt;
inline std::unique_ptr&lt;DataReaderType&gt; Statement::ExecuteReader( StatementExecuteMode executeMode )
{
    auto result = std::make_unique&lt;DataReaderType&gt;( *this );
    result-&gt;InitializeDefines( );
    auto rc = Execute( 1, executeMode );
    result-&gt;Prefetch( rc );
    return result;
}
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">DataReader</code> provides a default implementation of <code class="language-plaintext highlighter-rouge">InitializeDefines()</code> which performs an explicit 
describe to determine the fields of the select-list and create appropriate defines using <code class="language-plaintext highlighter-rouge">OCIDefineByPos2</code>.</p>

<p>Another option is to create a class derived from DataReader:</p>

<pre><code class="language-C++">class AllUsersReader : public DataReader
{
public:
    using Base = DataReader;
    constexpr static UInt32 USERNAME = 0;
    constexpr static UInt32 USER_ID = 1;
    constexpr static UInt32 CREATED = 2;
    constexpr static UInt32 COMMON = 3;
    constexpr static UInt32 ORACLE_MAINTAINED = 4;
    constexpr static UInt32 INHERITED = 5;
    constexpr static UInt32 DEFAULT_COLLATION = 6;
    constexpr static UInt32 IMPLICIT = 7;
    constexpr static UInt32 ALL_SHARD = 8;

    constexpr static wchar_t SQL[] = L"SELECT USERNAME, "
        L"USER_ID, CREATED, COMMON, ORACLE_MAINTAINED, "
        L"INHERITED, DEFAULT_COLLATION, IMPLICIT, ALL_SHARD "
        L"FROM ALL_USERS";
    ...
};

</code></pre>

<p>Each field gets its own id, which is the offset in the select-list. Since we know the types for the defines, 
we can create member variables for each field:</p>

<pre><code class="language-C++">private:
    CStringDefine* userName_ = nullptr;
    Int64Define* userId_ = nullptr;
    DateDefine* created_ = nullptr;
    CStringDefine* common_ = nullptr;
    CStringDefine* oracleMaintained_ = nullptr;
    CStringDefine* inherited_ = nullptr;
    CStringDefine* defaultCollation_ = nullptr;
    CStringDefine* implicit_ = nullptr;
    CStringDefine* allShard_ = nullptr;
public:
</code></pre>
<p>and then override the InitializeDefines( ) function:</p>

<pre><code class="language-C++">virtual void InitializeDefines( ) override
{
    userName_ = Define&lt;CStringDefine&gt;( USERNAME + 1, 128 );
    userId_ = Define&lt;Int64Define&gt;( USER_ID + 1 );
    created_ = Define&lt;DateDefine&gt;( CREATED + 1 );
    common_ = Define&lt;CStringDefine&gt;( COMMON + 1, 3 );
    oracleMaintained_ = Define&lt;CStringDefine&gt;( ORACLE_MAINTAINED + 1, 1 );
    inherited_ = Define&lt;CStringDefine&gt;( INHERITED + 1, 3 );
    defaultCollation_ = Define&lt;CStringDefine&gt;( DEFAULT_COLLATION + 1, 100 );
    implicit_ = Define&lt;CStringDefine&gt;( IMPLICIT + 1, 3 );
    allShard_ = Define&lt;CStringDefine&gt;( ALL_SHARD + 1, 3 );
}

</code></pre>

<p>This removes the need to perform any describe on the select-list and provides direct access to the 
objects that receives the data fetched from the database through OCI. We can easily implement function 
to access the data:</p>

<pre><code class="language-C++">std::wstring UserName( ) const
{
    return userName_-&gt;AsString( );
}
Int64 UserId( ) const
{
    return userId_-&gt;AsInt64( );
}
DateTime Created( ) const
{
    return created_-&gt;AsDateTime( );
}

</code></pre>

<p>And now, we can query the <code class="language-plaintext highlighter-rouge">ALL_USERS</code> view like this:</p>
<pre><code class="language-C++">auto statement = serviceContext.CreateStatement( AllUsersReader::SQL );
auto reader = statement.ExecuteReader&lt;AllUsersReader&gt;( );
while ( reader-&gt;Read( ) )
{
    auto userName = reader-&gt;UserName( );
    auto userId = reader-&gt;UserId( );
    auto created = reader-&gt;Created( );
}
</code></pre>

<p>While quite a bit more work, this executes more efficiently - and perhaps even more 
importantly: It isolates the internal implementation details of the query from the rest of the code.</p>

<p>There are also many situations where you know that it is more efficient to use a 64-bit integer than an 
Oracle <code class="language-plaintext highlighter-rouge">Number</code>, or that <code class="language-plaintext highlighter-rouge">OCI::Date</code> is more appropriate than a Timestamp, or a long var binary (LVB) in 
place of a BLOB. There are many real-world cases where the ability to control how data is exchanged with 
Oracle is crucial to the performance of the solution.</p>

<h3 id="improving-query-performance">Improving Query Performance</h3>

<p>The article started out with a promise of high performance, and performance is a relative thing, so a 
base case is needed. Here are the tables that will be used for the test cases:</p>

<pre><code class="language-SQL">CREATE TABLE TimeseriesValue1
(
Id NUMBER(19) NOT NULL,
Ts TIMESTAMP(9) NOT NULL,
Flags NUMBER(19) NOT NULL,
Val BINARY_DOUBLE NOT NULL,
CONSTRAINT PK_TSV1 PRIMARY KEY(Id,Ts)
) ORGANIZATION INDEX;

CREATE TABLE TimeseriesValue2
(
Id NUMBER(19) NOT NULL,
Ts NUMBER(19) NOT NULL,
Flags NUMBER(19) NOT NULL,
Val BINARY_DOUBLE NOT NULL,
CONSTRAINT PK_TSV2 PRIMARY KEY(Id,Ts)
) ORGANIZATION INDEX;

</code></pre>
<p>They are nearly identical, except that the type of the <code class="language-plaintext highlighter-rouge">Ts</code> column is a <code class="language-plaintext highlighter-rouge">TIMESTAMP(9)</code> for <code class="language-plaintext highlighter-rouge">TimeseriesValue1</code> 
and a <code class="language-plaintext highlighter-rouge">NUMBER(19)</code> for <code class="language-plaintext highlighter-rouge">TimeseriesValue2</code>. <code class="language-plaintext highlighter-rouge">NUMBER(19)</code> is large enough to hold any value that can be held by 
a 64-bit integer.</p>


  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Harlinn</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Harlinn</li><li><a class="u-email" href="mailto:espen@harlinn.no">espen@harlinn.no</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Harlinn"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Harlinn</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is my personal Github site, </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Fast Linear Algebra Classes for Games and Graphics | Harlinn</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Fast Linear Algebra Classes for Games and Graphics" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is my personal site." />
<meta property="og:description" content="This is my personal site." />
<link rel="canonical" href="https://harlinn.github.io/Cpp/Cpp/Math/FastLinearAlgebra.html" />
<meta property="og:url" content="https://harlinn.github.io/Cpp/Cpp/Math/FastLinearAlgebra.html" />
<meta property="og:site_name" content="Harlinn" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Fast Linear Algebra Classes for Games and Graphics" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"This is my personal site.","headline":"Fast Linear Algebra Classes for Games and Graphics","url":"https://harlinn.github.io/Cpp/Cpp/Math/FastLinearAlgebra.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://harlinn.github.io/feed.xml" title="Harlinn" /><script type="text/javascript" id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="importmap">
        {
            "imports":
            {
            "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.min.js" ,
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
            }
        }
    </script>
</head>
<body><header class="site-header" role="banner">
    <div id="animatedHeader" height="120px" width="100%">
        <script type="x-shader/x-vertex" id="vertexshader">
            attribute float scale;
            void main() {
                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                gl_PointSize = scale * ( 100.0 / - mvPosition.z );
                gl_Position = projectionMatrix * mvPosition;
            }

        </script>

        <script type="x-shader/x-fragment" id="fragmentshader">
            uniform vec3 color;
            void main() {
                if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 )  discard;
                gl_FragColor = vec4( color, 0.8 );
            }
        </script>

        <script type="module">

			import * as THREE from 'three';

			const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;

			let container; 
			let camera, scene, renderer;

			let particles, count = 0;

			let mouseX = 0, mouseY = 0;

			let animatedHeaderHeight = 120;

            let windowHalfX = window.innerWidth / 2;
            let windowHalfY = animatedHeaderHeight/2.0;

			init();

			function init() {

                container = document.querySelector('#animatedHeader');

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;

				scene = new THREE.Scene();

				//

				const numParticles = AMOUNTX * AMOUNTY;

				const positions = new Float32Array( numParticles * 3 );
				const scales = new Float32Array( numParticles );

				let i = 0, j = 0;

				for ( let ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( let iy = 0; iy < AMOUNTY; iy ++ ) {

						positions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x
						positions[ i + 1 ] = 0; // y
						positions[ i + 2 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z

						scales[ j ] = 1;

						i += 3;
						j ++;

					}

				}

				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) );

				const material = new THREE.ShaderMaterial( {

					uniforms: {
						color: { value: new THREE.Color( 0xffffff ) },
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent

				} );

				//

				particles = new THREE.Points( geometry, material );
				scene.add( particles );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize(window.innerWidth, animatedHeaderHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				container.style.touchAction = 'none';
				container.addEventListener( 'pointermove', onPointerMove );

				//

                window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;

				camera.aspect = window.innerWidth / animatedHeaderHeight; 
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, animatedHeaderHeight);

			}

			//

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			//

			function animate() {
				render();

			}

			function render() {

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );

				const positions = particles.geometry.attributes.position.array;
				const scales = particles.geometry.attributes.scale.array;

				let i = 0, j = 0;

				for ( let ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( let iy = 0; iy < AMOUNTY; iy ++ ) {

						positions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.3 ) * 50 ) +
										( Math.sin( ( iy + count ) * 0.5 ) * 50 );

						scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 20 +
										( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 20;

						i += 3;
						j ++;

					}

				}

				particles.geometry.attributes.position.needsUpdate = true;
				particles.geometry.attributes.scale.needsUpdate = true;

				renderer.render( scene, camera );

				count += 0.1;

			}

        </script>

    </div>
  <div class="wrapper"><a class="site-title" rel="author" href="/">Harlinn</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/Cpp/Cpp.html">C++</a><a class="page-link" href="/Databases/Databases.html">Databases</a><a class="page-link" href="/DotNet/DotNet.html">.Net</a><a class="page-link" href="/Java/Java.html">Java</a><a class="page-link" href="/Julia/Julia.html">Julia</a><a class="page-link" href="/Python/Python.html">Python</a><a class="page-link" href="/R/R.html">R</a><a class="page-link" href="/Rust/Rust.html">Rust</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Fast Linear Algebra Classes for Games and Graphics</h1>
  </header>

  <div class="post-content">
    <p>The Harlinn.Math library contains a set of optimized linear algebra classes and functions
for games and other graphic intensive apps. The operations are 
implemented using a blend of SIMD and regular C/C++, performing as well as, and sometimes 
outperforming, the <a href="https://github.com/microsoft/DirectXMath">DirectXMath</a>
library.</p>

<p>This is a raytraced image generated by <a href="pbrto.html">pbrto</a>.</p>

<p><img src="./assets/Kroken1.png" alt="kroken" /></p>

<p><a href="pbrto.html">pbrto</a> is the main example/demonstration of how to use the library
to improve the performance of a complex, computationally intensive, app.</p>

<p>The classes and functions are designed to make it easier to implement, understand and 
maintain efficient solutions, and the <a href="Benchmarks.html">Benchmarks</a> shows that this can be done
without loss of performance.</p>

<p><code class="language-plaintext highlighter-rouge">Harlinn/Math/VectorMath.h</code> is header only.</p>

<p>This document and related pages are under construction.</p>

<h3 id="concepts">Concepts</h3>

<ul>
  <li><a href="FastLinearAlgebra/Concepts.html">Concepts</a></li>
</ul>

<h3 id="classes-and-templates">Classes and Templates</h3>

<ul>
  <li><a href="FastLinearAlgebra/ClassesAndTemplates.html">Classes and Templates</a></li>
</ul>

<h3 id="functions">Functions</h3>

<ul>
  <li><a href="FastLinearAlgebra/BasicOperations.html">Basic operations</a></li>
  <li><a href="FastLinearAlgebra/ExponentialFunctions.html">Exponential functions</a></li>
  <li><a href="FastLinearAlgebra/PowerFunctions.html">Power functions</a></li>
  <li><a href="FastLinearAlgebra/TrigonometricFunctions.html">Trigonometric functions</a></li>
  <li><a href="FastLinearAlgebra/HyperbolicFunctions.html">Hyperbolic functions</a></li>
  <li><a href="FastLinearAlgebra/ErrorAndGammaFunctions.html">Error and gamma functions</a></li>
  <li><a href="FastLinearAlgebra/NearestIntegerFloatingPointOperations.html">Nearest integer floating point operations</a></li>
  <li><a href="FastLinearAlgebra/FloatingPointManipulationFunctions.html">Floating point manipulation functions</a></li>
  <li><a href="FastLinearAlgebra/ClassificationAndComparison.html">Classification and comparison</a></li>
  <li><a href="FastLinearAlgebra/OtherFunctions.html">Other functions</a></li>
  <li><a href="FastLinearAlgebra/SpecialFunctions.html">Special Functions</a></li>
  <li><a href="FastLinearAlgebra/VectorOperationsAndFunctions.html">Vector Operations and Functions</a></li>
  <li><a href="FastLinearAlgebra/QuaternionOperationsAndFunctions.html">Quaternion Operations and Functions</a></li>
  <li><a href="FastLinearAlgebra/PlaneOperationsAndFunctions.html">Plane Operations and Functions</a></li>
  <li><a href="FastLinearAlgebra/MatrixOperationsAndFunctions.html">Matrix Operations and Functions</a></li>
  <li><a href="FastLinearAlgebra/GeometricFunctions.html">Geometric Functions</a></li>
</ul>

<h1 id="introduction">Introduction</h1>

<p>The code for the mathematical classes and functions lives inside the <code class="language-plaintext highlighter-rouge">Harlinn::Math</code> 
namespace, and all that is needed to use this part of the library is to include the <code class="language-plaintext highlighter-rouge">Harlinn/Math/VectorMath.h</code> 
header file:</p>

<pre><code class="language-C++">#include &lt;Harlinn/Math/VectorMath.h&gt;
</code></pre>
<p>and you are ready to code.</p>

<p>In Game Programming Gems, Sam Melax describes a function for calculating the shortest arc 
quaternion between to vectors that can be implemented like this:</p>

<pre><code class="language-C++">
using namespace Harlinn
using namespace Harlinn::Math;

namespace Basics
{
    using Quaternion = Math::Quaternion&lt;float&gt;;

    Quaternion ShortestArc1( const Vector3f&amp; fromDir, 
                                    const Vector3f&amp; toDir ) noexcept
    {
        using Constants = Vector3f::Traits::Constants::Base;

        Vector3f fromDirNormalized = Normalize( fromDir );
        Vector3f toDirNormalized = Normalize( toDir );

        const float dot = ScalarDot( fromDirNormalized, toDirNormalized );
        if ( dot &gt;= 1.f )
        {
            return Quaternion::Identity( );
        }
        else if ( dot &lt;= -1.f )
        {
            Vector3f axis = Cross( fromDirNormalized, Vector3f::Right( ) );
            if ( AreNearlyEqual( ScalarLengthSquared( axis ), 0.f, 
                                                Constants::EpsilonValue ) )
            {
                axis = Cross( fromDirNormalized, Vector3f::Up() );
            }

            return Quaternion::FromAxisAndAngle( axis, Constants::Pi );
        }
        else
        {
            const float s = Sqrt( ( 1.f + dot ) * 2.f );
            Vector3f cp = Cross( fromDirNormalized, toDirNormalized ) / s;
            Quaternion result( cp, s * 0.5f );
            return result;
        }
    }
}

</code></pre>

<p>No surprises here, the above looks like something that could easily be done using most
3D math libraries.</p>

<p>Currently, this implementation is as fast as <code class="language-plaintext highlighter-rouge">Quaternion::FromToRotation</code> from <a href="https://github.com/microsoft/DirectXTK12">DirectXTK12</a>,
which is cool:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BenchmarkShortestArc1                                29.8 ns         29.3 ns     22400000
BenchmarkDirectXTK12QuaternionFromToRotation         30.5 ns         30.0 ns     21333333
</code></pre></div></div>

<p>A better performing version would look like:</p>

<pre><code class="language-C++">    Quaternion ShortestArc2( const Vector3f::Simd&amp; fromDir, 
                                    const Vector3f::Simd&amp; toDir ) noexcept
    {
        using Constants = Vector3f::Traits::Constants::Base;

        auto fromDirNormalized = Normalize( fromDir );
        auto toDirNormalized = Normalize( toDir );

        const auto dot = Dot( fromDirNormalized, toDirNormalized );
        const auto dotf = dot[ 0 ];
        if ( dotf &gt;= 1.f )
        {
            return Quaternion::Identity( );
        }
        else if ( dotf &lt;= -1.f )
        {
            auto axis = Cross( fromDirNormalized, Vector3f::Right( ) );
            if ( AreNearlyEqual( ScalarLengthSquared( axis ), 0.f, 
                                                Constants::EpsilonValue ) )
            {
                axis = Cross( fromDirNormalized, Vector3f::Up( ) );
            }

            return Quaternion::FromAxisAndAngle( axis, Constants::Pi );
        }
        else
        {
            const auto s = Sqrt( ( 1.f + dot ) * 2.f );
            auto cp = Cross( fromDirNormalized, toDirNormalized ) / s;
            Quaternion result( cp, s[0] * 0.5f );
            return result;
        }
    }
</code></pre>

<p>which looks almost identical to <code class="language-plaintext highlighter-rouge">ShortestArc1</code>, but the benchmark:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BenchmarkShortestArc2                                14.6 ns         14.6 ns     44800000
</code></pre></div></div>

<p>shows that <code class="language-plaintext highlighter-rouge">ShortestArc2</code> is more than twice as fast as <code class="language-plaintext highlighter-rouge">ShortestArc1</code>. Like <code class="language-plaintext highlighter-rouge">ShortestArc2</code>, 
<code class="language-plaintext highlighter-rouge">ShortestArc1</code> also does most of its calculations using functions that are implemented 
using SIMD, but <code class="language-plaintext highlighter-rouge">ShortestArc2</code> is smarter about how it does that.</p>

<p>The short explanation is that <code class="language-plaintext highlighter-rouge">ShortestArc2</code> avoids a bunch of calls to <code class="language-plaintext highlighter-rouge">_mm_load_ps</code> and <code class="language-plaintext highlighter-rouge">_mm_store_ps</code>,
and their sibling intrinsic functions, and here is why:</p>

<pre><code class="language-C++">    Quaternion ShortestArc2( const Vector3f::Simd&amp; fromDir, 
                                    const Vector3f::Simd&amp; toDir ) noexcept
    {
        using Constants = Vector3f::Traits::Constants::Base;

</code></pre>

<p>Since <code class="language-plaintext highlighter-rouge">Normalize</code> returns a <code class="language-plaintext highlighter-rouge">Vector3f::Simd</code> object, and using this for the calculations
eliminates calls to <code class="language-plaintext highlighter-rouge">_mm_load_ps</code> and <code class="language-plaintext highlighter-rouge">_mm_store_ps</code>, we replace <code class="language-plaintext highlighter-rouge">Vector3f</code> with <code class="language-plaintext highlighter-rouge">auto</code>
in the code.</p>

<pre><code class="language-C++">        auto fromDirNormalized = Normalize( fromDir );
        auto toDirNormalized = Normalize( toDir );

</code></pre>
<p>Next we replace the call to <code class="language-plaintext highlighter-rouge">ScalarDot( fromDirNormalized, toDirNormalized )</code> that returns 
the dot product as a scalar, with <code class="language-plaintext highlighter-rouge">Dot( fromDirNormalized, toDirNormalized )</code> which returns 
a <code class="language-plaintext highlighter-rouge">Vector3f::Simd</code> object.</p>

<pre><code class="language-C++">        const auto dot = Dot( fromDirNormalized, toDirNormalized );
</code></pre>
<p>The <code class="language-plaintext highlighter-rouge">Vector3f::Simd</code> type doesn’t have member variables for <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>, as it
uses a member variable <code class="language-plaintext highlighter-rouge">simd</code> of type <code class="language-plaintext highlighter-rouge">__m128</code> to store its data. <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>
occupies the first, second and third position of the <code class="language-plaintext highlighter-rouge">__m128</code>, respectively. <code class="language-plaintext highlighter-rouge">Dot</code> sets
the first, second and third position of the <code class="language-plaintext highlighter-rouge">__m128</code> to the value of the dot product
between the argument vectors. <code class="language-plaintext highlighter-rouge">Vector3f::Simd</code> provides access to the individual
values through its <code class="language-plaintext highlighter-rouge">float x( ) const noexcept</code>, <code class="language-plaintext highlighter-rouge">float y( ) const noexcept</code> and 
<code class="language-plaintext highlighter-rouge">float z( ) const noexcept</code> member functions, and we need this value to be able to
handle possible singularities.</p>

<pre><code class="language-C++">        const auto dotf = dot.x( );
</code></pre>

<p>With that out of the way, we replace the remaining <code class="language-plaintext highlighter-rouge">Vector3f</code> declarations with <code class="language-plaintext highlighter-rouge">auto</code>:</p>

<pre><code class="language-C++">        if ( dotf &gt;= 1.f )
        {
            return Quaternion::Identity( );
        }
        else if ( dotf &lt;= -1.f )
        {
            auto axis = Cross( fromDirNormalized, Vector3f::Right( ) );
            if ( AreNearlyEqual( ScalarLengthSquared( axis ), 0.f, 
                                                Constants::EpsilonValue ) )
            {
                axis = Cross( fromDirNormalized, Vector3f::Up( ) );
            }

            return Quaternion::FromAxisAndAngle( axis, Constants::Pi );
        }
        else
        {
</code></pre>

<p>The next line of code is interesting, as diving into the details about what’s
happening explains a lot about how the library works.</p>

<p>The expression <code class="language-plaintext highlighter-rouge">1.f + dot</code> is handled by an <code class="language-plaintext highlighter-rouge">operator +</code> overload that widens <code class="language-plaintext highlighter-rouge">1.f</code> to a 
<code class="language-plaintext highlighter-rouge">__m128</code> value with <code class="language-plaintext highlighter-rouge">1.f</code> in the three first positions before doing vector addition with
the <code class="language-plaintext highlighter-rouge">simd</code> variable of <code class="language-plaintext highlighter-rouge">dot</code>, returning the result as a <code class="language-plaintext highlighter-rouge">Vector3f::Simd</code> object. The result
then gets passed to an <code class="language-plaintext highlighter-rouge">operator +</code> overload that widens <code class="language-plaintext highlighter-rouge">2.f</code> into <code class="language-plaintext highlighter-rouge">__m128</code> value with 
<code class="language-plaintext highlighter-rouge">2.f</code> in the three first positions before doing vector multiplication with the result
of <code class="language-plaintext highlighter-rouge">1.f + dot</code>, returning the result as <code class="language-plaintext highlighter-rouge">Vector3f::Simd</code> object. This is then passed to
an overload of <code class="language-plaintext highlighter-rouge">Sqrt</code> that calculates the square root for each of the elements in the 
result of <code class="language-plaintext highlighter-rouge">( 1.f + dot ) * 2.f</code>, returning a <code class="language-plaintext highlighter-rouge">Vector3f::Simd</code> object which is stored in <code class="language-plaintext highlighter-rouge">s</code>.</p>

<pre><code class="language-C++">            const auto s = Sqrt( ( 1.f + dot ) * 2.f );
</code></pre>
<p>So <code class="language-plaintext highlighter-rouge">s</code> is now a <code class="language-plaintext highlighter-rouge">Vector3f::Simd</code> object, with relevant values in its
first three positions, and naturally <code class="language-plaintext highlighter-rouge">Cross</code> also returns a <code class="language-plaintext highlighter-rouge">Vector3f::Simd</code> object.
The result of the call to <code class="language-plaintext highlighter-rouge">Cross</code> and <code class="language-plaintext highlighter-rouge">s</code> gets handled by an <code class="language-plaintext highlighter-rouge">operator /</code> overload
dividing each of the elements of the first by its corresponding element in <code class="language-plaintext highlighter-rouge">s</code>,
again returning a <code class="language-plaintext highlighter-rouge">Vector3f::Simd</code> object which is assigned to <code class="language-plaintext highlighter-rouge">cp</code>.</p>

<pre><code class="language-C++">            auto cp = Cross( fromDirNormalized, toDirNormalized ) / s;
            Quaternion result( cp, s[0] * 0.5f );
            return result;
        }
    }
</code></pre>

<p><code class="language-plaintext highlighter-rouge">ShortestArc2</code> is as readable as <code class="language-plaintext highlighter-rouge">ShortestArc1</code>, and most of the increased performance 
was achieved by replacing <code class="language-plaintext highlighter-rouge">Vector3f</code> with <code class="language-plaintext highlighter-rouge">auto</code>, which is good C++ practice, anyway.</p>

<p>Could it be even faster? Sure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BenchmarkShortestArc                                 11.1 ns         11.2 ns     56000000
</code></pre></div></div>

<p>This benchmark, <code class="language-plaintext highlighter-rouge">BenchmarkShortestArc</code>, is for the <code class="language-plaintext highlighter-rouge">ShortestArc</code> implementation found 
in <code class="language-plaintext highlighter-rouge">Harlinn/Math/VectorMath.h</code>.</p>

<h1 id="implementation-details">Implementation Details</h1>

<p>The following operations are currently supported for <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> 
and <code class="language-plaintext highlighter-rouge">Tuple4</code>:</p>

<p><code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, unary <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>,
<code class="language-plaintext highlighter-rouge">+=</code>, <code class="language-plaintext highlighter-rouge">-=</code>, <code class="language-plaintext highlighter-rouge">*=</code>, <code class="language-plaintext highlighter-rouge">/=</code>, <code class="language-plaintext highlighter-rouge">Abs</code>, <code class="language-plaintext highlighter-rouge">Min</code>, <code class="language-plaintext highlighter-rouge">Max</code>, <code class="language-plaintext highlighter-rouge">Sqr</code>, <code class="language-plaintext highlighter-rouge">Ceil</code>, <code class="language-plaintext highlighter-rouge">Floor</code>, <code class="language-plaintext highlighter-rouge">Round</code>, 
<code class="language-plaintext highlighter-rouge">Trunc</code>, <code class="language-plaintext highlighter-rouge">Lerp</code>, <code class="language-plaintext highlighter-rouge">Saturate</code>, <code class="language-plaintext highlighter-rouge">Sqrt</code>, <code class="language-plaintext highlighter-rouge">FMA</code>, <code class="language-plaintext highlighter-rouge">FMSub</code>, <code class="language-plaintext highlighter-rouge">Sin</code>, <code class="language-plaintext highlighter-rouge">Cos</code>, <code class="language-plaintext highlighter-rouge">Tan</code>, 
<code class="language-plaintext highlighter-rouge">ASin</code>, <code class="language-plaintext highlighter-rouge">ACos</code>, <code class="language-plaintext highlighter-rouge">ATan</code>, <code class="language-plaintext highlighter-rouge">ATan2</code>, <code class="language-plaintext highlighter-rouge">SinH</code>, <code class="language-plaintext highlighter-rouge">CosH</code>, <code class="language-plaintext highlighter-rouge">TanH</code>, <code class="language-plaintext highlighter-rouge">ASinH</code>, <code class="language-plaintext highlighter-rouge">ACosH</code>, 
<code class="language-plaintext highlighter-rouge">ATanH</code>, <code class="language-plaintext highlighter-rouge">Log</code>, <code class="language-plaintext highlighter-rouge">Log1P</code>, <code class="language-plaintext highlighter-rouge">Log10</code>, <code class="language-plaintext highlighter-rouge">Log2</code>, <code class="language-plaintext highlighter-rouge">Exp</code>, <code class="language-plaintext highlighter-rouge">Exp10</code>, <code class="language-plaintext highlighter-rouge">Exp2</code>, <code class="language-plaintext highlighter-rouge">ExpM1</code>, 
<code class="language-plaintext highlighter-rouge">Pow</code>, <code class="language-plaintext highlighter-rouge">Dot</code>, <code class="language-plaintext highlighter-rouge">Hypot</code>, <code class="language-plaintext highlighter-rouge">Permute</code>, <code class="language-plaintext highlighter-rouge">Cross</code>, <code class="language-plaintext highlighter-rouge">LengthSquared</code>, <code class="language-plaintext highlighter-rouge">Length</code>
<code class="language-plaintext highlighter-rouge">Normalize</code>, <code class="language-plaintext highlighter-rouge">ReciprocalLength</code>, <code class="language-plaintext highlighter-rouge">DistanceSquared</code>, <code class="language-plaintext highlighter-rouge">Distance</code>, <code class="language-plaintext highlighter-rouge">HProd</code>
<code class="language-plaintext highlighter-rouge">HSum</code>, <code class="language-plaintext highlighter-rouge">DifferenceOfProducts</code>, <code class="language-plaintext highlighter-rouge">SumOfProducts</code></p>

<h3 id="tuple2-tuple3-tuple4-and-tuplesimd-functions">Tuple2, Tuple3, Tuple4 and TupleSimd Functions</h3>

<ul>
  <li><a href="#hsum-and-scalarhsum">HSum and ScalarHSum</a></li>
  <li><a href="#hprod-and-scalarhprod">HProd and ScalarHProd</a></li>
  <li><a href="#abs">Abs</a></li>
  <li><a href="#min">Min</a></li>
  <li><a href="#max">Max</a></li>
  <li><a href="#sqr">Sqr</a></li>
  <li><a href="#ceil">Ceil</a></li>
  <li><a href="#floor">Floor</a></li>
  <li><a href="#round">Round</a></li>
  <li><a href="#trunc">Trunc</a></li>
  <li><a href="#lerp">Lerp</a></li>
  <li><a href="#clamp">Clamp</a></li>
  <li><a href="#saturate">Saturate</a></li>
  <li><a href="#sqrt">Sqrt</a></li>
  <li><a href="#reciprocalsqrt">ReciprocalSqrt</a></li>
  <li><a href="#reciprocal">Reciprocal</a></li>
  <li><a href="#fma">FMA</a></li>
  <li><a href="#fmsub">FMSub</a></li>
  <li><a href="#fmaddsub">FMAddSub</a></li>
  <li><a href="#fmsubadd">FMSubAdd</a></li>
  <li><a href="#fnmadd">FNMAdd</a></li>
  <li><a href="#fnmsub">FNMSub</a></li>
  <li><a href="#sin">Sin</a></li>
  <li><a href="#cos">Cos</a></li>
  <li><a href="#tan">Tan</a></li>
  <li><a href="#asin">ASin</a></li>
  <li><a href="#acos">ACos</a></li>
  <li><a href="#atan">ATan</a></li>
  <li><a href="#atan2">ATan2</a></li>
  <li><a href="#modangles">ModAngles</a></li>
  <li><a href="#addangles">AddAngles</a></li>
  <li><a href="#subtractangles">SubtractAngles</a></li>
  <li><a href="#sinh">SinH</a></li>
  <li><a href="#cosh">CosH</a></li>
  <li><a href="#tanh">TanH</a></li>
  <li><a href="#asinh">ASinH</a></li>
  <li><a href="#acosh">ACosH</a></li>
  <li><a href="#atanh">ATanH</a></li>
  <li><a href="#log">Log</a></li>
  <li><a href="#log1p">Log1P</a></li>
  <li><a href="#log10">Log10</a></li>
  <li><a href="#log2">Log2</a></li>
  <li><a href="#exp">Exp</a></li>
  <li><a href="#exp10">Exp10</a></li>
  <li><a href="#exp2">Exp2</a></li>
  <li><a href="#expm1">ExpM1</a></li>
  <li><a href="#pow">Pow</a></li>
  <li><a href="#hypot">Hypot</a></li>
  <li><a href="#hermite">Hermite</a></li>
  <li><a href="#dot-and-scalardot">Dot and ScalarDot</a></li>
  <li><a href="#absdot-and-scalarabsdot">AbsDot and ScalarAbsDot</a></li>
  <li><a href="#cross">Cross</a></li>
  <li><a href="#lengthsquared-and-scalarlengthsquared">LengthSquared and ScalarLengthSquared</a></li>
  <li><a href="#length-and-scalarlength">Length and ScalarLength</a></li>
  <li><a href="#normalize">Normalize</a></li>
  <li><a href="#reciprocallength-and-scalarreciprocallength">ReciprocalLength and ScalarReciprocalLength</a></li>
  <li><a href="#distancesquared-and-scalardistancesquared">DistanceSquared and ScalarDistanceSquared</a></li>
  <li><a href="#distance-and-scalardistance">Distance and ScalarDistance</a></li>
  <li><a href="#inbounds">InBounds</a></li>
  <li><a href="#clamplength">ClampLength</a></li>
  <li><a href="#reflect">Reflect</a></li>
  <li><a href="#refract">Refract</a></li>
  <li><a href="#orthogonal">Orthogonal</a></li>
  <li><a href="#differenceofproducts">DifferenceOfProducts</a></li>
  <li><a href="#sumofproducts">SumOfProducts</a></li>
  <li><a href="#barycentric">BaryCentric</a></li>
  <li><a href="#catmullrom">CatmullRom</a></li>
  <li><a href="#mincomponentvalue">MinComponentValue</a></li>
  <li><a href="#maxcomponentvalue">MaxComponentValue</a></li>
  <li><a href="#mincomponentindex">MinComponentIndex</a></li>
  <li><a href="#maxcomponentindex">MaxComponentIndex</a></li>
</ul>

<p>The functions that work with the <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code>, <code class="language-plaintext highlighter-rouge">Tuple4</code> and <code class="language-plaintext highlighter-rouge">TupleSimd</code> types
generally returns a <code class="language-plaintext highlighter-rouge">TupleSimd</code> holding the result of the operation.</p>

<p>There are usually several overloads for each function, allowing the values
held by the <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> derived types to be automatically
loaded into a SIMD type/register.</p>

<p>Functions that calculate a single scalar value, returns a <code class="language-plaintext highlighter-rouge">TupleSimd</code> where every
element holds the calculated value. These functions also have an implementation that 
returns the scalar as single value. For instance, <code class="language-plaintext highlighter-rouge">Dot</code> returns a <code class="language-plaintext highlighter-rouge">TupleSimd</code>, while <code class="language-plaintext highlighter-rouge">ScalarDot</code> returns
a floating point value of the same type as a single element from the <code class="language-plaintext highlighter-rouge">TupleSimd</code> type.</p>

<h4 id="hsum-and-scalarhsum">HSum and ScalarHSum</h4>

<p>Calculates the horizontal sum of the elements in the vector.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T HSum( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
inline ResultT ScalarHSum( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT HSum( const T&amp; t ) noexcept;

</code></pre>

<h4 id="hprod-and-scalarhprod">HProd and ScalarHProd</h4>

<p>Calculates the horizontal product of the elements in the vector.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T HProd( const T&amp; t ) noexcept;

template&lt;Internal::SimdType T&gt;
inline auto ScalarHProd( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
inline ResultT ScalarHProd( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT HProd( const T&amp; t ) noexcept;
</code></pre>

<h4 id="abs">Abs</h4>

<p>Computes the absolute value of each element held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Abs( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Abs( const T&amp; t ) noexcept;
</code></pre>

<h4 id="min">Min</h4>

<p>Makes a comparison between the elements held by the two arguments, and 
returns a TupleSimd containing the smallest elements.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Min( const T&amp; lhs, const U&amp; rhs ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Min( const T&amp; lhs, const U&amp; rhs ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Min( const U&amp; lhs, const T&amp; rhs ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, 
                typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Min( const T&amp; lhs, const U&amp; rhs ) noexcept;
</code></pre>

<h4 id="max">Max</h4>

<p>Makes a comparison between the elements held by the two arguments, and 
returns a TupleSimd containing the largest elements.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Max( const T&amp; lhs, const U&amp; rhs ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Max( const T&amp; lhs, const U&amp; rhs ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Max( const U&amp; lhs, const T&amp; rhs ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, 
                typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Max( const T&amp; lhs, const U&amp; rhs ) noexcept;
</code></pre>

<h4 id="sqr">Sqr</h4>

<p>Computes the square value of each element held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Sqr( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Sqr( const T&amp; t ) noexcept;
</code></pre>

<h4 id="ceil">Ceil</h4>

<p>Computes the ceiling of each element held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Ceil( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Ceil( const T&amp; t ) noexcept;
</code></pre>

<h4 id="floor">Floor</h4>

<p>Computes the floor of each element held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Floor( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Floor( const T&amp; t ) noexcept;
</code></pre>

<h4 id="round">Round</h4>

<p>Rounds each element held by the argument towards the nearest even integer.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Round( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Round( const T&amp; t ) noexcept;
</code></pre>

<h4 id="trunc">Trunc</h4>

<p>Rounds each element held by the argument to the nearest integer in the direction of zero.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Trunc( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Trunc( const T&amp; t ) noexcept;
</code></pre>

<h4 id="lerp">Lerp</h4>

<p>Calculates the linear interpolation between the
the elements of <code class="language-plaintext highlighter-rouge">a</code> and the elements of <code class="language-plaintext highlighter-rouge">b</code>, for elements of
<code class="language-plaintext highlighter-rouge">c</code> is inside [0,1), or the linear extrapolation for elements
in <code class="language-plaintext highlighter-rouge">c</code> outside [0,1).</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt; &amp;&amp; Internal::IsCompatible&lt;T, U&gt; 
inline T Lerp( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Lerp( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U Lerp( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, 
                                    typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT Lerp( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, 
                                    typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="clamp">Clamp</h4>

<p>Returns the elements of v, if the elements are between their
respective boundaries specified the elements of lowerBounds
and the elements of upperBounds, otherwise the value of nearest
boundary is returned.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, 
                                        typename ResultT = typename S::Simd&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, 
                                        typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt; &amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT Clamp( NumberT v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;
</code></pre>

<h4 id="saturate">Saturate</h4>

<p>Saturates the elements of v to the range 0.0 to 1.0.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Saturate( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Saturate( const T&amp; v ) noexcept;
</code></pre>

<h4 id="sqrt">Sqrt</h4>

<p>Calculates the square root of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Sqrt( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Sqrt( const T&amp; v ) noexcept;
</code></pre>

<h4 id="reciprocalsqrt">ReciprocalSqrt</h4>

<p>Calculates the reciprocal square root of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ReciprocalSqrt( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ReciprocalSqrt( const T&amp; v ) noexcept;
</code></pre>

<h4 id="reciprocal">Reciprocal</h4>

<p>Calculates the reciprocal of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Reciprocal( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Reciprocal( const T&amp; v ) noexcept;
</code></pre>

<h4 id="fma">FMA</h4>

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMA( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, 
                                    typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMA( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMA( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, 
                                    typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMA( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, 
                                        typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="fmsub">FMSub</h4>

<p>Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, 
a and b, are multiplied and the infinite precision intermediate results are obtained. From the 
infinite precision intermediate results, the values in the third operand, c, are subtracted. 
The final results are rounded to the nearest floating point values.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="fmaddsub">FMAddSub</h4>

<p>Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are 
multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, 
c, are added to the intermediate results while the even values are subtracted from them. The final results 
are rounded to the nearest floating point values.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMAddSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMAddSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMAddSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMAddSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="fmsubadd">FMSubAdd</h4>

<p>Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, 
are multiplied and infinite precision intermediate results are obtained. The odd values in the third 
operand, c, are subtracted from the intermediate results while the even values are added to them. 
The final results are rounded to the nearest floating point values.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSubAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSubAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSubAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSubAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="fnmadd">FNMAdd</h4>

<p>Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, 
a and b, are multiplied and the negated infinite precision intermediate results are added to 
the values in the third operand, c, after which the final results are rounded to the nearest 
floating point values.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="fnmsub">FNMSub</h4>

<p>Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, 
are multiplied and the negated infinite precision intermediate result is obtained. From this negated 
intermediate result, the value in the third operand, c, is subtracted. The final result is rounded 
to the nearest floating point value.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="sin">Sin</h4>

<p>Calculates the sine of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Sin( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Sin( const T&amp; v ) noexcept;
</code></pre>

<h4 id="cos">Cos</h4>

<p>Calculates the cosine of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Cos( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Cos( const T&amp; v ) noexcept;
</code></pre>

<h4 id="tan">Tan</h4>

<p>Calculates the tangent of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Tan( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Tan( const T&amp; v ) noexcept;
</code></pre>

<h4 id="asin">ASin</h4>

<p>Calculates the inverse sine of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ASin( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ASin( const T&amp; v ) noexcept;
</code></pre>

<h4 id="acos">ACos</h4>

<p>Calculates the inverse cosine of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ACos( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ACos( const T&amp; v ) noexcept;
</code></pre>

<h4 id="atan">ATan</h4>

<p>Calculates the inverse tangent of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ATan( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ATan( const T&amp; v ) noexcept;
</code></pre>

<h4 id="atan2">ATan2</h4>

<p>Calculates the inverse tangent of each element in x divided by the
corresponding element in y, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T ATan2( const T&amp; x, const U&amp; y ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T ATan2( const T&amp; x, const U&amp; y ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T ATan2( const U&amp; x, const T&amp; y ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT ATan2( const T&amp; x, const U&amp; y ) noexcept;
</code></pre>

<h4 id="modangles">ModAngles</h4>

<p>Calculates the angle modulo \(2\pi\) of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ModAngles( const T&amp; angles );

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ModAngles( const T&amp; v ) noexcept;
</code></pre>

<h4 id="addangles">AddAngles</h4>

<p>Adds the angles in the corresponding elements of v1 and v2.
The argument angles must be in the range \([-\pi,\pi)\), and the
computed angles will be in the range \([-\pi,\pi)\).</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AddAngles( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AddAngles( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AddAngles( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT AddAngles( const T&amp; v1, const U&amp; v2 ) noexcept;
</code></pre>

<h4 id="subtractangles">SubtractAngles</h4>

<p>Subtracts the angles in v2 from the corresponding elements of v1.
The argument angles must be in the range \([-\pi,\pi)\), and the
computed angles will be in the range \([-\pi,\pi)\)</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T SubtractAngles( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T SubtractAngles( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T SubtractAngles( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT SubtractAngles( const T&amp; v1, const U&amp; v2 ) noexcept;
</code></pre>

<h4 id="sinh">SinH</h4>

<p>Calculates the hyperbolic sine of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T SinH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT SinH( const T&amp; v ) noexcept;
</code></pre>

<h4 id="cosh">CosH</h4>

<p>Calculates the hyperbolic cosine of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T CosH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT CosH( const T&amp; v ) noexcept;
</code></pre>

<h4 id="tanh">TanH</h4>

<p>Calculates the hyperbolic tangent of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T TanH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT TanH( const T&amp; v ) noexcept;
</code></pre>

<h4 id="asinh">ASinH</h4>

<p>Calculates the inverse hyperbolic sine of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ASinH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ASinH( const T&amp; v ) noexcept;
</code></pre>

<h4 id="acosh">ACosH</h4>

<p>Calculates the inverse hyperbolic cosine of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ACosH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ACosH( const T&amp; v ) noexcept;
</code></pre>
<h4 id="atanh">ATanH</h4>

<p>Calculates the inverse hyperbolic tangent of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ATanH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ATanH( const T&amp; v ) noexcept;
</code></pre>

<h4 id="log">Log</h4>

<p>Calculates the natural logarithm of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Log( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Log( const T&amp; v ) noexcept;
</code></pre>

<h4 id="log1p">Log1P</h4>

<p>Calculates the natural logarithm of \(1 +\) each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Log1P( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Log1P( const T&amp; v ) noexcept;
</code></pre>

<h4 id="log10">Log10</h4>

<p>Calculates the base-10 logarithm, \(log_{10}\), of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Log10( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Log10( const T&amp; v ) noexcept;
</code></pre>

<h4 id="log2">Log2</h4>

<p>Calculates the base-2 logarithm, \(log_{2}\), of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Log2( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Log2( const T&amp; v ) noexcept;
</code></pre>

<h4 id="exp">Exp</h4>

<p>Calculates \(e\) (Euler’s number, 2.7182818…), raised to the power of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Exp( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Exp( const T&amp; v ) noexcept;
</code></pre>

<h4 id="exp10">Exp10</h4>

<p>Calculates the base-10 exponential of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Exp10( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Exp10( const T&amp; v ) noexcept;
</code></pre>

<h4 id="exp2">Exp2</h4>

<p>Calculates the base-2 exponential of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Exp2( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Exp2( const T&amp; v ) noexcept;
</code></pre>

<h4 id="expm1">ExpM1</h4>

<p>Calculates  \(e\) (Euler’s number, 2.7182818…), raised to the power 
of each element in the argument, \(-1.0\).</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ExpM1( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ExpM1( const T&amp; v ) noexcept;
</code></pre>

<h4 id="pow">Pow</h4>

<p>Calculates the elements in <code class="language-plaintext highlighter-rouge">base</code> raised to the corresponding elements in <code class="language-plaintext highlighter-rouge">exponent</code>.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Pow( const T&amp; base, const U&amp; exponent ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Pow( const T&amp; base, const U&amp; exponent ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Pow( const U&amp; base, const T&amp; exponent ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Pow( const T&amp; base, const U&amp; exponent ) noexcept;
</code></pre>

<h4 id="hypot">Hypot</h4>

<p>Calculates the square root of the sum of the squares of each corresponding 
element in x and y, without undue overflow or underflow at intermediate 
stages of the computation.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Hypot( const T&amp; x, const U&amp; y ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Hypot( const T&amp; x, const U&amp; y ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Hypot( const U&amp; x, const T&amp; y ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Hypot( const T&amp; x, const U&amp; y ) noexcept;
</code></pre>

<h4 id="hermite">Hermite</h4>

<p>Calculates the Hermite spline interpolation, using the specified arguments.</p>

<pre><code class="language-C++">
template&lt;Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;
</code></pre>

<h4 id="dot-and-scalardot">Dot and ScalarDot</h4>

<p>Calculates the dot product between v1 and v2.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Dot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Dot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Dot( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Dot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
constexpr inline typename T::value_type ScalarDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
constexpr inline typename T::value_type ScalarDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
constexpr inline typename T::value_type ScalarDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::value_type&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
constexpr inline ResultT ScalarDot( const T&amp; v1, const U&amp; v2 ) noexcept;
</code></pre>

<h4 id="absdot-and-scalarabsdot">AbsDot and ScalarAbsDot</h4>

<p>Calculates the absolute value of the dot product between v1 and v2.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AbsDot( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT AbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarAbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarAbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarAbsDot( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarAbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;
</code></pre>

<h4 id="cross">Cross</h4>

<p>Calculates the cross product between v1 and v2.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Cross( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Cross( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Cross( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Cross( const T&amp; v1, const U&amp; v2 ) noexcept;
</code></pre>

<h4 id="lengthsquared-and-scalarlengthsquared">LengthSquared and ScalarLengthSquared</h4>

<p>Calculates the squared length of v.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T LengthSquared( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT LengthSquared( const T&amp; v ) noexcept;

template&lt;Internal::SimdType T&gt;
inline auto ScalarLengthSquared( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T&gt;
inline auto ScalarLengthSquared( const T&amp; v ) noexcept;

</code></pre>

<h4 id="length-and-scalarlength">Length and ScalarLength</h4>

<p>Calculates the length of v.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Length( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Length( const T&amp; v ) noexcept;

template&lt;Internal::SimdType T&gt;
inline auto ScalarLength( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T&gt;
inline auto ScalarLength( const T&amp; v ) noexcept;
</code></pre>

<h4 id="normalize">Normalize</h4>

<p>Normalizes v.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Normalize( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Normalize( const T&amp; v ) noexcept;
</code></pre>
<h4 id="reciprocallength-and-scalarreciprocallength">ReciprocalLength and ScalarReciprocalLength</h4>

<p>Calculates the reciprocal length of v.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ReciprocalLength( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ReciprocalLength( const T&amp; v ) noexcept;

template&lt;Internal::SimdType T&gt;
inline auto ScalarReciprocalLength( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T&gt;
inline auto ScalarReciprocalLength( const T&amp; v ) noexcept;
</code></pre>

<h4 id="distancesquared-and-scalardistancesquared">DistanceSquared and ScalarDistanceSquared</h4>

<p>Calculates the squared distance between p1 and p2.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T DistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T DistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T DistanceSquared( const U&amp; p1, const T&amp; p2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT DistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistanceSquared( const U&amp; p1, const T&amp; p2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;
</code></pre>

<h4 id="distance-and-scalardistance">Distance and ScalarDistance</h4>

<p>Calculates the distance between p1 and p2.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Distance( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Distance( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Distance( const U&amp; p1, const T&amp; p2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Distance( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistance( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistance( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistance( const U&amp; p1, const T&amp; p2 ) noexcept;
</code></pre>

<h4 id="inbounds">InBounds</h4>

<p>Detects if the elements of a vector are within bounds.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline S InBounds( const S&amp; v, const T&amp; bounds ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline S InBounds( const S&amp; v, const T&amp; bounds ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline T InBounds( const S&amp; v, const T&amp; bounds ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline typename S::Simd InBounds( const S&amp; v, const T&amp; bounds ) noexcept;

</code></pre>

<h4 id="clamplength">ClampLength</h4>

<p>Clamps the length of a vector to a given range.</p>
<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::SimdType S, typename T, typename U&gt;
    requires IsFloatingPoint&lt;T&gt; &amp;&amp; IsFloatingPoint&lt;U&gt;
inline S ClampLength( const S&amp; v, const T lengthMin, const U lengthMax ) noexcept;

template&lt;Internal::TupleType S, typename T, typename U&gt;
    requires IsFloatingPoint&lt;T&gt;&amp;&amp; IsFloatingPoint&lt;U&gt;
inline S ClampLength( const S&amp; v, const T lengthMin, const U lengthMax ) noexcept;
</code></pre>

<h4 id="reflect">Reflect</h4>

<p>Reflects an incident vector across a normal vector.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline S Reflect( const S&amp; incident, const T&amp; normal ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline S Reflect( const S&amp; incident, const T&amp; normal ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline T Reflect( const S&amp; incident, const T&amp; normal ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline typename S::Simd Reflect( const S&amp; incident, const T&amp; normal ) noexcept;

</code></pre>

<h4 id="refract">Refract</h4>

<p>Refracts an incident vector across a normal vector.</p>

<pre><code class="language-C++">
template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, typename U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; IsFloatingPoint&lt;U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U refractionIndex ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, typename U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; IsFloatingPoint&lt;U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, typename U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; IsFloatingPoint&lt;U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, typename U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; IsFloatingPoint&lt;U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U refractionIndex ) noexcept;
</code></pre>

<h4 id="orthogonal">Orthogonal</h4>

<p>Computes a vector perpendicular to the argument vector.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S&gt;
inline S Orthogonal( const S&amp; v ) noexcept;

template&lt;Internal::TupleType S&gt;
inline typename S::Simd Orthogonal( const S&amp; v ) noexcept;
</code></pre>

<h4 id="differenceofproducts">DifferenceOfProducts</h4>

<p>Calculates the difference between the product of the first and the second argument, 
and the product of the third and fourth argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline U DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline U DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline V DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline typename S::Simd DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;
</code></pre>

<h4 id="sumofproducts">SumOfProducts</h4>

<p>Calculates the sum of the product of the first and the second argument, 
and the product of the third and fourth argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline U SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline U SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline V SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline typename S::Simd SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;
</code></pre>

<h4 id="barycentric">BaryCentric</h4>

<p>Calculates a point in Barycentric coordinates, using the specified triangle.</p>

<p>see https://en.wikipedia.org/wiki/Barycentric_coordinate_system</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; IsFloatingPoint&lt;V&gt; &amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

</code></pre>

<h4 id="catmullrom">CatmullRom</h4>

<p>Calculates the Catmull-Rom interpolation, using the specified positions.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;


template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;
</code></pre>

<h4 id="mincomponentvalue">MinComponentValue</h4>

<p>Retrieves the lowest value held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, typename ResultT = typename T::value_type &gt;
inline ResultT MinComponentValue( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
constexpr inline ResultT MinComponentValue( const T&amp; v ) noexcept;
</code></pre>

<h4 id="maxcomponentvalue">MaxComponentValue</h4>

<p>Retrieves the highest value held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, typename ResultT = typename T::value_type &gt;
inline ResultT MaxComponentValue( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
constexpr inline ResultT MaxComponentValue( const T&amp; v ) noexcept;
</code></pre>

<h4 id="mincomponentindex">MinComponentIndex</h4>

<p>Retrieves the offset of the lowest value held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, typename ResultT = typename T::value_type &gt;
inline ResultT MinComponentIndex( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
constexpr inline ResultT MinComponentIndex( const T&amp; v ) noexcept;
</code></pre>

<h4 id="maxcomponentindex">MaxComponentIndex</h4>

<p>Retrieves the offset of the highest value held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, typename ResultT = typename T::value_type &gt;
inline ResultT MaxComponentIndex( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
constexpr inline ResultT MaxComponentIndex( const T&amp; v ) noexcept;
</code></pre>

<hr />

<h3 id="vector2f-vector3f-vector4f-vector2i-vector3i-vector4i">Vector2f, Vector3f, Vector4f, Vector2i, Vector3i, Vector4i</h3>

<p><code class="language-plaintext highlighter-rouge">Vector&lt;float,2&gt;</code>, <code class="language-plaintext highlighter-rouge">Vector&lt;float,3&gt;</code> and <code class="language-plaintext highlighter-rouge">Vector&lt;float,4&gt;</code> are specializations of <code class="language-plaintext highlighter-rouge">Vector&lt;T,N&gt;</code> that 
supports a wider repertoire of operations than the general <code class="language-plaintext highlighter-rouge">Vector&lt;T,N&gt;</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Vector&lt;float,2&gt;</code> is derived from the <code class="language-plaintext highlighter-rouge">Tuple2</code> template, <code class="language-plaintext highlighter-rouge">Vector&lt;float,3&gt;</code> is derived 
from the <code class="language-plaintext highlighter-rouge">Tuple3</code>, and <code class="language-plaintext highlighter-rouge">Vector&lt;float,4&gt;</code> is derived from <code class="language-plaintext highlighter-rouge">Tuple4</code>.</p>

<p>Just a few lines of code are required to create the <code class="language-plaintext highlighter-rouge">Vector&lt;float, 3&gt;</code> specialization of <code class="language-plaintext highlighter-rouge">Vector&lt;T,N&gt;</code>
with the full repertoire of features available for <code class="language-plaintext highlighter-rouge">Tuple3</code>:</p>

<pre><code class="language-C++">template&lt;&gt;
class Vector&lt;float, 3&gt; : public Tuple3&lt;Vector&lt;float, 3&gt;,float&gt;
{
public:
    using Base = Tuple3&lt;Vector&lt;float, 3&gt;, float&gt;;
    using Traits = Base::Traits;

    Vector( ) noexcept = default;
    explicit Vector( float v ) noexcept
        : Base( v, v, v )
    { }
    Vector( float xv, float yv, float zv ) noexcept
        : Base( xv, yv, zv )
    { }

    template&lt;typename T&gt;
        requires std::is_same_v&lt;typename T::SIMDType, typename Traits::SIMDType &gt;
    Vector( const T&amp; other ) noexcept
        : Base( other )
    { }
};
</code></pre>

<p>Below are two benchmarks, the first using <code class="language-plaintext highlighter-rouge">Math::Vector&lt;float, 3&gt;</code>, 
while the second uses <code class="language-plaintext highlighter-rouge">pbrt::Vector3f</code>.</p>

<pre><code class="language-C++">static void BenchmarkVector3( benchmark::State&amp; state )
{
    using namespace Harlinn::Math;
    using Vector = Math::Vector&lt;float, 3&gt;;
    DoubleGenerator.Reset( );

    for ( auto _ : state )
    {
        Vector v1( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        Vector v2( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        benchmark::DoNotOptimize( Dot( Abs( Max( Ceil( -v1 ), Floor( v2 ) ) ), v2 ) );
    }
}
BENCHMARK( BenchmarkVector3 );

static void BenchmarkPBRTVector3f( benchmark::State&amp; state )
{
    using namespace pbrt;
    using Vector = pbrt::Vector3f;
    DoubleGenerator.Reset( );


    for ( auto _ : state )
    {
        Vector v1( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        Vector v2( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        benchmark::DoNotOptimize( Dot( Abs( Max( Ceil( -v1 ), Floor( v2 ) ) ), v2 ) );
    }
}
BENCHMARK( BenchmarkPBRTVector3f );
</code></pre>
<p><code class="language-plaintext highlighter-rouge">BenchmarkVector2</code> runs <code class="language-plaintext highlighter-rouge">20</code> % faster than <code class="language-plaintext highlighter-rouge">BenchmarkPBRTVector3f</code> which is
optimized by the compiler for the AVX2 instruction set:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-------------------------------------------------------------------
Benchmark                         Time             CPU   Iterations
-------------------------------------------------------------------
BenchmarkVector3               5.63 ns         4.85 ns    186666667
BenchmarkPBRTVector3f          7.08 ns         5.86 ns    112000000
</code></pre></div></div>

<h4 id="vector-functions">Vector functions</h4>

<h5 id="anglebetween">AngleBetween</h5>

<p>Calculates the angle in radians between two vectors.</p>

<h5 id="anglebetweennormals">AngleBetweenNormals</h5>

<p>Calculates the angle in radians between two normalized vectors.</p>

<h5 id="transform">Transform</h5>

<p>Transforms a 3D vector by a matrix.</p>

<pre><code class="language-C++">inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;::Simd&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;::Simd&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;&amp; matrix );
</code></pre>

<h3 id="normal3f-and-normal3i">Normal3f and Normal3i</h3>

<p>The surface normal is a vector perpendicular to 
a surface at a specific position. It can be defined as the cross product 
of any two nonparallel vectors that are tangent to the surface at a point. 
Normals are similar to vectors, but it’s important to 
distinguish between the two of them: since normals are defined in terms 
of their relationship to a surface, they behave differently than 
vectors in some situations, particularly when applying transformations.</p>

<h4 id="normal3f-functions">Normal3f functions</h4>

<h5 id="transform-1">Transform</h5>

<p>Transforms the Normal3f object by the given matrix.</p>

<pre><code class="language-C++">inline Normal3f::Simd Transform( const Normal3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 3&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; v, 
                                const SquareMatrix&lt;float, 3&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 3&gt;&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; v, 
                                const SquareMatrix&lt;float, 3&gt;&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>

<h3 id="point3f-and-point3i">Point3f and Point3i</h3>

<p>A point is a zero-dimensional location in 2D or 3D space. The Point2i/f and Point3i/f 
classes represent points in the obvious way: using \(x, y, z\)  (in 3D) coordinates 
with respect to a coordinate system. Although the same representation is used for 
vectors, the fact that a point represents a position whereas a vector represents a 
direction leads to a number of important differences in how they are treated.</p>

<h4 id="point3f">Point3f</h4>

<h5 id="linepointdistance">LinePointDistance</h5>

<p>Calculates the minimum distance between a line and a point.</p>

<h5 id="transform-2">Transform</h5>

<p>Transforms the Point3f object by the provided transformation matrix.</p>

<pre><code class="language-C++">
inline Point3f::Simd Transform( const Point3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Point3f::Simd Transform( const Point3f&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Point3f::Simd Transform( const Point3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Point3f::Simd Transform( const Point3f&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>

<h2 id="squarematrix">SquareMatrix</h2>

<p>The <code class="language-plaintext highlighter-rouge">SquareMatrix</code> template class is used to represent transformations that can be applied
to vectors, points and surface normals.</p>

<p>The template is designed as a row oriented matrix, that can be instantiated for 
single and double precision floating point types. The template can be instantiated
as a \(2 x 2\), \(3 x 3\) or \(4 x 4\) matrix.</p>

<p>Internally, computations on \(2 x 2\) matrices are performed using a single SIMD type/register,
while operations on \(3 x 3\) and \(4 x 4\) matrices are performed using one
SIMD type/register for each row.</p>

<p><code class="language-plaintext highlighter-rouge">SquareMatrix</code> support matrix addition, scalar addition, matrix multiplication, scalar multiplication, 
the matrices can be transposed using <code class="language-plaintext highlighter-rouge">Transpose</code> and inverted using <code class="language-plaintext highlighter-rouge">Inverse</code>, and <code class="language-plaintext highlighter-rouge">Determinant</code> calculates
the determinant. The default constructor creates an identity matrix, so <code class="language-plaintext highlighter-rouge">SquareMatrix</code> handles the usual
operations associated with small square matrices.</p>

<h3 id="squarematrixfloat4-functions">SquareMatrix&lt;float,4&gt; functions</h3>

<h4 id="transpose">Transpose</h4>

<p>Calculates the transpose of the matrix.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd Transpose( const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline SquareMatrix&lt;float, 4&gt;::Simd Transpose( const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>

<h4 id="inverse">Inverse</h4>

<p>Calculates the inverse of the matrix.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd Inverse( const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix, 
                                            typename Vector&lt;float, 4&gt;::Simd* determinant = nullptr );

inline typename SquareMatrix&lt;float, 4&gt;::Simd Inverse( const SquareMatrix&lt;float, 4&gt;&amp; matrix, 
                                            typename Vector&lt;float, 4&gt;::Simd* determinant = nullptr );

</code></pre>

<h4 id="determinant-and-scalardeterminant">Determinant and ScalarDeterminant</h4>

<p>Calculates the determinant of a matrix.</p>

<pre><code class="language-C++">inline typename Vector&lt;float,4&gt;::Simd Determinant( const typename SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline typename Vector&lt;float, 4&gt;::Simd Determinant( const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline float ScalarDeterminant( const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline float ScalarDeterminant( const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>

<h4 id="translation">Translation</h4>

<p>Creates a translation matrix using the provided offsets.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd Translation( float offsetX, float offsetY, float offsetZ );

template&lt;Internal::SimdType S&gt;
    requires (S::Size &gt; 2) &amp;&amp; std::is_same_v&lt;typename S::value_type, float&gt;
inline SquareMatrix&lt;float, 4&gt;::Simd Translation( const S&amp; offsets );

template&lt;Internal::TupleType S&gt;
    requires ( S::Size &gt; 2 ) &amp;&amp; std::is_same_v&lt;typename S::value_type, float&gt;
inline SquareMatrix&lt;float, 4&gt;::Simd Translation( const S&amp; offsets );

</code></pre>

<h4 id="scaling">Scaling</h4>

<p>Creates a transformation matrix for scaling along 
the x-axis, y-axis, and z-axis.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd Scaling( float scaleX, float scaleY, float scaleZ );

template&lt;Internal::SimdType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd Scaling( const S&amp; v ) noexcept;

template&lt;Internal::TupleType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd Scaling( const S&amp; v ) noexcept;

</code></pre>

<h4 id="rotation">Rotation</h4>

<p>Creates a transformation matrix that rotates about the y-axis, 
then the x-axis, and finally the z-axis.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S&gt;
    requires (S::Size &gt; 2)
inline SquareMatrix&lt;float, 4&gt;::Simd Rotation( const S&amp; v ) noexcept;

template&lt;Internal::TupleType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd Rotation( const S&amp; v ) noexcept;

inline SquareMatrix&lt;float, 4&gt;::Simd Rotation( float xAxisRotation, 
                        float yAxisRotation, float zAxisRotation ) noexcept;
</code></pre>

<h4 id="rotationnormal">RotationNormal</h4>

<p>Creates a matrix that rotates around a normalized vector.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S&gt;
    requires ( S::Size &gt; 2 ) 
inline SquareMatrix&lt;float, 4&gt;::Simd RotationNormal( const S&amp; normalizedAxis, float angle ) noexcept;

template&lt;Internal::TupleType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd RotationNormal( const S&amp; normalizedAxis, float angle ) noexcept;

</code></pre>

<h4 id="rotationaxis">RotationAxis</h4>

<p>Creates a matrix that rotates around an arbitrary axis.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd RotationAxis( const S&amp; axis, float angle ) noexcept;

template&lt;Internal::TupleType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd RotationAxis( const S&amp; axis, float angle ) noexcept;
</code></pre>

<h4 id="rotationquaternion">RotationQuaternion</h4>

<p>Creates a rotation matrix from a quaternion.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd RotationQuaternion( const QuaternionSimd&lt;Quaternion&lt;float&gt;&gt;&amp; q );

inline SquareMatrix&lt;float, 4&gt;::Simd RotationQuaternion( const Quaternion&lt;float&gt;&amp; q );

</code></pre>

<h4 id="transformationmatrix">TransformationMatrix</h4>

<p>Creates a transformation matrix.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd TransformationMatrix( const Point3f::Simd&amp; scalingOrigin, 
                            const QuaternionSimd&lt;Quaternion&lt;float&gt;&gt;&amp; scalingOrientationQuaternion, 
                            const Vector&lt;float,3&gt;::Simd&amp; scaling,
                            const Point3f::Simd&amp; rotationOrigin, 
                            const QuaternionSimd&lt;Quaternion&lt;float&gt;&gt;&amp; rotationQuaternion, 
                            const Vector&lt;float, 3&gt;::Simd&amp; translation ) noexcept;


</code></pre>

<h4 id="affinetransformationmatrix">AffineTransformationMatrix</h4>

<p>Creates an affine transformation matrix.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, typename U, Internal::SimdType W&gt;
        requires (S::Size &gt; 2) &amp;&amp; (T::Size &gt; 2) &amp;&amp; (W::Size &gt; 2) &amp;&amp; IsFloatingPoint&lt;U&gt; &amp;&amp;
            std::is_same_v&lt;typename S::value_type,U&gt; &amp;&amp; 
                std::is_same_v&lt;typename T::value_type, U&gt; &amp;&amp; 
                std::is_same_v&lt;typename W::value_type, U&gt;
    inline SquareMatrix&lt;U, 4&gt;::Simd AffineTransformationMatrix( const S&amp; scaling,
                                        const T&amp; rotationOrigin,
                                        const QuaternionSimd&lt;Quaternion&lt;U&gt;&gt;&amp; rotationQuaternion,
                                        const W&amp; translation ) noexcept;

</code></pre>

<h4 id="lookto">LookTo</h4>

<p>Creates a view matrix using the left-handed coordinate system for the
provided camera position, camera direction, and up direction.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S,T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; (S::Size == 3)
inline SquareMatrix&lt;typename S::value_type, 4&gt;::Simd LookTo( const S&amp; cameraPosition, 
                                                            const T&amp; cameraDirection, 
                                                            const U&amp; upDirection ) noexcept;
</code></pre>

<h4 id="lookat">LookAt</h4>

<p>Creates a view matrix using the left-handed coordinate system for the
provided camera position, focal point, and up direction.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; ( S::Size == 3 )
inline SquareMatrix&lt;typename S::value_type, 4&gt;::Simd LookAt( const S&amp; cameraPosition, 
                                                            const T&amp; focusPosition, 
                                                            const U&amp; upDirection ) noexcept;
</code></pre>

<h4 id="perspectiveprojection">PerspectiveProjection</h4>

<p>Creates a left-handed perspective projection matrix.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
inline SquareMatrix&lt;T, 4&gt;::Simd PerspectiveProjection( T viewWidth, 
                                                    T viewHeight, 
                                                    T nearZ, 
                                                    T farZ ) noexcept;
</code></pre>

<h4 id="perspectivefovprojection">PerspectiveFovProjection</h4>

<p>Creates a left-handed perspective projection matrix based on a field of view.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
inline SquareMatrix&lt;T, 4&gt;::Simd PerspectiveFovProjection( T fovAngleY, 
                                                        T aspectRatio, 
                                                        T nearZ, 
                                                        T farZ ) noexcept;

</code></pre>

<h4 id="transform-3">Transform</h4>

<p>Applies a transformation matrix to a 3D vector.</p>

<pre><code class="language-C++">inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;::Simd&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;::Simd&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>
<p>Applies a transformation matrix to a 3D coordinate.</p>

<pre><code class="language-C++">inline Point3f::Simd Transform( const Point3f::Simd&amp; p, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Point3f::Simd Transform( const Point3f&amp; p, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Point3f::Simd Transform( const Point3f::Simd&amp; p, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Point3f::Simd Transform( const Point3f&amp; p, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );
</code></pre>

<p>Applies a transformation matrix to a normal.</p>

<pre><code class="language-C++">inline Normal3f::Simd Transform( const Normal3f::Simd&amp; n, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; n, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f::Simd&amp; n, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; n, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>

<h2 id="quaternion">Quaternion</h2>

<p>Quaternions provides a compact representation of rotations.</p>

<p>The <code class="language-plaintext highlighter-rouge">Quaternion</code> template can be used with both single and double precision floating
point types.</p>

<p>Like the tuple templates, there is a <code class="language-plaintext highlighter-rouge">QuaternionSimd</code> template that represents
quaternions loaded into a SIMD register.</p>

<p><code class="language-plaintext highlighter-rouge">Quaternion</code> and <code class="language-plaintext highlighter-rouge">QuaternionSimd</code> supports addition, subtraction, multiplication, 
scalar multiplication and scalar division.</p>

<h3 id="quaternion-member-functions">Quaternion member functions</h3>

<h4 id="constructors">Constructors</h4>

<pre><code class="language-C++">constexpr Quaternion( ) noexcept;
</code></pre>
<p>The default constructor initializes <code class="language-plaintext highlighter-rouge">v.x</code>, <code class="language-plaintext highlighter-rouge">v.y</code>, <code class="language-plaintext highlighter-rouge">v.z</code> and <code class="language-plaintext highlighter-rouge">w</code> to <code class="language-plaintext highlighter-rouge">0.0</code>.</p>

<pre><code class="language-C++">constexpr Quaternion( ValueType xv, ValueType yv, ValueType zv, ValueType wv ) noexcept;
</code></pre>
<p>Initializes <code class="language-plaintext highlighter-rouge">v.x</code> to <code class="language-plaintext highlighter-rouge">xv</code>, <code class="language-plaintext highlighter-rouge">v.y</code> to <code class="language-plaintext highlighter-rouge">yv</code>, <code class="language-plaintext highlighter-rouge">v.z</code> to <code class="language-plaintext highlighter-rouge">zv</code> and <code class="language-plaintext highlighter-rouge">w</code> to <code class="language-plaintext highlighter-rouge">wv</code>.</p>

<pre><code class="language-C++">constexpr Quaternion( const Vector&lt;ValueType,3&gt;&amp; vv, ValueType wv ) noexcept;
</code></pre>

<p>Initializes <code class="language-plaintext highlighter-rouge">v</code> to <code class="language-plaintext highlighter-rouge">xv</code> and <code class="language-plaintext highlighter-rouge">w</code> to <code class="language-plaintext highlighter-rouge">wv</code>.</p>

<pre><code class="language-C++">Quaternion( const Simd&amp; qsimd ) noexcept
</code></pre>
<p>Initializes the quaternion using the values held by <code class="language-plaintext highlighter-rouge">qsimd.simd</code>.</p>

<pre><code class="language-C++">Quaternion( ValueType pitch, ValueType yaw, ValueType roll ) noexcept
</code></pre>
<p>Creates a quaternion based on the pitch, yaw, and roll (Euler angles),
where:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pitch</code> is the angle of rotation around the x-axis, in radians.</li>
  <li><code class="language-plaintext highlighter-rouge">yaw</code> is the angle of rotation around the y-axis, in radians.</li>
  <li><code class="language-plaintext highlighter-rouge">roll</code> is the angle of rotation around the z-axis, in radians.</li>
</ul>

<h3 id="quaternion-functions">Quaternion functions</h3>

<h4 id="dot">Dot</h4>

<p>Calculates the dot product of two quaternions.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T,4&gt;::Simd Dot( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd Dot( const Quaternion&lt;T&gt;&amp; q1, 
                                const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd Dot( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                const Quaternion&lt;T&gt;&amp; q2 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd Dot( const Quaternion&lt;T&gt;&amp; q1, 
                                const Quaternion&lt;T&gt;&amp; q2 ) noexcept;
</code></pre>

<h4 id="length-and-scalarlength-1">Length and ScalarLength</h4>

<p>Calculates the magnitude of a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd Length( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd Length( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarLength( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarLength( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="lengthsquared-and-scalarlengthsquared-1">LengthSquared and ScalarLengthSquared</h4>

<p>Calculates the square of the magnitude of a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd LengthSquared( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd LengthSquared( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarLengthSquared( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarLengthSquared( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="reciprocallength-and-scalarreciprocallength-1">ReciprocalLength and ScalarReciprocalLength</h4>

<p>Calculates the reciprocal of the magnitude of a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd ReciprocalLength( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd ReciprocalLength( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarReciprocalLength( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarReciprocalLength( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="conjugate">Conjugate</h4>

<p>Calculates the conjugate of a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Conjugate( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Normalize( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="normalize-1">Normalize</h4>

<p>Normalizes a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Normalize( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Normalize( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="inverse-1">Inverse</h4>

<p>Calculates the inverse of a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Inverse( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Inverse( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="log-1">Log</h4>

<p>Calculates the natural logarithm of a unit quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Log( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Log( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="slerp">Slerp</h4>

<p>Spherical linear interpolation between two unit quaternions.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                    const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2, 
                                    const typename Vector&lt;T, 4&gt;::Simd&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                    const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2, 
                                    const Vector&lt;T, 4&gt;&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                    const Quaternion&lt;T&gt;&amp; q2, 
                                    const typename Vector&lt;T, 4&gt;::Simd&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                    const Quaternion&lt;T&gt;&amp; q2, 
                                    const Vector&lt;T, 4&gt;&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const Quaternion&lt;T&gt;&amp; q1, 
                                    const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2, 
                                    const typename Vector&lt;T, 4&gt;::Simd&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const Quaternion&lt;T&gt;&amp; q1, 
                                    const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2, 
                                    const Vector&lt;T, 4&gt;&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const Quaternion&lt;T&gt;&amp; q1, 
                                    const Quaternion&lt;T&gt;&amp; q2, 
                                    const typename Vector&lt;T, 4&gt;::Simd&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const Quaternion&lt;T&gt;&amp; q1, 
                                    const Quaternion&lt;T&gt;&amp; q2, 
                                    const Vector&lt;T, 4&gt;&amp; t ) noexcept;

</code></pre>

<h2 id="transforms">Transforms</h2>

<p>A transform is a mapping from vectors to vectors or points to points.</p>

<p>Taking a point, vector, or normal defined with respect to one coordinate frame and 
finding its coordinate values with respect to another coordinate frame is a useful 
capability.</p>

<h3 id="affinetransformation">AffineTransformation</h3>

<p>Affine transformations are transformations that preserves collinearity; where all 
points lying on a line initially, still lie on a line after transformation; and 
ratios of distances, like the midpoint of a line segment, which remains the 
midpoint after transformation. In this sense, affine indicates a special class 
of projective transformations that do not move any objects from the affine space 
\(R^3\) to the plane at infinity or conversely.</p>

<p>Geometric contraction, expansion, dilation, reflection, rotation, shear, similarity 
transformations, spiral similarities, and translation are all affine transformations, 
as are their combinations. In general, an affine transformation is a composition of 
rotations, translations, dilations, and shears.</p>

<p>While an affine transformation preserves proportions on lines, it does not 
necessarily preserve angles or lengths. Any triangle can be transformed 
into any other by an affine transformation, so all triangles are affine and, 
in this sense, affine is a generalization of congruent and similar.</p>

<p>Use the <code class="language-plaintext highlighter-rouge">AffineTransformation</code> class to efficiently transform <code class="language-plaintext highlighter-rouge">Vector3f</code>, <code class="language-plaintext highlighter-rouge">Point3f</code>,
<code class="language-plaintext highlighter-rouge">Normal3f</code>, and <code class="language-plaintext highlighter-rouge">AffineTransformation</code> objects from one coordinate space to another.</p>

<p>The transformation of a <code class="language-plaintext highlighter-rouge">AffineTransformation</code> object, results in an <code class="language-plaintext highlighter-rouge">AffineTransformation</code>
object combining the transformations of both into a single transformation.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Harlinn</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Harlinn</li><li><a class="u-email" href="mailto:espen@harlinn.no">espen@harlinn.no</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Harlinn"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Harlinn</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is my personal site. </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

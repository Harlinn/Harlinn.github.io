<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Fast Linear Algebra Classes for Games and Graphics | Harlinn</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Fast Linear Algebra Classes for Games and Graphics" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is my personal Github site," />
<meta property="og:description" content="This is my personal Github site," />
<link rel="canonical" href="https://harlinn.github.io/Cpp/Cpp/Math/FastLinearAlgebra.html" />
<meta property="og:url" content="https://harlinn.github.io/Cpp/Cpp/Math/FastLinearAlgebra.html" />
<meta property="og:site_name" content="Harlinn" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Fast Linear Algebra Classes for Games and Graphics" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"This is my personal Github site,","headline":"Fast Linear Algebra Classes for Games and Graphics","url":"https://harlinn.github.io/Cpp/Cpp/Math/FastLinearAlgebra.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://harlinn.github.io/feed.xml" title="Harlinn" /><script type="text/javascript" id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="importmap">
        {
            "imports":
            {
            "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.min.js" ,
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
            }
        }
    </script>
</head>
<body><header class="site-header" role="banner">
    <div id="animatedHeader" height="120px" width="100%">
        <script type="x-shader/x-vertex" id="vertexshader">
            attribute float scale;
            void main() {
                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                gl_PointSize = scale * ( 100.0 / - mvPosition.z );
                gl_Position = projectionMatrix * mvPosition;
            }

        </script>

        <script type="x-shader/x-fragment" id="fragmentshader">
            uniform vec3 color;
            void main() {
                if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 )  discard;
                gl_FragColor = vec4( color, 0.8 );
            }
        </script>

        <script type="module">

			import * as THREE from 'three';

			const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;

			let container; 
			let camera, scene, renderer;

			let particles, count = 0;

			let mouseX = 0, mouseY = 0;

			let animatedHeaderHeight = 120;

            let windowHalfX = window.innerWidth / 2;
            let windowHalfY = animatedHeaderHeight/2.0;

			init();

			function init() {

                container = document.querySelector('#animatedHeader');

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;

				scene = new THREE.Scene();

				//

				const numParticles = AMOUNTX * AMOUNTY;

				const positions = new Float32Array( numParticles * 3 );
				const scales = new Float32Array( numParticles );

				let i = 0, j = 0;

				for ( let ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( let iy = 0; iy < AMOUNTY; iy ++ ) {

						positions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x
						positions[ i + 1 ] = 0; // y
						positions[ i + 2 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z

						scales[ j ] = 1;

						i += 3;
						j ++;

					}

				}

				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) );

				const material = new THREE.ShaderMaterial( {

					uniforms: {
						color: { value: new THREE.Color( 0xffffff ) },
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent

				} );

				//

				particles = new THREE.Points( geometry, material );
				scene.add( particles );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize(window.innerWidth, animatedHeaderHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				container.style.touchAction = 'none';
				container.addEventListener( 'pointermove', onPointerMove );

				//

                window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;

				camera.aspect = window.innerWidth / animatedHeaderHeight; 
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, animatedHeaderHeight);

			}

			//

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			//

			function animate() {
				render();

			}

			function render() {

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );

				const positions = particles.geometry.attributes.position.array;
				const scales = particles.geometry.attributes.scale.array;

				let i = 0, j = 0;

				for ( let ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( let iy = 0; iy < AMOUNTY; iy ++ ) {

						positions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.3 ) * 50 ) +
										( Math.sin( ( iy + count ) * 0.5 ) * 50 );

						scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 20 +
										( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 20;

						i += 3;
						j ++;

					}

				}

				particles.geometry.attributes.position.needsUpdate = true;
				particles.geometry.attributes.scale.needsUpdate = true;

				renderer.render( scene, camera );

				count += 0.1;

			}

        </script>

    </div>
  <div class="wrapper"><a class="site-title" rel="author" href="/">Harlinn</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/Cpp/Cpp.html">C++</a><a class="page-link" href="/Databases/Databases.html">Databases</a><a class="page-link" href="/DotNet/DotNet.html">.Net</a><a class="page-link" href="/Java/Java.html">Java</a><a class="page-link" href="/Julia/Julia.html">Julia</a><a class="page-link" href="/Python/Python.html">Python</a><a class="page-link" href="/R/R.html">R</a><a class="page-link" href="/Rust/Rust.html">Rust</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Fast Linear Algebra Classes for Games and Graphics</h1>
  </header>

  <div class="post-content">
    <p>The library contains a set of linear algebra classes and function that are optimized
for games and other graphic intensive apps. The operations are 
implemented using a blend of SIMD and regular C/C++, performing as well as, and sometimes 
outperforming, the <a href="https://github.com/microsoft/DirectXMath">DirectXMath</a>
library.</p>

<p>Itâ€™s used to create the <a href="/Cpp/Harlinn.Windows/Examples/Windows/Graphics/DirectX/MiniEngine/MiniEngine.html">MiniEngine</a>,
providing a moderately complex example of how to use this part of the library.</p>

<p>The classes and functions are designed to make it easier to implement, understand and 
maintain efficient vectorized solutions, and the <a href="#benchmarks">Benchmarks</a> says it all 
when it comes to the efficiency of this implementation.</p>

<ul>
  <li><a href="#vector"><code class="language-plaintext highlighter-rouge">Vector</code></a> is template for fixed size vectors of integer or floating point values.</li>
  <li><a href="#tuple2-tuple3-and-tuple4"><code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code></a> 
are template classes that holds <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code> or <code class="language-plaintext highlighter-rouge">4</code> integer or floating point 
values. They are used to implement specializations of <code class="language-plaintext highlighter-rouge">Vector</code> and other
classes holding <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code> or <code class="language-plaintext highlighter-rouge">4</code> integer or floating point values.
    <ul>
      <li>
        <p><a href="#tuple2-tuple3-tuple4-and-tuplesimd-functions"><code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code>, <code class="language-plaintext highlighter-rouge">Tuple4</code> and <code class="language-plaintext highlighter-rouge">TupleSimd</code> Functions</a></p>
      </li>
      <li><a href="#vector2f-vector3f-vector4f-vector2i-vector3i-vector4i"><code class="language-plaintext highlighter-rouge">Vector2f</code>, <code class="language-plaintext highlighter-rouge">Vector3f</code>, <code class="language-plaintext highlighter-rouge">Vector4f</code>, <code class="language-plaintext highlighter-rouge">Vector2i</code>, <code class="language-plaintext highlighter-rouge">Vector3i</code>, <code class="language-plaintext highlighter-rouge">Vector4i</code></a></li>
      <li><a href="#normal3f-and-normal3i"><code class="language-plaintext highlighter-rouge">Normal3f</code> and <code class="language-plaintext highlighter-rouge">Normal3i</code></a></li>
      <li><a href="#point3f-and-point3i"><code class="language-plaintext highlighter-rouge">Point3f</code> and <code class="language-plaintext highlighter-rouge">Point3i</code></a></li>
    </ul>
  </li>
  <li><a href="#squarematrix"><code class="language-plaintext highlighter-rouge">SquareMatrix</code></a></li>
  <li><a href="#quaternion"><code class="language-plaintext highlighter-rouge">Quaternion</code></a></li>
  <li><a href="#transform"><code class="language-plaintext highlighter-rouge">Transform</code></a></li>
  <li><a href="#benchmarks">Benchmarks</a></li>
</ul>

<p>The purpose of specializations of <a href="SimdOperations.html"><code class="language-plaintext highlighter-rouge">SIMD::Traits&lt;T, N&gt;</code></a> is to have a mechanism for
selecting implementations that are implemented for <code class="language-plaintext highlighter-rouge">T</code> and optimized for <code class="language-plaintext highlighter-rouge">N</code> elements,
for developing the C++ templates classes and template functions that forms the core
of the linear algebra features of the library.</p>

<p>The <a href="SimdOperations.html"><code class="language-plaintext highlighter-rouge">SIMD::Traits&lt;T, N&gt;</code></a> specializations are used to implement a set of C++
classes that simplifies SIMD development. These classes are contained in 
the <code class="language-plaintext highlighter-rouge">HCCVectorMath.h</code> header file.</p>

<p>The library exploits the ability of C++ to create zero-overhead abstractions,
making efficient SIMD code readable:</p>

<pre><code class="language-C++">using Vector = Math::Vector&lt;float, 4&gt;;

Vector v1( 1.0f, 2.0f, 3.f, 1.0f );
Vector v2( 1.0f, 2.0f, 3.f, 1.0f );
Vector v3 = v1 + v2 + v1 + v2 + v1 + v2;

</code></pre>
<p>where the <code class="language-plaintext highlighter-rouge">+</code> operator is implemented as:</p>

<pre><code class="language-C++">template&lt;Internal::TupleType T, 
        Internal::TupleType U, 
        typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT operator + ( const T&amp; lhs, const U&amp; rhs ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Add( Traits::Load( lhs.values.data( ) ), 
                            Traits::Load( rhs.values.data( ) ) );
}
</code></pre>

<p>Which the compiler turns into:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    using Vector = Math::Vector&lt;float, 4&gt;;

    Vector v1( 1.0f, 2.0f, 3.f, 1.0f );
00007FF6C7F162D8  vmovdqu     xmm4,xmmword ptr [__xmm@3f80000040400000400000003f800000 (07FF6C8387F60h)]  
    Vector v2( 1.0f, 2.0f, 3.f, 1.0f );
    Vector v3 = v1 + v2 + v1 + v2 + v1 + v2;
00007FF6C7F162E0  vaddps      xmm0,xmm4,xmm4  
00007FF6C7F162E4  vaddps      xmm1,xmm0,xmm4  
00007FF6C7F162E8  vaddps      xmm2,xmm1,xmm4  
00007FF6C7F162EC  vaddps      xmm3,xmm2,xmm4  
00007FF6C7F162F0  vaddps      xmm6,xmm3,xmm4  
</code></pre></div></div>

<p>The compiler detects that the two vectors are identical, and only
do a single load of the data into xmm4, and then generates 
code for the additions.</p>

<p>The important thing is that <b>there are no unnecessary artifacts</b> caused 
by using the classes.</p>

<p>Rearranging, and grouping, the terms:</p>

<pre><code class="language-C++">Vector v3 = ( v1 + v2 ) + ( v1 + v2 ) + ( v1 + v2 );
</code></pre>

<p>improves the generated code significantly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00007FF6BC1F39E8  vaddps      xmm1,xmm6,xmm6  
00007FF6BC1F39EC  vaddps      xmm0,xmm1,xmm1  
00007FF6BC1F39F0  vaddps      xmm1,xmm0,xmm1 
</code></pre></div></div>
<p>Reducing the number of <code class="language-plaintext highlighter-rouge">vaddps</code> operations to just three.</p>

<p>Doing the same thing using <a href="https://github.com/microsoft/DirectXMath">DirectXMath</a> 
requires a bit more work:</p>

<pre><code class="language-C++">
XMFLOAT4A v1( { 1.0f, 2.0f, 3.f, 1.0f } );
XMFLOAT4A v2( { 1.0f, 2.0f, 3.f, 1.0f } );
auto v1Loaded = XMLoadFloat4A( &amp;v1 );
auto v2Loaded = XMLoadFloat4A( &amp;v2 );
        
auto v3Loaded = XMVectorAdd(
        XMVectorAdd( 
            XMVectorAdd( 
                v1Loaded,
                v2Loaded ),
            v1Loaded ),
        XMVectorAdd( 
            XMVectorAdd( 
                v2Loaded,
                v1Loaded ),
            v2Loaded ) );

</code></pre>

<p>Benchmarking the above <a href="https://github.com/microsoft/DirectXMath">DirectXMath</a> 
code against</p>

<pre><code class="language-C++">`Vector v3 = ( v1 + v2 ) + ( v1 + v2 ) + ( v1 + v2 );`
</code></pre>

<p>yields:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>----------------------------------------------------------------------------------
Benchmark                                        Time             CPU   Iterations
----------------------------------------------------------------------------------
BenchmarkVector2MultipleAdds                  4.36 ns         3.35 ns    224000000
BenchmarkVector2MultipleXMVectorAdd           4.56 ns         3.77 ns    165925926
</code></pre></div></div>

<p>So, there is rarely any overhead to using the library, compared to working directly
with the SIMD compiler intrinsic functions.</p>

<p>Ideally, the compiler would generate optimal code for any computations,
and it usually comes close - and when enabled using the <code class="language-plaintext highlighter-rouge">/arch:AVX</code>, <code class="language-plaintext highlighter-rouge">/arch:AVX2</code>, <code class="language-plaintext highlighter-rouge">/arch:AVX512</code>
or <code class="language-plaintext highlighter-rouge">/arch:AVX10.1</code> switches, it will utilize SIMD operations to improve performance. 
This just requires a rebuild of the solution, and will often improve performance significantly.</p>

<p>Note that AVX was introduced with the Sandy Bridge micro architecture back in 2011, 
while AVX2 came later with the Haswell micro architecture in 2012, and AMD added support
for AVX2 in 2015. So itâ€™s generally safe to assume that any modern server, or workstation,
supports AVX2.</p>

<h2 id="vector">Vector</h2>

<p>Vector is a C++ template class that holds a fixed number of elements:</p>

<pre><code class="language-C++">template&lt;typename ValueT, size_t N&gt;
class alignas( Math::Internal::SIMD::Traits&lt;ValueT,N&gt;::AlignAs ) Vector
{
  ...
};
</code></pre>

<p>The template supports the unary <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">-=</code>, <code class="language-plaintext highlighter-rouge">+=</code>, <code class="language-plaintext highlighter-rouge">*=</code>, <code class="language-plaintext highlighter-rouge">/=</code>, 
and <code class="language-plaintext highlighter-rouge">[]</code> operators. The basic mathematical operators are <code class="language-plaintext highlighter-rouge">constexpr</code> implemented,
allowing code to be evaluated at compile time, while using SIMD instructions at
runtime, but <a href="https://eigen.tuxfamily.org">Eigen</a> and <a href="https://arma.sourceforge.net/">Armadillo</a> 
are far better alternatives for general linear algebra.</p>

<h2 id="tuple2-tuple3-and-tuple4">Tuple2, Tuple3 and Tuple4</h2>

<p>The <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> templates implements most of the magic, 
together with the <code class="language-plaintext highlighter-rouge">TupleSimd</code> template, required to provide an efficient
set of classes and templates that can handle linear algebra for games, 
graphic apps, and other apps that work with two and/or three dimensional data.</p>

<p>The template arguments are the type derived from the template and the type used
to store each coordinateâ€™s value. Since the templates know their derived type, 
the templates can operate on, and return values of the derived type.</p>

<p>When working with data in two dimensions, itâ€™s a common convention that the
type holding two dimensional data has two data fields, <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>. Similarly
a type holding three dimensional data is expected to have three data fields
named <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">Tuple2</code> template fills this role for two dimensional data:</p>
<pre><code class="language-C++">template&lt;class DerivedT, typename T&gt;
class Tuple2 : public Internal::TupleBase
{
public:
  ...
    union
    {
        ArrayType values;
        struct
        {
            value_type x, y;
        };
    };
  ...
};
</code></pre>

<p>where <code class="language-plaintext highlighter-rouge">values</code> is a <code class="language-plaintext highlighter-rouge">std::array&lt;value_type,2&gt;</code> sharing the location of
<code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> in memory. Setting <code class="language-plaintext highlighter-rouge">v.values[0] = 0</code> is the same as <code class="language-plaintext highlighter-rouge">v.x = 0</code>.</p>

<p>The union between <code class="language-plaintext highlighter-rouge">values</code> and <code class="language-plaintext highlighter-rouge">struct { value_type x, y; }</code> is important
as it provides a generic way to access the coordinates held by the object
without explicitly accessing each value through <code class="language-plaintext highlighter-rouge">x</code> or <code class="language-plaintext highlighter-rouge">y</code>.</p>

<p><code class="language-plaintext highlighter-rouge">DerivedT</code> is required to be a class derived from the <code class="language-plaintext highlighter-rouge">Tuple2</code> template,
and <code class="language-plaintext highlighter-rouge">value_type</code> is declared as <code class="language-plaintext highlighter-rouge">using value_type = T;</code>.</p>

<p>Similarly the <code class="language-plaintext highlighter-rouge">Tuple3</code> template fills this role for three dimensional data:</p>

<pre><code class="language-C++">template&lt;class DerivedT, typename T&gt;
class Tuple3 : public Internal::TupleBase
{
public:
  ...
    union
    {
        ArrayType values;
        struct
        {
            value_type x, y, z;
        };
    };
  ...
};
</code></pre>
<p>and here <code class="language-plaintext highlighter-rouge">values</code> is a <code class="language-plaintext highlighter-rouge">std::array&lt;value_type,3&gt;</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Tuple4</code> adds an additional field <code class="language-plaintext highlighter-rouge">w</code>, and uses <code class="language-plaintext highlighter-rouge">std::array&lt;value_type,4&gt;</code>
for the values array.</p>

<p>The <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> templates are derived from the
empty <code class="language-plaintext highlighter-rouge">Internal::TupleBase</code> struct.</p>

<pre><code class="language-C++">namespace Internal
{
    struct TupleBase
    { };
}
</code></pre>
<p>This provides a mechanism used to distinguish between types derived from
<code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code>; and types that are not:</p>

<pre><code class="language-C++">namespace Internal
{
    template&lt;typename T&gt;
    concept TupleType = std::is_base_of_v&lt;TupleBase, T&gt;;
}
</code></pre>

<p>To use SIMD on the Intel/AMD x64 architecture, data must, as mentioned,
be loaded into a SIMD type that is an abstract representation of an
AVX or SSE4 register. The <code class="language-plaintext highlighter-rouge">TupleSimd</code> template represents SIMD types
using one of the <a href="SimdOperations.html"><code class="language-plaintext highlighter-rouge">SIMD::Traits</code></a> specializations combined with
a tuple type.</p>

<pre><code class="language-C++">template&lt;typename TraitsT, typename TupleT&gt;
class TupleSimd : public Internal::TupleSimdBase
{
  ...    
};
</code></pre>
<p><code class="language-plaintext highlighter-rouge">TupleSimd</code> fills this role for each of the <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> 
template classes.</p>

<pre><code class="language-C++">template&lt;class DerivedT, typename T&gt;
class Tuple3 : public Internal::TupleBase
{
public:
    using DerivedType = DerivedT;
  ...
    using Simd = TupleSimd&lt;Traits, DerivedType&gt;;
  ...
};
</code></pre>

<p>The above definition of <code class="language-plaintext highlighter-rouge">Tuple3::Simd</code> ensures that each class
derived from <code class="language-plaintext highlighter-rouge">Tuple3</code> gets a distinct <code class="language-plaintext highlighter-rouge">Tuple3::Simd</code> C++ type.</p>

<h3 id="tuple2-tuple3-and-tuple4-implementation-details">Tuple2, Tuple3 and Tuple4 implementation details</h3>

<p><code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> have similar implementations, following
the same pattern:</p>

<pre><code class="language-C++">template&lt;typename DerivedT, typename T&gt;
class Tuple3 : public Internal::TupleBase
{
</code></pre>

<p><code class="language-plaintext highlighter-rouge">Internal::TupleBase</code> is used as the base class for the 
<code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> enabling the use of <a href="https://en.cppreference.com/w/cpp/types/is_base_of"><code class="language-plaintext highlighter-rouge">std::is_base_of_v&lt;,&gt;</code></a>
to distinguish between types that are derived from <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code>
and those that are not, and this is used to ensure that the templates designed for 
<code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> will only be enabled for classes derived from either of them.</p>

<p>Inside the template definition, <code class="language-plaintext highlighter-rouge">DerivedType</code> is defined as the class or struct derived from 
the <code class="language-plaintext highlighter-rouge">Tuple3</code> template, together with <code class="language-plaintext highlighter-rouge">value_type</code> and <code class="language-plaintext highlighter-rouge">size_type</code>.</p>

<pre><code class="language-C++">public:
    using DerivedType = DerivedT;
    using value_type = T;
    using size_type = size_t;
</code></pre>

<p><code class="language-plaintext highlighter-rouge">Tuple3</code> holds three values, <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>, as its main purpose is to 
be a storage for three dimensional coordinates, and <code class="language-plaintext highlighter-rouge">Size</code> specifies the
number of values that <code class="language-plaintext highlighter-rouge">Tuple3</code> holds.</p>

<pre><code class="language-C++">    static constexpr size_type Size = 3;

    using Traits = SIMD::Traits&lt;value_type, Size&gt;;
    using SIMDType = typename Traits::SIMDType;
</code></pre>
<p>Above <code class="language-plaintext highlighter-rouge">Traits</code> is defined for <code class="language-plaintext highlighter-rouge">value_type</code> and <code class="language-plaintext highlighter-rouge">Size</code>, selecting
the <code class="language-plaintext highlighter-rouge">SIMD::Traits</code> specialization that fits the requirements for 
<code class="language-plaintext highlighter-rouge">Tuple3</code>.</p>

<p>Next <code class="language-plaintext highlighter-rouge">ArrayType</code> is defined:</p>

<pre><code class="language-C++">    using ArrayType = typename Traits::ArrayType;
</code></pre>

<p>This is the same as <code class="language-plaintext highlighter-rouge">std::array&lt;value_type,Size&gt;</code>, and while <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>
is the common notation for three dimensional information, <code class="language-plaintext highlighter-rouge">values</code>, 
as defined below, is more convenient for developing templates 
that will work with <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code>, <code class="language-plaintext highlighter-rouge">Tuple4</code> and any class derived from 
either of them.</p>

<p>The mathematical operations are performed using the <code class="language-plaintext highlighter-rouge">Simd</code> 
type which holds a SIMD vector using the <code class="language-plaintext highlighter-rouge">TupleSimd</code> instantiated
for the <code class="language-plaintext highlighter-rouge">Traits</code> and the class derived from the <code class="language-plaintext highlighter-rouge">Tuple3</code> template,
ensuring that each derived class gets a unique <code class="language-plaintext highlighter-rouge">TupleSimd</code> C++ type.</p>

<pre><code class="language-C++">    using Simd = TupleSimd&lt;Traits, DerivedType&gt;;
</code></pre>
<p>The data fields of <code class="language-plaintext highlighter-rouge">Tuple3</code>:</p>
<pre><code class="language-C++">    union
    {
        ArrayType values;
        struct
        {
            value_type x, y, z;
        };
    };
</code></pre>
<p>The default constructor ensures that <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> are initialized to
<code class="language-plaintext highlighter-rouge">0</code>.</p>

<pre><code class="language-C++">    Tuple3( ) noexcept
            : x{}, y{}, z{}
    { }

    Tuple3( value_type xv, value_type yv, value_type zv ) noexcept
        : x( xv ), y( yv ), z( zv )
    { }

</code></pre>

<p>The next constructor initializes a <code class="language-plaintext highlighter-rouge">Tuple3</code> from a compatible <code class="language-plaintext highlighter-rouge">TupleSimd</code>,
which is any <code class="language-plaintext highlighter-rouge">TupleSimd</code> instantiated for the same <code class="language-plaintext highlighter-rouge">SIMD::Traits</code> specialization
as <code class="language-plaintext highlighter-rouge">Tuple3</code>. <code class="language-plaintext highlighter-rouge">SIMD::Traits</code> has a <code class="language-plaintext highlighter-rouge">ToArray</code> function that stores the values
in the SIMD type in a <code class="language-plaintext highlighter-rouge">std::array&lt;&gt;</code> with the same type as <code class="language-plaintext highlighter-rouge">ArrayType</code> and 
returns the data.</p>

<pre><code class="language-C++">
    template&lt;Internal::SimdType T&gt;
        requires std::is_same_v&lt;Traits, typename T::Traits&gt;
    Tuple3( const T&amp; other ) noexcept
        : values( Traits::ToArray( other.simd ) )
    { }

    template&lt;Internal::SimdType T&gt;
        requires std::is_same_v&lt;Traits, typename T::Traits&gt;
    DerivedType&amp; operator = ( const T&amp; other ) noexcept
    {
        values = Traits::ToArray( other.simd );
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    constexpr bool operator == ( const Tuple3&amp; other ) const noexcept
    {
        return IsSameValue( x, other.x ) &amp;&amp; IsSameValue( y, other.y ) 
                            &amp;&amp; IsSameValue( z, other.z );
    }
    constexpr bool operator != ( const Tuple3&amp; other ) const noexcept
    {
        return !IsSameValue( x, other.x ) || !IsSameValue( y, other.y ) 
                            || !IsSameValue( z, other.z );
    }

</code></pre>
<p>Compare the <code class="language-plaintext highlighter-rouge">Tuple3</code> with a compatible <code class="language-plaintext highlighter-rouge">TupleSimd</code>:</p>

<pre><code class="language-C++">
    template&lt;Internal::SimdType T&gt;
        requires std::is_same_v&lt;Traits, typename T::Traits&gt;
    bool operator == ( const T&amp; other ) const noexcept
    {
        return Traits::Equals( Traits::Load( values.data( ) ), other.simd );
    }

    template&lt;Internal::SimdType T&gt;
        requires std::is_same_v&lt;Traits, typename T::Traits&gt;
    bool operator != ( const T&amp; other ) const noexcept
    {
        return Traits::Equals( Traits::Load( values.data( ) ), other.simd ) == false;
    }

</code></pre>
<p>Negation loads the data of <code class="language-plaintext highlighter-rouge">Tuple3</code> into a <code class="language-plaintext highlighter-rouge">SIMDType</code>, calls <code class="language-plaintext highlighter-rouge">Traits::Negate</code> returning 
the result as a <code class="language-plaintext highlighter-rouge">Tuple3::Simd</code>, the <code class="language-plaintext highlighter-rouge">TupleSimd</code> specialization for
this <code class="language-plaintext highlighter-rouge">Tuple3</code> type:</p>

<pre><code class="language-C++">    Simd operator-( ) const noexcept
    {
        return Traits::Negate( Traits::Load( values.data( ) ) );
    }

</code></pre>
<p><code class="language-plaintext highlighter-rouge">Tuple3</code> overloads the <code class="language-plaintext highlighter-rouge">+=</code>, <code class="language-plaintext highlighter-rouge">-=</code>, <code class="language-plaintext highlighter-rouge">*=</code> and <code class="language-plaintext highlighter-rouge">/=</code> operators, and each operator
accepts a <code class="language-plaintext highlighter-rouge">const</code> reference to a <code class="language-plaintext highlighter-rouge">Simd</code>, <code class="language-plaintext highlighter-rouge">const</code> reference to a <code class="language-plaintext highlighter-rouge">Tuple3</code>, or 
a scalar - note that the overloads returns a reference to <code class="language-plaintext highlighter-rouge">DerivedType</code>:</p>

<pre><code class="language-C++">
    DerivedType&amp; operator += ( const Simd&amp; other ) noexcept
    {
        values = Traits::ToArray( Traits::Add( Traits::Load( values ), other.simd ) );
        return static_cast&lt; DerivedType&amp; &gt;(*this );
    }

    DerivedType&amp; operator += ( const Tuple3&amp; other ) noexcept
    {
        x += other.x;
        y += other.y;
        z += other.z;
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    DerivedType&amp; operator += ( const value_type&amp; value ) noexcept
    {
        x += value;
        y += value;
        z += value;
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    DerivedType&amp; operator -= ( const Simd&amp; other ) noexcept
    {
        values = Traits::ToArray( Traits::Sub( Traits::Load( values ), other.simd ) );
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    DerivedType&amp; operator -= ( const Tuple3&amp; other ) noexcept
    {
        x -= other.x;
        y -= other.y;
        z -= other.z;
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    DerivedType&amp; operator -= ( const value_type&amp; value ) noexcept
    {
        x -= value;
        y -= value;
        z -= value;
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    DerivedType&amp; operator *= ( const Simd&amp; other ) noexcept
    {
        values = Traits::ToArray( Traits::Mul( Traits::Load( values ), other.simd ) );
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    DerivedType&amp; operator *= ( const Tuple3&amp; other ) noexcept
    {
        x *= other.x;
        y *= other.y;
        z *= other.z;
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    DerivedType&amp; operator *= ( const value_type&amp; value ) noexcept
    {
        x *= value;
        y *= value;
        z *= value;
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }


    DerivedType&amp; operator /= ( const Simd&amp; other ) noexcept
    {
        values = Traits::ToArray( Traits::Div( Traits::Load( values ), other.simd ) );
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    DerivedType&amp; operator /= ( const Tuple3&amp; other ) noexcept
    {
        x /= other.x;
        y /= other.y;
        z /= other.z;
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    DerivedType&amp; operator /= ( const value_type&amp; value ) noexcept
    {
        x /= value;
        y /= value;
        z /= value;
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }
</code></pre>
<p>Since <code class="language-plaintext highlighter-rouge">Tuple3</code> is a container, it implements common container member functions:</p>

<pre><code class="language-C++">    const_reference operator[]( size_t index ) const noexcept
    {
        return values[ index ];
    }

    reference operator[]( size_t index ) noexcept
    {
        return values[ index ];
    }

    const_pointer data( ) const noexcept
    {
        return values.data( );
    }
    pointer data( ) noexcept
    {
        return values.data( );
    }

    constexpr size_t size( ) const noexcept
    {
        return Size;
    }

    const_reference front( ) const noexcept
    {
        return values.front( );
    }
    reference front( ) noexcept
    {
        return values.front( );
    }

    const_reference back( ) const noexcept
    {
        return values.back( );
    }
    reference back( ) noexcept
    {
        return values.back( );
    }

    const_iterator begin( ) const noexcept
    {
        return values.begin( );
    }
    const_iterator cbegin( ) const noexcept
    {
        return values.cbegin( );
    }
    iterator begin( ) noexcept
    {
        return values.begin( );
    }
    const_iterator end( ) const noexcept
    {
        return values.end( );
    }
    const_iterator cend( ) const noexcept
    {
        return values.cend( );
    }
    iterator end( ) noexcept
    {
        return values.end( );
    }
    const_reverse_iterator rbegin( ) const noexcept
    {
        return values.rbegin( );
    }
    reverse_iterator rbegin( ) noexcept
    {
        return values.rbegin( );
    }
    const_reverse_iterator rend( ) const noexcept
    {
        return values.rend( );
    }
    reverse_iterator rend( ) noexcept
    {
        return values.rend( );
    }
</code></pre>
<p>The above provides a reasonable level of integration with the standard C++ library.</p>

<p>Calling the <code class="language-plaintext highlighter-rouge">Assign</code> member functions from derived classes can be more convenient
than calling <code class="language-plaintext highlighter-rouge">Base::operator = ( arrayOfData )</code>.</p>

<pre><code class="language-C++">    void Assign( value_type xv, value_type yv, value_type zv ) noexcept
    {
        x = xv;
        y = yv;
        z = zv;
    }
    void Assign( const ArrayType&amp; src ) noexcept
    {
        values = src;
    }
    void Assign( SIMDType src ) noexcept
    {
        values = Traits::ToArray( src );
    }
</code></pre>

<p>The ability to check for <code class="language-plaintext highlighter-rouge">NaN</code> or infinity:</p>

<pre><code class="language-C++">
    bool HasNaN( ) const noexcept
    {
        return std::isnan( x ) || std::isnan( y ) || std::isnan( z );
    }

    bool IsFinite( ) const noexcept
    {
        return std::isfinite( x ) &amp;&amp; std::isfinite( y ) &amp;&amp; std::isfinite( z );
    }

    bool IsInfinite( ) const noexcept
    {
        return std::isinf( x ) || std::isinf( y ) || std::isinf( z );
    }

};
</code></pre>

<p>The library defines two internal concepts. <code class="language-plaintext highlighter-rouge">Internal::TupleType</code> and <code class="language-plaintext highlighter-rouge">Internal::SimdType</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> matches the <code class="language-plaintext highlighter-rouge">Internal::TupleType</code> concept, while
any <code class="language-plaintext highlighter-rouge">TupleSimd</code> derived type matches the <code class="language-plaintext highlighter-rouge">Internal::SimdType</code> concept.</p>

<p>In the code below, <code class="language-plaintext highlighter-rouge">Internal::IsCompatible&lt;T,U&gt;</code> is used to verify that
<code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code> are compatible types using the same <code class="language-plaintext highlighter-rouge">SIMD::Traits</code> specialization.</p>

<p>The first overload will be used when both arguments are compatible <code class="language-plaintext highlighter-rouge">TupleSimd</code>
based objects, so the implementation can perform the addition without
any loading of values into a SIMD datatype/register.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T,U&gt;
inline T operator + ( const T&amp; lhs, const U&amp; rhs ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Add( lhs.simd, rhs.simd );
}
</code></pre>

<p>The second overload accepts <code class="language-plaintext highlighter-rouge">TupleSimd</code> for the left hand argument,
and any compatible <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> or <code class="language-plaintext highlighter-rouge">Tuple4</code> as its right hand argument.</p>

<p>The implementation loads the data from the tuple type, before performing
the addition, returning <code class="language-plaintext highlighter-rouge">T</code> which is a <code class="language-plaintext highlighter-rouge">TupleSimd</code> based type.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T operator + ( const T&amp; lhs, const U&amp; rhs ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Add( lhs.simd, Traits::Load( rhs.values.data( ) ) );
}
</code></pre>
<p>The third overload accepts the same type of arguments as the second,
but takes a <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> or <code class="language-plaintext highlighter-rouge">Tuple4</code> as its left hand argument,
and <code class="language-plaintext highlighter-rouge">TupleSimd</code> for the right hand argument.</p>

<p>This time the contents of <code class="language-plaintext highlighter-rouge">lhs</code> gets loaded before performing the addition.</p>
<pre><code class="language-C++">template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T operator + ( const U&amp; lhs, const T&amp; rhs ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Add( Traits::Load( lhs.values.data( ) ), rhs.simd );
}
</code></pre>
<p>The fourth, and last, overload, accepts compatible <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> or <code class="language-plaintext highlighter-rouge">Tuple4</code>
for both the left hand side and the right hand side of the addition, loading data
for both arguments before performing the addition.</p>
<pre><code class="language-C++">template&lt;Internal::TupleType T, Internal::TupleType U, 
                            typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT operator + ( const T&amp; lhs, const U&amp; rhs ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Add( Traits::Load( lhs.values.data( ) ), 
                                Traits::Load( rhs.values.data( ) ) );
}

</code></pre>

<p>Loading to and storing from the SIMD types is done using the <code class="language-plaintext highlighter-rouge">values</code> field of
the <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> types, so they can all share the same
operator and function implementations:</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Round( const T&amp; t ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Round( t.simd );
}
template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Round( const T&amp; t ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Round( Traits::Load( t.values.data( ) ) );
}

</code></pre>

<p>The operators and functions nearly always return a <code class="language-plaintext highlighter-rouge">TupleSimd</code> based type,
ensuring that data is only loaded into a SIMD type when necessary.</p>

<p>The following operations are currently supported for <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> 
and <code class="language-plaintext highlighter-rouge">Tuple4</code>:</p>

<p><code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, unary <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>,
<code class="language-plaintext highlighter-rouge">+=</code>, <code class="language-plaintext highlighter-rouge">-=</code>, <code class="language-plaintext highlighter-rouge">*=</code>, <code class="language-plaintext highlighter-rouge">/=</code>, <code class="language-plaintext highlighter-rouge">Abs</code>, <code class="language-plaintext highlighter-rouge">Min</code>, <code class="language-plaintext highlighter-rouge">Max</code>, <code class="language-plaintext highlighter-rouge">Sqr</code>, <code class="language-plaintext highlighter-rouge">Ceil</code>, <code class="language-plaintext highlighter-rouge">Floor</code>, <code class="language-plaintext highlighter-rouge">Round</code>, 
<code class="language-plaintext highlighter-rouge">Trunc</code>, <code class="language-plaintext highlighter-rouge">Lerp</code>, <code class="language-plaintext highlighter-rouge">Saturate</code>, <code class="language-plaintext highlighter-rouge">Sqrt</code>, <code class="language-plaintext highlighter-rouge">FMA</code>, <code class="language-plaintext highlighter-rouge">FMSub</code>, <code class="language-plaintext highlighter-rouge">Sin</code>, <code class="language-plaintext highlighter-rouge">Cos</code>, <code class="language-plaintext highlighter-rouge">Tan</code>, 
<code class="language-plaintext highlighter-rouge">ASin</code>, <code class="language-plaintext highlighter-rouge">ACos</code>, <code class="language-plaintext highlighter-rouge">ATan</code>, <code class="language-plaintext highlighter-rouge">ATan2</code>, <code class="language-plaintext highlighter-rouge">SinH</code>, <code class="language-plaintext highlighter-rouge">CosH</code>, <code class="language-plaintext highlighter-rouge">TanH</code>, <code class="language-plaintext highlighter-rouge">ASinH</code>, <code class="language-plaintext highlighter-rouge">ACosH</code>, 
<code class="language-plaintext highlighter-rouge">ATanH</code>, <code class="language-plaintext highlighter-rouge">Log</code>, <code class="language-plaintext highlighter-rouge">Log1P</code>, <code class="language-plaintext highlighter-rouge">Log10</code>, <code class="language-plaintext highlighter-rouge">Log2</code>, <code class="language-plaintext highlighter-rouge">Exp</code>, <code class="language-plaintext highlighter-rouge">Exp10</code>, <code class="language-plaintext highlighter-rouge">Exp2</code>, <code class="language-plaintext highlighter-rouge">ExpM1</code>, 
<code class="language-plaintext highlighter-rouge">Pow</code>, <code class="language-plaintext highlighter-rouge">Dot</code>, <code class="language-plaintext highlighter-rouge">Hypot</code>, <code class="language-plaintext highlighter-rouge">Permute</code>, <code class="language-plaintext highlighter-rouge">Cross</code>, <code class="language-plaintext highlighter-rouge">LengthSquared</code>, <code class="language-plaintext highlighter-rouge">Length</code>
<code class="language-plaintext highlighter-rouge">Normalize</code>, <code class="language-plaintext highlighter-rouge">ReciprocalLength</code>, <code class="language-plaintext highlighter-rouge">DistanceSquared</code>, <code class="language-plaintext highlighter-rouge">Distance</code>, <code class="language-plaintext highlighter-rouge">HProd</code>
<code class="language-plaintext highlighter-rouge">HSum</code>, <code class="language-plaintext highlighter-rouge">DifferenceOfProducts</code>, <code class="language-plaintext highlighter-rouge">SumOfProducts</code></p>

<h3 id="tuple2-tuple3-tuple4-and-tuplesimd-functions">Tuple2, Tuple3, Tuple4 and TupleSimd Functions</h3>

<ul>
  <li><a href="#hsum-and-scalarhsum">HSum and ScalarHSum</a></li>
  <li><a href="#hprod-and-scalarhprod">HProd and ScalarHProd</a></li>
  <li><a href="#abs">Abs</a></li>
  <li><a href="#min">Min</a></li>
  <li><a href="#max">Max</a></li>
  <li><a href="#sqr">Sqr</a></li>
  <li><a href="#ceil">Ceil</a></li>
  <li><a href="#floor">Floor</a></li>
  <li><a href="#round">Round</a></li>
  <li><a href="#trunc">Trunc</a></li>
  <li><a href="#lerp">Lerp</a></li>
  <li><a href="#clamp">Clamp</a></li>
  <li><a href="#saturate">Saturate</a></li>
  <li><a href="#sqrt">Sqrt</a></li>
  <li><a href="#reciprocalsqrt">ReciprocalSqrt</a></li>
  <li><a href="#reciprocal">Reciprocal</a></li>
  <li><a href="#fma">FMA</a></li>
  <li><a href="#fmsub">FMSub</a></li>
  <li><a href="#fmaddsub">FMAddSub</a></li>
  <li><a href="#fmsubadd">FMSubAdd</a></li>
  <li><a href="#fnmadd">FNMAdd</a></li>
  <li><a href="#fnmsub">FNMSub</a></li>
  <li><a href="#sin">Sin</a></li>
  <li><a href="#cos">Cos</a></li>
  <li><a href="#tan">Tan</a></li>
  <li><a href="#asin">ASin</a></li>
  <li><a href="#acos">ACos</a></li>
  <li><a href="#atan">ATan</a></li>
  <li><a href="#atan2">ATan2</a></li>
  <li><a href="#modangles">ModAngles</a></li>
  <li><a href="#addangles">AddAngles</a></li>
  <li><a href="#subtractangles">SubtractAngles</a></li>
  <li><a href="#sinh">SinH</a></li>
  <li><a href="#cosh">CosH</a></li>
  <li><a href="#tanh">TanH</a></li>
  <li><a href="#asinh">ASinH</a></li>
  <li><a href="#acosh">ACosH</a></li>
  <li><a href="#atanh">ATanH</a></li>
  <li><a href="#log">Log</a></li>
  <li><a href="#log1p">Log1P</a></li>
  <li><a href="#log10">Log10</a></li>
  <li><a href="#log2">Log2</a></li>
  <li><a href="#exp">Exp</a></li>
  <li><a href="#exp10">Exp10</a></li>
  <li><a href="#exp2">Exp2</a></li>
  <li><a href="#expm1">ExpM1</a></li>
  <li><a href="#pow">Pow</a></li>
  <li><a href="#hypot">Hypot</a></li>
  <li><a href="#hermite">Hermite</a></li>
  <li><a href="#dot-and-scalardot">Dot and ScalarDot</a></li>
  <li><a href="#absdot-and-scalarabsdot">AbsDot and ScalarAbsDot</a></li>
  <li><a href="#cross">Cross</a></li>
  <li><a href="#lengthsquared-and-scalarlengthsquared">LengthSquared and ScalarLengthSquared</a></li>
  <li><a href="#length-and-scalarlength">Length and ScalarLength</a></li>
  <li><a href="#normalize">Normalize</a></li>
  <li><a href="#reciprocallength-and-scalarreciprocallength">ReciprocalLength and ScalarReciprocalLength</a></li>
  <li><a href="#distancesquared-and-scalardistancesquared">DistanceSquared and ScalarDistanceSquared</a></li>
  <li><a href="#distance-and-scalardistance">Distance and ScalarDistance</a></li>
  <li><a href="#inbounds">InBounds</a></li>
  <li><a href="#clamplength">ClampLength</a></li>
  <li><a href="#reflect">Reflect</a></li>
  <li><a href="#refract">Refract</a></li>
  <li><a href="#orthogonal">Orthogonal</a></li>
  <li><a href="#differenceofproducts">DifferenceOfProducts</a></li>
  <li><a href="#sumofproducts">SumOfProducts</a></li>
  <li><a href="#barycentric">BaryCentric</a></li>
  <li><a href="#catmullrom">CatmullRom</a></li>
  <li><a href="#mincomponentvalue">MinComponentValue</a></li>
  <li><a href="#maxcomponentvalue">MaxComponentValue</a></li>
  <li><a href="#mincomponentindex">MinComponentIndex</a></li>
  <li><a href="#maxcomponentindex">MaxComponentIndex</a></li>
</ul>

<p>The functions that work with the <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code>, <code class="language-plaintext highlighter-rouge">Tuple4</code> and <code class="language-plaintext highlighter-rouge">TupleSimd</code> types
generally returns a <code class="language-plaintext highlighter-rouge">TupleSimd</code> holding the result of the operation.</p>

<p>There are usually several overloads for each function, allowing the values
held by the <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> derived types to be automatically
loaded into a SIMD type/register.</p>

<p>Functions that calculate a single scalar value, returns a <code class="language-plaintext highlighter-rouge">TupleSimd</code> where every
element holds the calculated value. These functions also have an implementation that 
returns the scalar as single value. For instance, <code class="language-plaintext highlighter-rouge">Dot</code> returns a <code class="language-plaintext highlighter-rouge">TupleSimd</code>, while <code class="language-plaintext highlighter-rouge">ScalarDot</code> returns
a floating point value of the same type as a single element from the <code class="language-plaintext highlighter-rouge">TupleSimd</code> type.</p>

<h4 id="hsum-and-scalarhsum">HSum and ScalarHSum</h4>

<p>Calculates the horizontal sum of the elements in the vector.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T HSum( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
inline ResultT ScalarHSum( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT HSum( const T&amp; t ) noexcept;

</code></pre>

<h4 id="hprod-and-scalarhprod">HProd and ScalarHProd</h4>

<p>Calculates the horizontal product of the elements in the vector.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T HProd( const T&amp; t ) noexcept;

template&lt;Internal::SimdType T&gt;
inline auto ScalarHProd( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
inline ResultT ScalarHProd( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT HProd( const T&amp; t ) noexcept;
</code></pre>

<h4 id="abs">Abs</h4>

<p>Computes the absolute value of each element held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Abs( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Abs( const T&amp; t ) noexcept;
</code></pre>

<h4 id="min">Min</h4>

<p>Makes a comparison between the elements held by the two arguments, and 
returns a TupleSimd containing the smallest elements.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Min( const T&amp; lhs, const U&amp; rhs ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Min( const T&amp; lhs, const U&amp; rhs ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Min( const U&amp; lhs, const T&amp; rhs ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, 
                typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Min( const T&amp; lhs, const U&amp; rhs ) noexcept;
</code></pre>

<h4 id="max">Max</h4>

<p>Makes a comparison between the elements held by the two arguments, and 
returns a TupleSimd containing the largest elements.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Max( const T&amp; lhs, const U&amp; rhs ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Max( const T&amp; lhs, const U&amp; rhs ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Max( const U&amp; lhs, const T&amp; rhs ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, 
                typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Max( const T&amp; lhs, const U&amp; rhs ) noexcept;
</code></pre>

<h4 id="sqr">Sqr</h4>

<p>Computes the square value of each element held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Sqr( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Sqr( const T&amp; t ) noexcept;
</code></pre>

<h4 id="ceil">Ceil</h4>

<p>Computes the ceiling of each element held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Ceil( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Ceil( const T&amp; t ) noexcept;
</code></pre>

<h4 id="floor">Floor</h4>

<p>Computes the floor of each element held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Floor( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Floor( const T&amp; t ) noexcept;
</code></pre>

<h4 id="round">Round</h4>

<p>Rounds each element held by the argument towards the nearest even integer.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Round( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Round( const T&amp; t ) noexcept;
</code></pre>

<h4 id="trunc">Trunc</h4>

<p>Rounds each element held by the argument to the nearest integer in the direction of zero.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Trunc( const T&amp; t ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Trunc( const T&amp; t ) noexcept;
</code></pre>

<h4 id="lerp">Lerp</h4>

<p>Calculates the linear interpolation between the
the elements of <code class="language-plaintext highlighter-rouge">a</code> and the elements of <code class="language-plaintext highlighter-rouge">b</code>, for elements of
<code class="language-plaintext highlighter-rouge">c</code> is inside [0,1), or the linear extrapolation for elements
in <code class="language-plaintext highlighter-rouge">c</code> outside [0,1).</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt; &amp;&amp; Internal::IsCompatible&lt;T, U&gt; 
inline T Lerp( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Lerp( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U Lerp( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, 
                                    typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT Lerp( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, 
                                    typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT Lerp( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="clamp">Clamp</h4>

<p>Returns the elements of v, if the elements are between their
respective boundaries specified the elements of lowerBounds
and the elements of upperBounds, otherwise the value of nearest
boundary is returned.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, 
                                        typename ResultT = typename S::Simd&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT Clamp( const S&amp; v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, 
                                        typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt; &amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT Clamp( NumberT v, const T&amp; lowerBounds, const U&amp; upperBounds ) noexcept;
</code></pre>

<h4 id="saturate">Saturate</h4>

<p>Saturates the elements of v to the range 0.0 to 1.0.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Saturate( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Saturate( const T&amp; v ) noexcept;
</code></pre>

<h4 id="sqrt">Sqrt</h4>

<p>Calculates the square root of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Sqrt( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Sqrt( const T&amp; v ) noexcept;
</code></pre>

<h4 id="reciprocalsqrt">ReciprocalSqrt</h4>

<p>Calculates the reciprocal square root of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ReciprocalSqrt( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ReciprocalSqrt( const T&amp; v ) noexcept;
</code></pre>

<h4 id="reciprocal">Reciprocal</h4>

<p>Calculates the reciprocal of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Reciprocal( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Reciprocal( const T&amp; v ) noexcept;
</code></pre>

<h4 id="fma">FMA</h4>

<p>Multiplies the corresponding elements of a and b, adding the result to the corresponding element of c.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMA( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, 
                                    typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMA( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMA( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, 
                                    typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMA( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, 
                                        typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMA( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="fmsub">FMSub</h4>

<p>Performs a set of multiply-subtract computation on a, b, and c. Corresponding values in two operands, 
a and b, are multiplied and the infinite precision intermediate results are obtained. From the 
infinite precision intermediate results, the values in the third operand, c, are subtracted. 
The final results are rounded to the nearest floating point values.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="fmaddsub">FMAddSub</h4>

<p>Performs a set of multiply-add-subtract computation on a, b, and c. Corresponding values in two operands, a and b, are 
multiplied and infinite precision intermediate results are obtained. The odd values in the third operand, 
c, are added to the intermediate results while the even values are subtracted from them. The final results 
are rounded to the nearest floating point values.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMAddSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMAddSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMAddSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMAddSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMAddSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="fmsubadd">FMSubAdd</h4>

<p>Performs a set of multiply-subtract-add computation on a, b, and c. Corresponding values in two operands, a and b, 
are multiplied and infinite precision intermediate results are obtained. The odd values in the third 
operand, c, are subtracted from the intermediate results while the even values are added to them. 
The final results are rounded to the nearest floating point values.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSubAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSubAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSubAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSubAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FMSubAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="fnmadd">FNMAdd</h4>

<p>Performs a set of negated multiply-add computation on a, b, and c. Corresponding values in two operands, 
a and b, are multiplied and the negated infinite precision intermediate results are added to 
the values in the third operand, c, after which the final results are rounded to the nearest 
floating point values.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMAdd( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMAdd( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMAdd( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="fnmsub">FNMSub</h4>

<p>Performs a set of negated multiply-subtract computation on a, b, and c. The values in two operands, a and b, 
are multiplied and the negated infinite precision intermediate result is obtained. From this negated 
intermediate result, the value in the third operand, c, is subtracted. The final result is rounded 
to the nearest floating point value.</p>

<pre><code class="language-C++">template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMSub( NumberT a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::SimdType T, Internal::TupleType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::SimdType U&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;typename NumberT, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires std::is_arithmetic_v&lt;NumberT&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMSub( const T&amp; a, NumberT b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline S FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline T FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline U FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd &gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;T, U&gt;
inline ResultT FNMSub( const S&amp; a, const T&amp; b, const U&amp; c ) noexcept;
</code></pre>

<h4 id="sin">Sin</h4>

<p>Calculates the sine of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Sin( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Sin( const T&amp; v ) noexcept;
</code></pre>

<h4 id="cos">Cos</h4>

<p>Calculates the cosine of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Cos( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Cos( const T&amp; v ) noexcept;
</code></pre>

<h4 id="tan">Tan</h4>

<p>Calculates the tangent of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Tan( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Tan( const T&amp; v ) noexcept;
</code></pre>

<h4 id="asin">ASin</h4>

<p>Calculates the inverse sine of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ASin( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ASin( const T&amp; v ) noexcept;
</code></pre>

<h4 id="acos">ACos</h4>

<p>Calculates the inverse cosine of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ACos( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ACos( const T&amp; v ) noexcept;
</code></pre>

<h4 id="atan">ATan</h4>

<p>Calculates the inverse tangent of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ATan( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ATan( const T&amp; v ) noexcept;
</code></pre>

<h4 id="atan2">ATan2</h4>

<p>Calculates the inverse tangent of each element in x divided by the
corresponding element in y, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T ATan2( const T&amp; x, const U&amp; y ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T ATan2( const T&amp; x, const U&amp; y ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T ATan2( const U&amp; x, const T&amp; y ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT ATan2( const T&amp; x, const U&amp; y ) noexcept;
</code></pre>

<h4 id="modangles">ModAngles</h4>

<p>Calculates the angle modulo \(2\pi\) of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ModAngles( const T&amp; angles );

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ModAngles( const T&amp; v ) noexcept;
</code></pre>

<h4 id="addangles">AddAngles</h4>

<p>Adds the angles in the corresponding elements of v1 and v2.
The argument angles must be in the range \([-\pi,\pi)\), and the
computed angles will be in the range \([-\pi,\pi)\).</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AddAngles( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AddAngles( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AddAngles( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT AddAngles( const T&amp; v1, const U&amp; v2 ) noexcept;
</code></pre>

<h4 id="subtractangles">SubtractAngles</h4>

<p>Subtracts the angles in v2 from the corresponding elements of v1.
The argument angles must be in the range \([-\pi,\pi)\), and the
computed angles will be in the range \([-\pi,\pi)\)</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T SubtractAngles( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T SubtractAngles( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T SubtractAngles( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT SubtractAngles( const T&amp; v1, const U&amp; v2 ) noexcept;
</code></pre>

<h4 id="sinh">SinH</h4>

<p>Calculates the hyperbolic sine of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T SinH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT SinH( const T&amp; v ) noexcept;
</code></pre>

<h4 id="cosh">CosH</h4>

<p>Calculates the hyperbolic cosine of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T CosH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT CosH( const T&amp; v ) noexcept;
</code></pre>

<h4 id="tanh">TanH</h4>

<p>Calculates the hyperbolic tangent of each element in the argument expressed in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T TanH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT TanH( const T&amp; v ) noexcept;
</code></pre>

<h4 id="asinh">ASinH</h4>

<p>Calculates the inverse hyperbolic sine of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ASinH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ASinH( const T&amp; v ) noexcept;
</code></pre>

<h4 id="acosh">ACosH</h4>

<p>Calculates the inverse hyperbolic cosine of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ACosH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ACosH( const T&amp; v ) noexcept;
</code></pre>
<h4 id="atanh">ATanH</h4>

<p>Calculates the inverse hyperbolic tangent of each element in the argument, in radians.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ATanH( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ATanH( const T&amp; v ) noexcept;
</code></pre>

<h4 id="log">Log</h4>

<p>Calculates the natural logarithm of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Log( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Log( const T&amp; v ) noexcept;
</code></pre>

<h4 id="log1p">Log1P</h4>

<p>Calculates the natural logarithm of \(1 +\) each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Log1P( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Log1P( const T&amp; v ) noexcept;
</code></pre>

<h4 id="log10">Log10</h4>

<p>Calculates the base-10 logarithm, \(log_{10}\), of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Log10( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Log10( const T&amp; v ) noexcept;
</code></pre>

<h4 id="log2">Log2</h4>

<p>Calculates the base-2 logarithm, \(log_{2}\), of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Log2( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Log2( const T&amp; v ) noexcept;
</code></pre>

<h4 id="exp">Exp</h4>

<p>Calculates \(e\) (Eulerâ€™s number, 2.7182818â€¦), raised to the power of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Exp( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Exp( const T&amp; v ) noexcept;
</code></pre>

<h4 id="exp10">Exp10</h4>

<p>Calculates the base-10 exponential of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Exp10( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Exp10( const T&amp; v ) noexcept;
</code></pre>

<h4 id="exp2">Exp2</h4>

<p>Calculates the base-2 exponential of each element in the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Exp2( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Exp2( const T&amp; v ) noexcept;
</code></pre>

<h4 id="expm1">ExpM1</h4>

<p>Calculates  \(e\) (Eulerâ€™s number, 2.7182818â€¦), raised to the power 
of each element in the argument, \(-1.0\).</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ExpM1( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ExpM1( const T&amp; v ) noexcept;
</code></pre>

<h4 id="pow">Pow</h4>

<p>Calculates the elements in <code class="language-plaintext highlighter-rouge">base</code> raised to the corresponding elements in <code class="language-plaintext highlighter-rouge">exponent</code>.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Pow( const T&amp; base, const U&amp; exponent ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Pow( const T&amp; base, const U&amp; exponent ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Pow( const U&amp; base, const T&amp; exponent ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Pow( const T&amp; base, const U&amp; exponent ) noexcept;
</code></pre>

<h4 id="hypot">Hypot</h4>

<p>Calculates the square root of the sum of the squares of each corresponding 
element in x and y, without undue overflow or underflow at intermediate 
stages of the computation.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Hypot( const T&amp; x, const U&amp; y ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Hypot( const T&amp; x, const U&amp; y ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Hypot( const U&amp; x, const T&amp; y ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Hypot( const T&amp; x, const U&amp; y ) noexcept;
</code></pre>

<h4 id="hermite">Hermite</h4>

<p>Calculates the Hermite spline interpolation, using the specified arguments.</p>

<pre><code class="language-C++">
template&lt;Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;T, U&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, V&gt; &amp;&amp; 
            Internal::IsCompatible&lt;T, W&gt;
inline T Hermite( const T&amp; firstPosition, const U&amp; firstTangent, 
                    const V&amp; secondPosition, const W&amp; secondTangent, 
                    typename T::value_type t ) noexcept;
</code></pre>

<h4 id="dot-and-scalardot">Dot and ScalarDot</h4>

<p>Calculates the dot product between v1 and v2.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Dot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Dot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Dot( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Dot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
constexpr inline typename T::value_type ScalarDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
constexpr inline typename T::value_type ScalarDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
constexpr inline typename T::value_type ScalarDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::value_type&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
constexpr inline ResultT ScalarDot( const T&amp; v1, const U&amp; v2 ) noexcept;
</code></pre>

<h4 id="absdot-and-scalarabsdot">AbsDot and ScalarAbsDot</h4>

<p>Calculates the absolute value of the dot product between v1 and v2.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T AbsDot( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT AbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarAbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarAbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarAbsDot( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarAbsDot( const T&amp; v1, const U&amp; v2 ) noexcept;
</code></pre>

<h4 id="cross">Cross</h4>

<p>Calculates the cross product between v1 and v2.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Cross( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Cross( const T&amp; v1, const U&amp; v2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Cross( const U&amp; v1, const T&amp; v2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Cross( const T&amp; v1, const U&amp; v2 ) noexcept;
</code></pre>

<h4 id="lengthsquared-and-scalarlengthsquared">LengthSquared and ScalarLengthSquared</h4>

<p>Calculates the squared length of v.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T LengthSquared( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT LengthSquared( const T&amp; v ) noexcept;

template&lt;Internal::SimdType T&gt;
inline auto ScalarLengthSquared( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T&gt;
inline auto ScalarLengthSquared( const T&amp; v ) noexcept;

</code></pre>

<h4 id="length-and-scalarlength">Length and ScalarLength</h4>

<p>Calculates the length of v.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Length( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Length( const T&amp; v ) noexcept;

template&lt;Internal::SimdType T&gt;
inline auto ScalarLength( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T&gt;
inline auto ScalarLength( const T&amp; v ) noexcept;
</code></pre>

<h4 id="normalize">Normalize</h4>

<p>Normalizes v.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Normalize( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Normalize( const T&amp; v ) noexcept;
</code></pre>
<h4 id="reciprocallength-and-scalarreciprocallength">ReciprocalLength and ScalarReciprocalLength</h4>

<p>Calculates the reciprocal length of v.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T ReciprocalLength( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT ReciprocalLength( const T&amp; v ) noexcept;

template&lt;Internal::SimdType T&gt;
inline auto ScalarReciprocalLength( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T&gt;
inline auto ScalarReciprocalLength( const T&amp; v ) noexcept;
</code></pre>

<h4 id="distancesquared-and-scalardistancesquared">DistanceSquared and ScalarDistanceSquared</h4>

<p>Calculates the squared distance between p1 and p2.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T DistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T DistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T DistanceSquared( const U&amp; p1, const T&amp; p2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT DistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistanceSquared( const U&amp; p1, const T&amp; p2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistanceSquared( const T&amp; p1, const U&amp; p2 ) noexcept;
</code></pre>

<h4 id="distance-and-scalardistance">Distance and ScalarDistance</h4>

<p>Calculates the distance between p1 and p2.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Distance( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Distance( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T Distance( const U&amp; p1, const T&amp; p2 ) noexcept;

template&lt;Internal::TupleType T, Internal::TupleType U, typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT Distance( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistance( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistance( const T&amp; p1, const U&amp; p2 ) noexcept;

template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline auto ScalarDistance( const U&amp; p1, const T&amp; p2 ) noexcept;
</code></pre>

<h4 id="inbounds">InBounds</h4>

<p>Detects if the elements of a vector are within bounds.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline S InBounds( const S&amp; v, const T&amp; bounds ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline S InBounds( const S&amp; v, const T&amp; bounds ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline T InBounds( const S&amp; v, const T&amp; bounds ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline typename S::Simd InBounds( const S&amp; v, const T&amp; bounds ) noexcept;

</code></pre>

<h4 id="clamplength">ClampLength</h4>

<p>Clamps the length of a vector to a given range.</p>
<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd ClampLength( const S&amp; v, const T&amp; lengthMin, const U&amp; lengthMax ) noexcept;

template&lt;Internal::SimdType S, typename T, typename U&gt;
    requires IsFloatingPoint&lt;T&gt; &amp;&amp; IsFloatingPoint&lt;U&gt;
inline S ClampLength( const S&amp; v, const T lengthMin, const U lengthMax ) noexcept;

template&lt;Internal::TupleType S, typename T, typename U&gt;
    requires IsFloatingPoint&lt;T&gt;&amp;&amp; IsFloatingPoint&lt;U&gt;
inline S ClampLength( const S&amp; v, const T lengthMin, const U lengthMax ) noexcept;
</code></pre>

<h4 id="reflect">Reflect</h4>

<p>Reflects an incident vector across a normal vector.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline S Reflect( const S&amp; incident, const T&amp; normal ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline S Reflect( const S&amp; incident, const T&amp; normal ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline T Reflect( const S&amp; incident, const T&amp; normal ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T&gt;
    requires Internal::IsCompatible&lt;S, T&gt;
inline typename S::Simd Reflect( const S&amp; incident, const T&amp; normal ) noexcept;

</code></pre>

<h4 id="refract">Refract</h4>

<p>Refracts an incident vector across a normal vector.</p>

<pre><code class="language-C++">
template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U&amp; refractionIndex ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, typename U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; IsFloatingPoint&lt;U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U refractionIndex ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, typename U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; IsFloatingPoint&lt;U&gt;
inline S Refract( const S&amp; incident, const T&amp; normal, const U refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, typename U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; IsFloatingPoint&lt;U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U refractionIndex ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, typename U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; IsFloatingPoint&lt;U&gt;
inline typename S::Simd Refract( const S&amp; incident, const T&amp; normal, const U refractionIndex ) noexcept;
</code></pre>

<h4 id="orthogonal">Orthogonal</h4>

<p>Computes a vector perpendicular to the argument vector.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S&gt;
inline S Orthogonal( const S&amp; v ) noexcept;

template&lt;Internal::TupleType S&gt;
inline typename S::Simd Orthogonal( const S&amp; v ) noexcept;
</code></pre>

<h4 id="differenceofproducts">DifferenceOfProducts</h4>

<p>Calculates the difference between the product of the first and the second argument, 
and the product of the third and fourth argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline U DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline U DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline V DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline typename S::Simd DifferenceOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;
</code></pre>

<h4 id="sumofproducts">SumOfProducts</h4>

<p>Calculates the sum of the product of the first and the second argument, 
and the product of the third and fourth argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline S SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline T SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline U SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline U SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline V SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;
inline typename S::Simd SumOfProducts( const S&amp; v1, const T&amp; v2, const U&amp; v3, const V&amp; v4 ) noexcept;
</code></pre>

<h4 id="barycentric">BaryCentric</h4>

<p>Calculates a point in Barycentric coordinates, using the specified triangle.</p>

<p>see https://en.wikipedia.org/wiki/Barycentric_coordinate_system</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; f, const W&amp; g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; IsFloatingPoint&lt;V&gt; &amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, typename V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; IsFloatingPoint&lt;V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd BaryCentric( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V f, const W g ) noexcept;

</code></pre>

<h4 id="catmullrom">CatmullRom</h4>

<p>Calculates the Catmull-Rom interpolation, using the specified positions.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::SimdType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, Internal::TupleType W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; Internal::IsCompatible&lt;S, W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W&amp; t ) noexcept;


template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::SimdType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline S CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::SimdType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::SimdType T, Internal::TupleType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::SimdType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::SimdType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;

template&lt;Internal::TupleType S, Internal::TupleType T, Internal::TupleType U, Internal::TupleType V, typename W&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt;&amp;&amp; Internal::IsCompatible&lt;S, V&gt;&amp;&amp; IsFloatingPoint&lt;W&gt;
inline typename S::Simd CatmullRom( const S&amp; p1, const T&amp; p2, const U&amp; p3, const V&amp; p4, const W t ) noexcept;
</code></pre>

<h4 id="mincomponentvalue">MinComponentValue</h4>

<p>Retrieves the lowest value held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, typename ResultT = typename T::value_type &gt;
inline ResultT MinComponentValue( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
constexpr inline ResultT MinComponentValue( const T&amp; v ) noexcept;
</code></pre>

<h4 id="maxcomponentvalue">MaxComponentValue</h4>

<p>Retrieves the highest value held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, typename ResultT = typename T::value_type &gt;
inline ResultT MaxComponentValue( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
constexpr inline ResultT MaxComponentValue( const T&amp; v ) noexcept;
</code></pre>

<h4 id="mincomponentindex">MinComponentIndex</h4>

<p>Retrieves the offset of the lowest value held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, typename ResultT = typename T::value_type &gt;
inline ResultT MinComponentIndex( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
constexpr inline ResultT MinComponentIndex( const T&amp; v ) noexcept;
</code></pre>

<h4 id="maxcomponentindex">MaxComponentIndex</h4>

<p>Retrieves the offset of the highest value held by the argument.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, typename ResultT = typename T::value_type &gt;
inline ResultT MaxComponentIndex( const T&amp; v ) noexcept;

template&lt;Internal::TupleType T, typename ResultT = typename T::value_type&gt;
constexpr inline ResultT MaxComponentIndex( const T&amp; v ) noexcept;
</code></pre>

<hr />

<h3 id="vector2f-vector3f-vector4f-vector2i-vector3i-vector4i">Vector2f, Vector3f, Vector4f, Vector2i, Vector3i, Vector4i</h3>

<p><code class="language-plaintext highlighter-rouge">Vector&lt;float,2&gt;</code>, <code class="language-plaintext highlighter-rouge">Vector&lt;float,3&gt;</code> and <code class="language-plaintext highlighter-rouge">Vector&lt;float,4&gt;</code> are specializations of <code class="language-plaintext highlighter-rouge">Vector&lt;T,N&gt;</code> that 
supports a wider repertoire of operations than the general <code class="language-plaintext highlighter-rouge">Vector&lt;T,N&gt;</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Vector&lt;float,2&gt;</code> is derived from the <code class="language-plaintext highlighter-rouge">Tuple2</code> template, <code class="language-plaintext highlighter-rouge">Vector&lt;float,3&gt;</code> is derived 
from the <code class="language-plaintext highlighter-rouge">Tuple3</code>, and <code class="language-plaintext highlighter-rouge">Vector&lt;float,4&gt;</code> is derived from <code class="language-plaintext highlighter-rouge">Tuple4</code>.</p>

<p>Just a few lines of code are required to create the <code class="language-plaintext highlighter-rouge">Vector&lt;float, 3&gt;</code> specialization of <code class="language-plaintext highlighter-rouge">Vector&lt;T,N&gt;</code>
with the full repertoire of features available for <code class="language-plaintext highlighter-rouge">Tuple3</code>:</p>

<pre><code class="language-C++">template&lt;&gt;
class Vector&lt;float, 3&gt; : public Tuple3&lt;Vector&lt;float, 3&gt;,float&gt;
{
public:
    using Base = Tuple3&lt;Vector&lt;float, 3&gt;, float&gt;;
    using Traits = Base::Traits;

    Vector( ) noexcept = default;
    explicit Vector( float v ) noexcept
        : Base( v, v, v )
    { }
    Vector( float xv, float yv, float zv ) noexcept
        : Base( xv, yv, zv )
    { }

    template&lt;typename T&gt;
        requires std::is_same_v&lt;typename T::SIMDType, typename Traits::SIMDType &gt;
    Vector( const T&amp; other ) noexcept
        : Base( other )
    { }
};
</code></pre>

<p>Below are two benchmarks, the first using <code class="language-plaintext highlighter-rouge">Math::Vector&lt;float, 3&gt;</code>, 
while the second uses <code class="language-plaintext highlighter-rouge">pbrt::Vector3f</code>.</p>

<pre><code class="language-C++">static void BenchmarkVector3( benchmark::State&amp; state )
{
    using namespace Harlinn::Common::Core::Math;
    using Vector = Math::Vector&lt;float, 3&gt;;
    DoubleGenerator.Reset( );

    for ( auto _ : state )
    {
        Vector v1( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        Vector v2( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        benchmark::DoNotOptimize( Dot( Abs( Max( Ceil( -v1 ), Floor( v2 ) ) ), v2 ) );
    }
}
BENCHMARK( BenchmarkVector3 );

static void BenchmarkPBRTVector3f( benchmark::State&amp; state )
{
    using namespace pbrt;
    using Vector = pbrt::Vector3f;
    DoubleGenerator.Reset( );


    for ( auto _ : state )
    {
        Vector v1( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        Vector v2( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        benchmark::DoNotOptimize( Dot( Abs( Max( Ceil( -v1 ), Floor( v2 ) ) ), v2 ) );
    }
}
BENCHMARK( BenchmarkPBRTVector3f );
</code></pre>
<p><code class="language-plaintext highlighter-rouge">BenchmarkVector2</code> runs <code class="language-plaintext highlighter-rouge">20</code> % faster than <code class="language-plaintext highlighter-rouge">BenchmarkPBRTVector3f</code> which is
optimized by the compiler for the AVX2 instruction set:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-------------------------------------------------------------------
Benchmark                         Time             CPU   Iterations
-------------------------------------------------------------------
BenchmarkVector3               5.63 ns         4.85 ns    186666667
BenchmarkPBRTVector3f          7.08 ns         5.86 ns    112000000
</code></pre></div></div>

<h4 id="vector-functions">Vector functions</h4>

<h5 id="anglebetween">AngleBetween</h5>

<p>Calculates the angle in radians between two vectors.</p>

<h5 id="anglebetweennormals">AngleBetweenNormals</h5>

<p>Calculates the angle in radians between two normalized vectors.</p>

<h5 id="transform">Transform</h5>

<p>Transforms a 3D vector by a matrix.</p>

<pre><code class="language-C++">inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;::Simd&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;::Simd&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;&amp; matrix );
</code></pre>

<h3 id="normal3f-and-normal3i">Normal3f and Normal3i</h3>

<p>The surface normal is a vector perpendicular to 
a surface at a specific position. It can be defined as the cross product 
of any two nonparallel vectors that are tangent to the surface at a point. 
Normals are similar to vectors, but itâ€™s important to 
distinguish between the two of them: since normals are defined in terms 
of their relationship to a surface, they behave differently than 
vectors in some situations, particularly when applying transformations.</p>

<h4 id="normal3f-functions">Normal3f functions</h4>

<h5 id="transform-1">Transform</h5>

<p>Transforms the Normal3f object by the given matrix.</p>

<pre><code class="language-C++">inline Normal3f::Simd Transform( const Normal3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 3&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; v, 
                                const SquareMatrix&lt;float, 3&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 3&gt;&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; v, 
                                const SquareMatrix&lt;float, 3&gt;&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>

<h3 id="point3f-and-point3i">Point3f and Point3i</h3>

<p>A point is a zero-dimensional location in 2D or 3D space. The Point2i/f and Point3i/f 
classes represent points in the obvious way: using \(x, y, z\)  (in 3D) coordinates 
with respect to a coordinate system. Although the same representation is used for 
vectors, the fact that a point represents a position whereas a vector represents a 
direction leads to a number of important differences in how they are treated.</p>

<h4 id="point3f">Point3f</h4>

<h5 id="linepointdistance">LinePointDistance</h5>

<p>Calculates the minimum distance between a line and a point.</p>

<h5 id="transform-2">Transform</h5>

<p>Transforms the Point3f object by the provided transformation matrix.</p>

<pre><code class="language-C++">
inline Point3f::Simd Transform( const Point3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Point3f::Simd Transform( const Point3f&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Point3f::Simd Transform( const Point3f::Simd&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Point3f::Simd Transform( const Point3f&amp; v, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>

<h2 id="squarematrix">SquareMatrix</h2>

<p>The <code class="language-plaintext highlighter-rouge">SquareMatrix</code> template class is used to represent transformations that can be applied
to vectors, points and surface normals.</p>

<p>The template is designed as a row oriented matrix, that can be instantiated for 
single and double precision floating point types. The template can be instantiated
as a \(2 x 2\), \(3 x 3\) or \(4 x 4\) matrix.</p>

<p>Internally, computations on \(2 x 2\) matrices are performed using a single SIMD type/register,
while operations on \(3 x 3\) and \(4 x 4\) matrices are performed using one
SIMD type/register for each row.</p>

<p><code class="language-plaintext highlighter-rouge">SquareMatrix</code> support matrix addition, scalar addition, matrix multiplication, scalar multiplication, 
the matrices can be transposed using <code class="language-plaintext highlighter-rouge">Transpose</code> and inverted using <code class="language-plaintext highlighter-rouge">Inverse</code>, and <code class="language-plaintext highlighter-rouge">Determinant</code> calculates
the determinant. The default constructor creates an identity matrix, so <code class="language-plaintext highlighter-rouge">SquareMatrix</code> handles the usual
operations associated with small square matrices.</p>

<h3 id="squarematrixfloat4-functions">SquareMatrix&lt;float,4&gt; functions</h3>

<h4 id="transpose">Transpose</h4>

<p>Calculates the transpose of the matrix.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd Transpose( const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline SquareMatrix&lt;float, 4&gt;::Simd Transpose( const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>

<h4 id="inverse">Inverse</h4>

<p>Calculates the inverse of the matrix.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd Inverse( const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix, 
                                            typename Vector&lt;float, 4&gt;::Simd* determinant = nullptr );

inline typename SquareMatrix&lt;float, 4&gt;::Simd Inverse( const SquareMatrix&lt;float, 4&gt;&amp; matrix, 
                                            typename Vector&lt;float, 4&gt;::Simd* determinant = nullptr );

</code></pre>

<h4 id="determinant-and-scalardeterminant">Determinant and ScalarDeterminant</h4>

<p>Calculates the determinant of a matrix.</p>

<pre><code class="language-C++">inline typename Vector&lt;float,4&gt;::Simd Determinant( const typename SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline typename Vector&lt;float, 4&gt;::Simd Determinant( const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline float ScalarDeterminant( const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline float ScalarDeterminant( const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>

<h4 id="translation">Translation</h4>

<p>Creates a translation matrix using the provided offsets.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd Translation( float offsetX, float offsetY, float offsetZ );

template&lt;Internal::SimdType S&gt;
    requires (S::Size &gt; 2) &amp;&amp; std::is_same_v&lt;typename S::value_type, float&gt;
inline SquareMatrix&lt;float, 4&gt;::Simd Translation( const S&amp; offsets );

template&lt;Internal::TupleType S&gt;
    requires ( S::Size &gt; 2 ) &amp;&amp; std::is_same_v&lt;typename S::value_type, float&gt;
inline SquareMatrix&lt;float, 4&gt;::Simd Translation( const S&amp; offsets );

</code></pre>

<h4 id="scaling">Scaling</h4>

<p>Creates a transformation matrix for scaling along 
the x-axis, y-axis, and z-axis.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd Scaling( float scaleX, float scaleY, float scaleZ );

template&lt;Internal::SimdType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd Scaling( const S&amp; v ) noexcept;

template&lt;Internal::TupleType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd Scaling( const S&amp; v ) noexcept;

</code></pre>

<h4 id="rotation">Rotation</h4>

<p>Creates a transformation matrix that rotates about the y-axis, 
then the x-axis, and finally the z-axis.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S&gt;
    requires (S::Size &gt; 2)
inline SquareMatrix&lt;float, 4&gt;::Simd Rotation( const S&amp; v ) noexcept;

template&lt;Internal::TupleType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd Rotation( const S&amp; v ) noexcept;

inline SquareMatrix&lt;float, 4&gt;::Simd Rotation( float xAxisRotation, 
                        float yAxisRotation, float zAxisRotation ) noexcept;
</code></pre>

<h4 id="rotationnormal">RotationNormal</h4>

<p>Creates a matrix that rotates around a normalized vector.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S&gt;
    requires ( S::Size &gt; 2 ) 
inline SquareMatrix&lt;float, 4&gt;::Simd RotationNormal( const S&amp; normalizedAxis, float angle ) noexcept;

template&lt;Internal::TupleType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd RotationNormal( const S&amp; normalizedAxis, float angle ) noexcept;

</code></pre>

<h4 id="rotationaxis">RotationAxis</h4>

<p>Creates a matrix that rotates around an arbitrary axis.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd RotationAxis( const S&amp; axis, float angle ) noexcept;

template&lt;Internal::TupleType S&gt;
    requires ( S::Size &gt; 2 )
inline SquareMatrix&lt;float, 4&gt;::Simd RotationAxis( const S&amp; axis, float angle ) noexcept;
</code></pre>

<h4 id="rotationquaternion">RotationQuaternion</h4>

<p>Creates a rotation matrix from a quaternion.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd RotationQuaternion( const QuaternionSimd&lt;Quaternion&lt;float&gt;&gt;&amp; q );

inline SquareMatrix&lt;float, 4&gt;::Simd RotationQuaternion( const Quaternion&lt;float&gt;&amp; q );

</code></pre>

<h4 id="transformationmatrix">TransformationMatrix</h4>

<p>Creates a transformation matrix.</p>

<pre><code class="language-C++">inline SquareMatrix&lt;float, 4&gt;::Simd TransformationMatrix( const Point3f::Simd&amp; scalingOrigin, 
                            const QuaternionSimd&lt;Quaternion&lt;float&gt;&gt;&amp; scalingOrientationQuaternion, 
                            const Vector&lt;float,3&gt;::Simd&amp; scaling,
                            const Point3f::Simd&amp; rotationOrigin, 
                            const QuaternionSimd&lt;Quaternion&lt;float&gt;&gt;&amp; rotationQuaternion, 
                            const Vector&lt;float, 3&gt;::Simd&amp; translation ) noexcept;


</code></pre>

<h4 id="affinetransformationmatrix">AffineTransformationMatrix</h4>

<p>Creates an affine transformation matrix.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, typename U, Internal::SimdType W&gt;
        requires (S::Size &gt; 2) &amp;&amp; (T::Size &gt; 2) &amp;&amp; (W::Size &gt; 2) &amp;&amp; IsFloatingPoint&lt;U&gt; &amp;&amp;
            std::is_same_v&lt;typename S::value_type,U&gt; &amp;&amp; 
                std::is_same_v&lt;typename T::value_type, U&gt; &amp;&amp; 
                std::is_same_v&lt;typename W::value_type, U&gt;
    inline SquareMatrix&lt;U, 4&gt;::Simd AffineTransformationMatrix( const S&amp; scaling,
                                        const T&amp; rotationOrigin,
                                        const QuaternionSimd&lt;Quaternion&lt;U&gt;&gt;&amp; rotationQuaternion,
                                        const W&amp; translation ) noexcept;

</code></pre>

<h4 id="lookto">LookTo</h4>

<p>Creates a view matrix using the left-handed coordinate system for the
provided camera position, camera direction, and up direction.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;S,T&gt; &amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; (S::Size == 3)
inline SquareMatrix&lt;typename S::value_type, 4&gt;::Simd LookTo( const S&amp; cameraPosition, 
                                                            const T&amp; cameraDirection, 
                                                            const U&amp; upDirection ) noexcept;
</code></pre>

<h4 id="lookat">LookAt</h4>

<p>Creates a view matrix using the left-handed coordinate system for the
provided camera position, focal point, and up direction.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType S, Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;S, T&gt;&amp;&amp; Internal::IsCompatible&lt;S, U&gt; &amp;&amp; ( S::Size == 3 )
inline SquareMatrix&lt;typename S::value_type, 4&gt;::Simd LookAt( const S&amp; cameraPosition, 
                                                            const T&amp; focusPosition, 
                                                            const U&amp; upDirection ) noexcept;
</code></pre>

<h4 id="perspectiveprojection">PerspectiveProjection</h4>

<p>Creates a left-handed perspective projection matrix.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
inline SquareMatrix&lt;T, 4&gt;::Simd PerspectiveProjection( T viewWidth, 
                                                    T viewHeight, 
                                                    T nearZ, 
                                                    T farZ ) noexcept;
</code></pre>

<h4 id="perspectivefovprojection">PerspectiveFovProjection</h4>

<p>Creates a left-handed perspective projection matrix based on a field of view.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
inline SquareMatrix&lt;T, 4&gt;::Simd PerspectiveFovProjection( T fovAngleY, 
                                                        T aspectRatio, 
                                                        T nearZ, 
                                                        T farZ ) noexcept;

</code></pre>

<h4 id="transform-3">Transform</h4>

<p>Applies a transformation matrix to a 3D vector.</p>

<pre><code class="language-C++">inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;::Simd&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;::Simd&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Vector&lt;float, 3&gt;::Simd Transform( const Vector&lt;float, 3&gt;&amp; v, 
                                        const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>
<p>Applies a transformation matrix to a 3D coordinate.</p>

<pre><code class="language-C++">inline Point3f::Simd Transform( const Point3f::Simd&amp; p, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Point3f::Simd Transform( const Point3f&amp; p, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Point3f::Simd Transform( const Point3f::Simd&amp; p, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Point3f::Simd Transform( const Point3f&amp; p, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );
</code></pre>

<p>Applies a transformation matrix to a normal.</p>

<pre><code class="language-C++">inline Normal3f::Simd Transform( const Normal3f::Simd&amp; n, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; n, 
                                const SquareMatrix&lt;float, 4&gt;::Simd&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f::Simd&amp; n, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

inline Normal3f::Simd Transform( const Normal3f&amp; n, 
                                const SquareMatrix&lt;float, 4&gt;&amp; matrix );

</code></pre>

<h2 id="quaternion">Quaternion</h2>

<p>Quaternions provides a compact representation of rotations.</p>

<p>The <code class="language-plaintext highlighter-rouge">Quaternion</code> template can be used with both single and double precision floating
point types.</p>

<p>Like the tuple templates, there is a <code class="language-plaintext highlighter-rouge">QuaternionSimd</code> template that represents
quaternions loaded into a SIMD register.</p>

<p><code class="language-plaintext highlighter-rouge">Quaternion</code> and <code class="language-plaintext highlighter-rouge">QuaternionSimd</code> supports addition, subtraction, multiplication, 
scalar multiplication and scalar division.</p>

<h3 id="quaternion-member-functions">Quaternion member functions</h3>

<h4 id="constructors">Constructors</h4>

<pre><code class="language-C++">constexpr Quaternion( ) noexcept;
</code></pre>
<p>The default constructor initializes <code class="language-plaintext highlighter-rouge">v.x</code>, <code class="language-plaintext highlighter-rouge">v.y</code>, <code class="language-plaintext highlighter-rouge">v.z</code> and <code class="language-plaintext highlighter-rouge">w</code> to <code class="language-plaintext highlighter-rouge">0.0</code>.</p>

<pre><code class="language-C++">constexpr Quaternion( ValueType xv, ValueType yv, ValueType zv, ValueType wv ) noexcept;
</code></pre>
<p>Initializes <code class="language-plaintext highlighter-rouge">v.x</code> to <code class="language-plaintext highlighter-rouge">xv</code>, <code class="language-plaintext highlighter-rouge">v.y</code> to <code class="language-plaintext highlighter-rouge">yv</code>, <code class="language-plaintext highlighter-rouge">v.z</code> to <code class="language-plaintext highlighter-rouge">zv</code> and <code class="language-plaintext highlighter-rouge">w</code> to <code class="language-plaintext highlighter-rouge">wv</code>.</p>

<pre><code class="language-C++">constexpr Quaternion( const Vector&lt;ValueType,3&gt;&amp; vv, ValueType wv ) noexcept;
</code></pre>

<p>Initializes <code class="language-plaintext highlighter-rouge">v</code> to <code class="language-plaintext highlighter-rouge">xv</code> and <code class="language-plaintext highlighter-rouge">w</code> to <code class="language-plaintext highlighter-rouge">wv</code>.</p>

<pre><code class="language-C++">Quaternion( const Simd&amp; qsimd ) noexcept
</code></pre>
<p>Initializes the quaternion using the values held by <code class="language-plaintext highlighter-rouge">qsimd.simd</code>.</p>

<pre><code class="language-C++">Quaternion( ValueType pitch, ValueType yaw, ValueType roll ) noexcept
</code></pre>
<p>Creates a quaternion based on the pitch, yaw, and roll (Euler angles),
where:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pitch</code> is the angle of rotation around the x-axis, in radians.</li>
  <li><code class="language-plaintext highlighter-rouge">yaw</code> is the angle of rotation around the y-axis, in radians.</li>
  <li><code class="language-plaintext highlighter-rouge">roll</code> is the angle of rotation around the z-axis, in radians.</li>
</ul>

<h3 id="quaternion-functions">Quaternion functions</h3>

<h4 id="dot">Dot</h4>

<p>Calculates the dot product of two quaternions.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T,4&gt;::Simd Dot( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd Dot( const Quaternion&lt;T&gt;&amp; q1, 
                                const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd Dot( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                const Quaternion&lt;T&gt;&amp; q2 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd Dot( const Quaternion&lt;T&gt;&amp; q1, 
                                const Quaternion&lt;T&gt;&amp; q2 ) noexcept;
</code></pre>

<h4 id="length-and-scalarlength-1">Length and ScalarLength</h4>

<p>Calculates the magnitude of a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd Length( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd Length( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarLength( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarLength( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="lengthsquared-and-scalarlengthsquared-1">LengthSquared and ScalarLengthSquared</h4>

<p>Calculates the square of the magnitude of a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd LengthSquared( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd LengthSquared( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarLengthSquared( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarLengthSquared( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="reciprocallength-and-scalarreciprocallength-1">ReciprocalLength and ScalarReciprocalLength</h4>

<p>Calculates the reciprocal of the magnitude of a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd ReciprocalLength( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename Vector&lt;T, 4&gt;::Simd ReciprocalLength( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarReciprocalLength( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
typename T ScalarReciprocalLength( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="conjugate">Conjugate</h4>

<p>Calculates the conjugate of a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Conjugate( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Normalize( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="normalize-1">Normalize</h4>

<p>Normalizes a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Normalize( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Normalize( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="inverse-1">Inverse</h4>

<p>Calculates the inverse of a quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Inverse( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Inverse( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="log-1">Log</h4>

<p>Calculates the natural logarithm of a unit quaternion.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Log( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1 ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Log( const Quaternion&lt;T&gt;&amp; q1 ) noexcept;
</code></pre>

<h4 id="slerp">Slerp</h4>

<p>Spherical linear interpolation between two unit quaternions.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                    const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2, 
                                    const typename Vector&lt;T, 4&gt;::Simd&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                    const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2, 
                                    const Vector&lt;T, 4&gt;&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                    const Quaternion&lt;T&gt;&amp; q2, 
                                    const typename Vector&lt;T, 4&gt;::Simd&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q1, 
                                    const Quaternion&lt;T&gt;&amp; q2, 
                                    const Vector&lt;T, 4&gt;&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const Quaternion&lt;T&gt;&amp; q1, 
                                    const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2, 
                                    const typename Vector&lt;T, 4&gt;::Simd&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const Quaternion&lt;T&gt;&amp; q1, 
                                    const QuaternionSimd&lt;Quaternion&lt;T&gt;&gt;&amp; q2, 
                                    const Vector&lt;T, 4&gt;&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const Quaternion&lt;T&gt;&amp; q1, 
                                    const Quaternion&lt;T&gt;&amp; q2, 
                                    const typename Vector&lt;T, 4&gt;::Simd&amp; t ) noexcept;

template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
QuaternionSimd&lt;Quaternion&lt;T&gt;&gt; Slerp( const Quaternion&lt;T&gt;&amp; q1, 
                                    const Quaternion&lt;T&gt;&amp; q2, 
                                    const Vector&lt;T, 4&gt;&amp; t ) noexcept;

</code></pre>

<h2 id="transform-4">Transform</h2>

<p>A transform is a mapping from vectors to vectors or points to points.</p>

<p>Taking a point, vector, or normal defined with respect to one coordinate frame and 
finding its coordinate values with respect to another coordinate frame is a useful 
capability.</p>

<h2 id="benchmarks">Benchmarks</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--------------------------------------------------------------------------------------
Benchmark                                            Time             CPU   Iterations
--------------------------------------------------------------------------------------
BenchmarkPointRotationAxis                        13.4 ns         10.5 ns     64000000
BenchmarkPointXMMatrixRotationAxis                20.2 ns         16.5 ns     56000000
BenchmarkVectorRotationAxis                       13.5 ns         10.5 ns     64000000
BenchmarkVectorXMMatrixRotationAxis               19.3 ns         16.1 ns     40727273
BenchmarkNormalRotationAxis                       13.2 ns         10.9 ns     74334815
BenchmarkNormalXMMatrixRotationAxis               19.8 ns         17.1 ns     44800000
BenchmarkPointTranslation                         3.53 ns         2.85 ns    263529412
BenchmarkPointXMMatrixTranslation                 3.85 ns         2.98 ns    235789474
BenchmarkVectorTranslation                        2.89 ns         2.51 ns    298666667
BenchmarkVectorXMMatrixTranslation                3.93 ns         3.31 ns    235789474
BenchmarkNormalTranslation                        2.21 ns         1.83 ns    298666667
BenchmarkNormalXMMatrixTranslation                2.78 ns         2.02 ns    263529412
BenchmarkPointScaling                             3.48 ns         2.90 ns    280000000
BenchmarkPointXMMatrixScaling                     3.76 ns         3.28 ns    224000000
BenchmarkVectorScaling                            3.59 ns         3.20 ns    248888889
BenchmarkVectorXMMatrixScaling                    4.51 ns         3.85 ns    194782609
BenchmarkNormalScaling                            3.58 ns         2.92 ns    203636364
BenchmarkNormalXMMatrixScaling                    3.80 ns         2.76 ns    248888889
BenchmarkPointTransformationMatrix                3.28 ns         2.58 ns    344615385
BenchmarkPointXMMatrixTransformation              3.25 ns         2.68 ns    280000000
BenchmarkVectorTransformationMatrix               3.20 ns         2.61 ns    263529412
BenchmarkVectorXMMatrixTransformation             3.35 ns         2.92 ns    235789474
BenchmarkNormalTransformationMatrix               3.33 ns         2.55 ns    263529412
BenchmarkNormalXMMatrixTransformation             3.04 ns         2.73 ns    320000000
BenchmarkPointAffineTransformationMatrix          34.0 ns         24.6 ns     40727273
BenchmarkPointXMMatrixAffineTransformation        30.7 ns         27.3 ns     32000000
BenchmarkVectorAffineTransformationMatrix         33.6 ns         28.5 ns     26352941
BenchmarkVectorXMMatrixAffineTransformation       31.6 ns         24.5 ns     24888889
BenchmarkNormalAffineTransformationMatrix         32.9 ns         26.4 ns     24888889
BenchmarkNormalXMMatrixAffineTransformation       30.7 ns         25.6 ns     29866667
BenchmarkPointLookTo                              17.9 ns         15.4 ns     64000000
BenchmarkPointXMMatrixLookToLH                    24.2 ns         17.6 ns     32000000
BenchmarkVectorLookTo                             17.5 ns         13.7 ns     56000000
BenchmarkVectorXMMatrixLookToLH                   23.5 ns         20.3 ns     40727273
BenchmarkNormalLookTo                             17.6 ns         14.4 ns     64000000
BenchmarkNormalXMMatrixLookToLH                   23.1 ns         20.5 ns     32000000
BenchmarkPointLookAt                              19.5 ns         16.2 ns     56000000
BenchmarkPointXMMatrixLookAtLH                    28.8 ns         26.2 ns     29866667
BenchmarkVectorLookAt                             19.3 ns         15.7 ns     74666667
BenchmarkVectorXMMatrixLookAtLH                   26.8 ns         20.5 ns     32000000
BenchmarkNormalLookAt                             18.5 ns         15.1 ns     49777778
BenchmarkNormalXMMatrixLookAtLH                   27.9 ns         23.1 ns     34461538
BenchmarkPointPerspectiveProjection               3.11 ns         2.57 ns    248888889
BenchmarkPointXMMatrixPerspectiveLH               4.58 ns         2.68 ns    186666667
BenchmarkVectorPerspectiveProjection              3.31 ns         2.79 ns    280000000
BenchmarkVectorXMMatrixPerspectiveLH              4.14 ns         3.93 ns    194782609
BenchmarkVectorPerspectiveProjection              3.30 ns         2.76 ns    248888889
BenchmarkNormalXMMatrixPerspectiveLH              3.42 ns         3.08 ns    213333333
BenchmarkPointPerspectiveFovProjection            11.9 ns         8.54 ns     64000000
BenchmarkPointXMMatrixPerspectiveFovLH            16.6 ns         12.8 ns     56000000
BenchmarkVectorPerspectiveFovProjection           11.3 ns         8.28 ns    100000000
BenchmarkVectorXMMatrixPerspectiveFovLH           15.6 ns         14.2 ns     56000000
BenchmarkNormalPerspectiveFovProjection           10.5 ns         8.59 ns    100000000
BenchmarkNormalXMMatrixPerspectiveFovLH           15.6 ns         11.5 ns     64000000
BenchmarkPointProject                             43.9 ns         36.8 ns     20363636
BenchmarkPointXMVector3Project                    57.6 ns         47.4 ns     11200000

</code></pre></div></div>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Harlinn</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Harlinn</li><li><a class="u-email" href="mailto:espen@harlinn.no">espen@harlinn.no</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Harlinn"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Harlinn</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is my personal Github site, </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Optimized basic math functions | Harlinn</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Optimized basic math functions" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is my personal site." />
<meta property="og:description" content="This is my personal site." />
<link rel="canonical" href="https://harlinn.github.io/Cpp/Cpp/Math/BasicMath.html" />
<meta property="og:url" content="https://harlinn.github.io/Cpp/Cpp/Math/BasicMath.html" />
<meta property="og:site_name" content="Harlinn" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Optimized basic math functions" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"This is my personal site.","headline":"Optimized basic math functions","url":"https://harlinn.github.io/Cpp/Cpp/Math/BasicMath.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://harlinn.github.io/feed.xml" title="Harlinn" /><script type="text/javascript" id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="importmap">
        {
            "imports":
            {
            "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.min.js" ,
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
            }
        }
    </script>
</head>
<body><header class="site-header" role="banner">
    <div id="animatedHeader" height="120px" width="100%">
        <script type="x-shader/x-vertex" id="vertexshader">
            attribute float scale;
            void main() {
                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                gl_PointSize = scale * ( 100.0 / - mvPosition.z );
                gl_Position = projectionMatrix * mvPosition;
            }

        </script>

        <script type="x-shader/x-fragment" id="fragmentshader">
            uniform vec3 color;
            void main() {
                if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 )  discard;
                gl_FragColor = vec4( color, 0.8 );
            }
        </script>

        <script type="module">

			import * as THREE from 'three';

			const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;

			let container; 
			let camera, scene, renderer;

			let particles, count = 0;

			let mouseX = 0, mouseY = 0;

			let animatedHeaderHeight = 120;

            let windowHalfX = window.innerWidth / 2;
            let windowHalfY = animatedHeaderHeight/2.0;

			init();

			function init() {

                container = document.querySelector('#animatedHeader');

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;

				scene = new THREE.Scene();

				//

				const numParticles = AMOUNTX * AMOUNTY;

				const positions = new Float32Array( numParticles * 3 );
				const scales = new Float32Array( numParticles );

				let i = 0, j = 0;

				for ( let ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( let iy = 0; iy < AMOUNTY; iy ++ ) {

						positions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x
						positions[ i + 1 ] = 0; // y
						positions[ i + 2 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z

						scales[ j ] = 1;

						i += 3;
						j ++;

					}

				}

				const geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) );

				const material = new THREE.ShaderMaterial( {

					uniforms: {
						color: { value: new THREE.Color( 0xffffff ) },
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent

				} );

				//

				particles = new THREE.Points( geometry, material );
				scene.add( particles );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize(window.innerWidth, animatedHeaderHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				container.style.touchAction = 'none';
				container.addEventListener( 'pointermove', onPointerMove );

				//

                window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;

				camera.aspect = window.innerWidth / animatedHeaderHeight; 
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, animatedHeaderHeight);

			}

			//

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			//

			function animate() {
				render();

			}

			function render() {

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );

				const positions = particles.geometry.attributes.position.array;
				const scales = particles.geometry.attributes.scale.array;

				let i = 0, j = 0;

				for ( let ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( let iy = 0; iy < AMOUNTY; iy ++ ) {

						positions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.3 ) * 50 ) +
										( Math.sin( ( iy + count ) * 0.5 ) * 50 );

						scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 20 +
										( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 20;

						i += 3;
						j ++;

					}

				}

				particles.geometry.attributes.position.needsUpdate = true;
				particles.geometry.attributes.scale.needsUpdate = true;

				renderer.render( scene, camera );

				count += 0.1;

			}

        </script>

    </div>
  <div class="wrapper"><a class="site-title" rel="author" href="/">Harlinn</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/Cpp/Cpp.html">C++</a><a class="page-link" href="/Databases/Databases.html">Databases</a><a class="page-link" href="/DotNet/DotNet.html">.Net</a><a class="page-link" href="/Java/Java.html">Java</a><a class="page-link" href="/Julia/Julia.html">Julia</a><a class="page-link" href="/Python/Python.html">Python</a><a class="page-link" href="/R/R.html">R</a><a class="page-link" href="/Rust/Rust.html">Rust</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Optimized basic math functions</h1>
  </header>

  <div class="post-content">
    <p>In C++, like any other programming language, computations are performed using the available set
of operators, the intrinsic functions implemented by the compiler, and the set of core mathematical 
functions provided by the standard C and C++ libraries, or some alternative implementation.</p>

<p>The header, <code class="language-plaintext highlighter-rouge">HCCMath.h</code> provides alternatives to many of the core mathematical function that is specified in 
the C and C++ standards. All of the functions can be <code class="language-plaintext highlighter-rouge">constexpr</code> evaluated, and several offer 
runtime performance benefits as well.</p>

<p><code class="language-plaintext highlighter-rouge">HCCMath.h</code> is header only, and does not require linking with <code class="language-plaintext highlighter-rouge">Harlinn.Common.Core.lib</code>.</p>

<p><img src="assets/BasicMath.svg" alt="" /></p>

<p>The functions are implemented in the <a href="/Doxygen/namespace_harlinn_1_1_common_1_1_core_1_1_math.html"><code class="language-plaintext highlighter-rouge">Harlinn::Common::Core::Math</code> namespace</a>.</p>

<h3 id="unit-tests">Unit Tests</h3>

<p>Unit tests for <code class="language-plaintext highlighter-rouge">constexpr</code> evaluation of the core functions from <code class="language-plaintext highlighter-rouge">HCCMath.h</code> are provided in 
<a href="https://github.com/Harlinn/Harlinn.Windows/blob/master/Tests/Harlinn.Common.Core.Math.Tests/ConstexprMathTests.cpp">ConstexprMathTests.cpp</a>.</p>

<p><a href="https://github.com/Harlinn/Harlinn.Windows/tree/master/Tests/Harlinn.Common.Core.Math.Tests">Harlinn.Common.Core.Math.Tests</a> contains 663 test cases, 
striving to demonstrate the accuracy of the computations. Be aware that running the release build of the full test suite takes nearly an hour,
as several of the tests seeks to determine the result for every possible input, or very large subsets of the possible inputs - comparing
the results with those produced by the standard implementation.</p>

<h3 id="benchmarks">Benchmarks</h3>

<p>The performance of the functions is benchmarked using the <a href="https://github.com/google/benchmark">Google benchmark</a> library, 
and can be verified by building and executing <a href="https://github.com/Harlinn/Harlinn.Windows/tree/master/Benchmarks/Math/BasicMathBenchmarks">BasicMathBenchmarks</a> 
included in the <a href="/Cpp/Harlinn.Windows/Harlinn.Windows.html">Harlinn.Windows solution</a>.</p>

<p><a href="Benchmarks.html">Benchmarks</a> for a single inline function cannot be relied upon to accurately determine how well the 
function will perform perform in a real application. For release builds, the compiler and linker,
employs global optimization strategies, attempting to optimize the operations across all
the compilation units. The global optimization strategies will often find optimization
opportunities that are very hard to detect and implement manually, and the only way to really determine
if one set of functions performs better than another, is to try them out in a real, computationally intensive,
application.</p>

<p>It is, however, unlikely that a set of functions that performs worse than another, in a reasonable
set of benchmarks, can outperform the other in a real application.</p>

<h3 id="pbrto-a-micro-optimized-raytracing-app">PBRTO a micro optimized raytracing app</h3>

<p>PBRTO is a micro optimized version of <a href="https://github.com/mmp/pbrt-v4">PBRT-v4</a>, under development 
as an example of how the functionality in <code class="language-plaintext highlighter-rouge">HCCMath.h</code>, <code class="language-plaintext highlighter-rouge">HCCSIMD.h</code> and <code class="language-plaintext highlighter-rouge">HCCVectorMath.h</code> can be used to 
optimize the performance of real, computationally intensive, apps. It’s now about <code class="language-plaintext highlighter-rouge">91</code> % 
faster than the release build of the original PBRT. <a href="pbrto.html">more…</a></p>

<h2 id="background">Background</h2>

<p>The functions were created to explore <code class="language-plaintext highlighter-rouge">constexpr</code> evaluation of mathematical expressions, since nothing
improves runtime performance as much as making the compiler calculate the results at compile time.</p>

<p>Since <code class="language-plaintext highlighter-rouge">constexpr</code> evaluation doesn’t allow undefined behavior, this can also be used to eliminate 
a wide range of subtle, and hard to find, errors in code using <code class="language-plaintext highlighter-rouge">HCCMath.h</code> that currently 
cannot be <code class="language-plaintext highlighter-rouge">constexpr</code> evaluated using the standard libraries.</p>

<p>Much of the code is based on version <code class="language-plaintext highlighter-rouge">0.8.5</code> of the <a href="https://github.com/JuliaMath/openlibm">OpenLibm</a> 
mathematical C library used by the <a href="https://julialang.org/">Julia</a> programming language.</p>

<p>The library does not include the <a href="https://github.com/JuliaMath/openlibm">OpenLibm</a> floating
point environment, and relies on the floating point environment provided by the
Visual C++ runtime.</p>

<p>Some functions, like <code class="language-plaintext highlighter-rouge">Sin</code>, can only perform <code class="language-plaintext highlighter-rouge">constexpr</code> evaluation for a subset of the
possible arguments. <code class="language-plaintext highlighter-rouge">Sin</code> has no problems with <code class="language-plaintext highlighter-rouge">constexpr</code> evaluation for \(\pm 20000^\circ\),
but fails to <code class="language-plaintext highlighter-rouge">constexpr</code> evaluate <code class="language-plaintext highlighter-rouge">Sin(1.7976931348623158e+308)</code>.</p>

<p>The API is template based, which may seem odd, but this helps to reduce the number of
unintended conversions between numeric types. Most functions designed to work with 
floating point values do not accept integer values without an explicit cast to
<code class="language-plaintext highlighter-rouge">float</code> or <code class="language-plaintext highlighter-rouge">double</code>.</p>

<h3 id="implementation-quality">Implementation quality</h3>

<p>The quality of the implementation is, since it is based on <a href="https://github.com/JuliaMath/openlibm">OpenLibm</a>,
high. <a href="https://github.com/JuliaMath/openlibm">OpenLibm</a> does many things very well, but sometimes
the Visual C++ runtime, an intrinsic function, or another alternative implemented by the library, perform 
better. When this is the case, the library selects the implementation with the best runtime performance.</p>

<p>Since some functions are implemented differently for <code class="language-plaintext highlighter-rouge">constexpr</code> evaluation, they will not return
identical results when executed at runtime. The difference is small; and can, in most cases, be ignored,
as in these cases both implementations are based on approximations.</p>

<h3 id="testing-the-runtime-function-evaluation">Testing the runtime function evaluation</h3>

<p>Changes to the <a href="https://github.com/JuliaMath/openlibm">OpenLibm</a> code was required to
enable <code class="language-plaintext highlighter-rouge">constexpr</code> evaluation since constructs like <code class="language-plaintext highlighter-rouge">(x - x)/(x - x)</code> makes Visual C++ unhappy. So
does <code class="language-plaintext highlighter-rouge">goto</code>s, <code class="language-plaintext highlighter-rouge">x/0.</code>, unions, <code class="language-plaintext highlighter-rouge">const</code>, <code class="language-plaintext highlighter-rouge">static</code> and <code class="language-plaintext highlighter-rouge">volatile</code> declarations; necessitating quite a few changes.</p>

<p>Several of the tests execute the function under test 20 000 times using random generated values, while
others try every possible value over the range of values most often used with the function.</p>

<p>The functions in the <code class="language-plaintext highlighter-rouge">Math</code> namespace that use the <code class="language-plaintext highlighter-rouge">constepr</code> path implementation
at runtime are thoroughly tested, and the tests tries to determine the maximum 
deviation between the standard function and the corresponding function in the <code class="language-plaintext highlighter-rouge">Math</code> namespace.</p>

<p>Deviation is calculated by the <code class="language-plaintext highlighter-rouge">Deviation</code> function below.</p>

<p>The value passed for the first argument is the expected result, usually calculated using
the standard implementation, while the value calculated by the corresponding function
in the <code class="language-plaintext highlighter-rouge">Math</code> namespace is passed as the second argument.</p>

<pre><code class="language-C++">inline double Deviation( double first, double second )
{
    // If both is NaN, the results don't deviate
    if ( std::isnan( first ) )
    {
        if ( std::isnan( second ) )
        {
            return 0.0;
        }
        return std::numeric_limits&lt;double&gt;::infinity( );
    }
    else if ( std::isnan( second ) )
    {
        // The second value is NaN, but not the first
        return std::numeric_limits&lt;double&gt;::infinity( );
    }
    if ( std::isinf( first ) )
    {
        if ( std::isinf( second ) )
        {
            if ( first &gt; 0. &amp;&amp; second &gt; 0. )
            {
                // Both values are +infinity
                return 0;
            }
            else if ( first &lt; 0. &amp;&amp; second &lt; 0. )
            {
                // Both values are -infinity
                return 0;
            }
            // Opposite signs
            return std::numeric_limits&lt;double&gt;::infinity( );
        }
        // only the first value is infinite
        return std::numeric_limits&lt;double&gt;::infinity( );
    }
    else if ( std::isinf( second ) )
    {
        // only the second value is infinite
        return std::numeric_limits&lt;double&gt;::infinity( );
    }

    // Avoid division by zero
    if ( first != 0.0 )
    {
        using std::abs;
        if ( first &lt;= second )
        {
            return abs( second - first ) / abs( first );
        }
        else
        {
            return abs( first - second ) / abs( first );
        }
    }
    else
    {
        // When second is very close to zero, the result is zero deviation
        constexpr double veryCloseToZero = 5e-323;
        auto absSecond = abs( second );
        if ( absSecond &lt;= veryCloseToZero )
        {
            return 0.0;
        }
        // May still be very close to zero, but will cause the test to fail.
        return 1.0;
    }
}
</code></pre>

<h3 id="exceptional-performance">Exceptional performance</h3>

<p>A few functions outperforms the standard implementation spectacularly, like <code class="language-plaintext highlighter-rouge">Exp</code> 
which outperforms <code class="language-plaintext highlighter-rouge">std::exp</code> by <code class="language-plaintext highlighter-rouge">1200</code> %.</p>

<p>The two implementations returns the same result for <code class="language-plaintext highlighter-rouge">2261694913</code> out of <code class="language-plaintext highlighter-rouge">2288746510</code> cases, 
and when tested with double precision floating point argument values, uniformly distributed
over the interval <code class="language-plaintext highlighter-rouge">[-744.0, 710.0]</code>, the maximum deviation, <code class="language-plaintext highlighter-rouge">1.56426946755e-12</code>
was obtained when passing <code class="language-plaintext highlighter-rouge">-717.256469727</code> as the argument to the functions.</p>

<h3 id="using-simdtraitstn">Using <code class="language-plaintext highlighter-rouge">SIMD::Traits&lt;T.N&gt;</code></h3>

<p>Some functions, like <code class="language-plaintext highlighter-rouge">Hypot</code>, use the <a href="SimdOperations.html"><code class="language-plaintext highlighter-rouge">SIMD::Traits&lt;T.N&gt;</code> specializations</a> to achieve excellent runtime performance.</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
constexpr inline std::remove_cvref_t&lt;T&gt; Hypot( T x, T y, T z ) noexcept
{
    if ( std::is_constant_evaluated( ) )
    {
        return Math::Internal::OpenLibM::FastHypot( x, y );
    }
    else
    {
        using FloatT = std::remove_cvref_t&lt;T&gt;;
        using Traits = SIMD::Traits&lt;FloatT, 3&gt;;

        auto v = Traits::Set( z, y, x );
        v = Traits::Mul( v, v );
        v = Traits::HSum( v );
        v = Traits::Sqrt( v );
        return Traits::First( v );
    }
}
</code></pre>

<h3 id="using-the-standard-and-the-internal-implementation-at-runtime">Using the standard, and the internal, implementation at runtime.</h3>

<p><code class="language-plaintext highlighter-rouge">Math::Internal::TanImpl</code> performs about 40 % worse than <code class="language-plaintext highlighter-rouge">std::tan</code>, for double precision
floating point values, but <code class="language-plaintext highlighter-rouge">Math::Internal::TanImpl</code> beats <code class="language-plaintext highlighter-rouge">std::tan</code>, for single precision
floating point values, by more than <code class="language-plaintext highlighter-rouge">60</code> %, and splitting the execution path between 
<code class="language-plaintext highlighter-rouge">Math::Internal::TanImpl</code> for single precision floating point values, and <code class="language-plaintext highlighter-rouge">std::tan</code>
provides the best solution:</p>

<pre><code class="language-C++">template&lt;typename T&gt;
    requires IsFloatingPoint&lt;T&gt;
constexpr inline std::remove_cvref_t&lt;T&gt; Tan( T x ) noexcept
{
    using FloatT = std::remove_cvref_t&lt;T&gt;;
    if ( std::is_constant_evaluated( ) )
    {
        if constexpr ( std::is_same_v&lt;FloatT, float&gt; )
        {
            return Math::Internal::OpenLibM::tanf( x );
        }
        else
        {
            return Math::Internal::OpenLibM::tan( x );
        }
    }
    else
    {
        if constexpr ( std::is_same_v&lt;FloatT, float&gt; )
        {
            return Math::Internal::OpenLibM::tanf( x );
        }
        else
        {
            return std::tan( x );
        }
    }
}
</code></pre>

<p>The runtime execution path for each function is selected based on its performance 
in the <a href="Benchmarks.html">benchmarks</a>.</p>

<h2 id="basic-operations">Basic operations</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Abs</code> which returns the absolute value \(|x|\) for <code class="language-plaintext highlighter-rouge">x</code>, is implemented for 
floating point types, signed integers and unsigned integers. Calls <code class="language-plaintext highlighter-rouge">std::abs</code>
at runtime.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FMod</code> which calculate the remainder of a floating point division operation, 
is implemented for floating point types.</p>

    <p><code class="language-plaintext highlighter-rouge">FMod</code> outperforms <code class="language-plaintext highlighter-rouge">std::fmod</code> by approximately <code class="language-plaintext highlighter-rouge">60</code> % for double precision floating
point values, and by <code class="language-plaintext highlighter-rouge">40</code> % for single precision floating point values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Max</code> which returns the greater of to values, is implemented for floating point types.</p>

    <p><code class="language-plaintext highlighter-rouge">Max</code> calls <code class="language-plaintext highlighter-rouge">std::max</code> at compile time, and at runtime it calls <code class="language-plaintext highlighter-rouge">_mm_max_ss</code> for single 
precision floating point values, and <code class="language-plaintext highlighter-rouge">std::max</code> for double precision floating
point values. This improves the performance, on the average, by <code class="language-plaintext highlighter-rouge">10</code> % for single 
precision floating point values. It varies between <code class="language-plaintext highlighter-rouge">2</code> % and <code class="language-plaintext highlighter-rouge">30</code> % for each run 
of the benchmarks.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Min</code> which returns the lesser of to values, is implemented for floating point types.</p>

    <p><code class="language-plaintext highlighter-rouge">Min</code> calls <code class="language-plaintext highlighter-rouge">std::min</code> at compile time, and at runtime it calls <code class="language-plaintext highlighter-rouge">_mm_min_ss</code> for single 
precision floating point values, and <code class="language-plaintext highlighter-rouge">std::min</code> for double precision floating
point values. This improves the performance, on the average, by <code class="language-plaintext highlighter-rouge">7</code> % for single 
precision floating point values. It varies between <code class="language-plaintext highlighter-rouge">-2</code> % and <code class="language-plaintext highlighter-rouge">20</code> % for each run 
of the benchmarks.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">IsSameValue</code> checks for binary equality between two floating point values.</p>
  </li>
</ul>

<h2 id="exponential-functions">Exponential functions</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Exp</code> returns <strong>e</strong> raised to the given power (<strong>e</strong><sup><code class="language-plaintext highlighter-rouge">x</code></sup>).</p>

    <p><code class="language-plaintext highlighter-rouge">Exp</code> outperforms <code class="language-plaintext highlighter-rouge">std::exp</code> by approximately <code class="language-plaintext highlighter-rouge">1200</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">1000</code> % for single precision floating point values.</p>

    <p>The maximum detected deviation between <code class="language-plaintext highlighter-rouge">std::exp</code> and <code class="language-plaintext highlighter-rouge">Exp</code> is <code class="language-plaintext highlighter-rouge">1.18844e-07</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">2.18599e-16</code> for double precision floating point values, for argument
values in the range <code class="language-plaintext highlighter-rouge">-9</code> to <code class="language-plaintext highlighter-rouge">10</code>, tested with a uniform random distribution of <code class="language-plaintext highlighter-rouge">10'000</code> values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Log</code> computes natural, base <strong>e</strong>, logarithm (ln x)</p>

    <p><code class="language-plaintext highlighter-rouge">Log</code> outperforms <code class="language-plaintext highlighter-rouge">std::log</code> by approximately <code class="language-plaintext highlighter-rouge">260</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">400</code> % for single precision floating point values.</p>

    <p>The maximum detected deviation between <code class="language-plaintext highlighter-rouge">std::log</code> and <code class="language-plaintext highlighter-rouge">Log</code> is <code class="language-plaintext highlighter-rouge">1.18795e-07</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">2.04848e-16</code> for double precision floating point values, for argument
values in the range <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">100000</code>, tested with a uniform random distribution of <code class="language-plaintext highlighter-rouge">10'000</code> values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Log2</code> base 2 logarithm of the given number (log<sub>2</sub><code class="language-plaintext highlighter-rouge">x</code>).</p>

    <p><code class="language-plaintext highlighter-rouge">Log2</code> outperforms <code class="language-plaintext highlighter-rouge">std::log2</code> by approximately <code class="language-plaintext highlighter-rouge">270</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">250</code> % for single precision floating point values.</p>

    <p>The maximum detected deviation between <code class="language-plaintext highlighter-rouge">std::log2</code> and <code class="language-plaintext highlighter-rouge">Log2</code> is <code class="language-plaintext highlighter-rouge">1.18288e-07</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">2.1882e-16</code> for double precision floating point values, for argument
values in the range <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">100000</code>, tested with a uniform random distribution of <code class="language-plaintext highlighter-rouge">10'000</code> values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Log10</code> computes common (base 10) logarithm (log<sub>10</sub><code class="language-plaintext highlighter-rouge">x</code> )</p>

    <p><code class="language-plaintext highlighter-rouge">Log10</code> outperforms <code class="language-plaintext highlighter-rouge">std::log10</code> by approximately <code class="language-plaintext highlighter-rouge">360</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">390</code> % for single precision floating point values.</p>

    <p>The maximum detected deviation between <code class="language-plaintext highlighter-rouge">std::log10</code> and <code class="language-plaintext highlighter-rouge">Log10</code> is <code class="language-plaintext highlighter-rouge">1.18216e-07</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">2.0154e-16</code> for double precision floating point values, for argument
values in the range <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">100000</code>, tested with a uniform random distribution of <code class="language-plaintext highlighter-rouge">10'000</code> values.</p>
  </li>
</ul>

<h2 id="power-functions">Power functions</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Sqrt</code> computes square root (√<code class="language-plaintext highlighter-rouge">x</code>)</p>

    <p>Calls <code class="language-plaintext highlighter-rouge">_mm_sqrt_pd</code> or <code class="language-plaintext highlighter-rouge">_mm_sqrt_ps</code> at runtime.</p>

    <p><code class="language-plaintext highlighter-rouge">Sqrt</code> outperforms <code class="language-plaintext highlighter-rouge">std::sqrt</code> by approximately <code class="language-plaintext highlighter-rouge">1400</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">1300</code> % for single precision floating point values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Hypot</code> computes square root of the sum of the squares of two or three numbers.</p>

    <p>The two argument version of <code class="language-plaintext highlighter-rouge">Hypot</code> outperforms <code class="language-plaintext highlighter-rouge">std::hypot</code> by approximately <code class="language-plaintext highlighter-rouge">270</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">230</code> % for single precision floating point values.</p>

    <p>The three argument version of <code class="language-plaintext highlighter-rouge">Hypot</code> outperforms <code class="language-plaintext highlighter-rouge">std::hypot</code> by approximately <code class="language-plaintext highlighter-rouge">190</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">320</code> % for single precision floating point values.</p>
  </li>
</ul>

<h2 id="trigonometric-functions">Trigonometric functions</h2>

<p>Graphic intensive application are highly sensitive to the performance of 
the trigonometric functions, especially for single precision floating point values.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Sin</code> computes the sine of its argument given in radians.</p>

    <p><code class="language-plaintext highlighter-rouge">Sin</code> calls <code class="language-plaintext highlighter-rouge">std::sin</code> at runtime for both single and double precision values.</p>

    <p>The <code class="language-plaintext highlighter-rouge">constexpr</code> path for <code class="language-plaintext highlighter-rouge">Sin</code> outperforms <code class="language-plaintext highlighter-rouge">std::sin</code> by approximately <code class="language-plaintext highlighter-rouge">100</code> % for single precision 
floating point values, but performs worse when both the sine and the cosine
is calculated for the same value.</p>

    <p>The maximum deviation between <code class="language-plaintext highlighter-rouge">std::sin</code> and the <code class="language-plaintext highlighter-rouge">constexpr</code> path for <code class="language-plaintext highlighter-rouge">Sin</code> is <code class="language-plaintext highlighter-rouge">1.19182e-07</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">2.22045e-16</code> for double precision floating point values, tested for all possible single 
precision floating point argument values for in the range <code class="language-plaintext highlighter-rouge">-((2*pi)+epsilon)</code> to <code class="language-plaintext highlighter-rouge">((2*pi)+epsilon)</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Cos</code> computes the cosine of its argument given in radians.</p>

    <p><code class="language-plaintext highlighter-rouge">Cos</code> calls <code class="language-plaintext highlighter-rouge">std::cos</code> at runtime for both single and double precision values.</p>

    <p>The <code class="language-plaintext highlighter-rouge">constexpr</code> path for <code class="language-plaintext highlighter-rouge">Cos</code> outperforms <code class="language-plaintext highlighter-rouge">std::cos</code> by approximately <code class="language-plaintext highlighter-rouge">110</code> % for single precision 
floating point values, but performs worse when both the sine and the cosine
is calculated for the same value.</p>

    <p>The maximum deviation between <code class="language-plaintext highlighter-rouge">std::cos</code> and the <code class="language-plaintext highlighter-rouge">constexpr</code> path for <code class="language-plaintext highlighter-rouge">Cos</code> is <code class="language-plaintext highlighter-rouge">1.19187e-07</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">2.22044e-16</code> for double precision floating point values, tested for all possible single 
precision floating point argument values for in the range <code class="language-plaintext highlighter-rouge">-((2*pi)+epsilon)</code> to <code class="language-plaintext highlighter-rouge">((2*pi)+epsilon)</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Tan</code> computes the tangent of its argument given in radians.</p>

    <p><code class="language-plaintext highlighter-rouge">Tan</code> outperforms <code class="language-plaintext highlighter-rouge">std::tan</code> by approximately <code class="language-plaintext highlighter-rouge">60</code> % for single precision 
floating point values,</p>

    <p><code class="language-plaintext highlighter-rouge">Tan</code> calls std::tan at runtime, with a consistent performance penalty of about <code class="language-plaintext highlighter-rouge">20</code> %
compared to calling <code class="language-plaintext highlighter-rouge">std::tan</code> directly for double precision floating point values.</p>

    <p>The maximum deviation between <code class="language-plaintext highlighter-rouge">std::tan</code> and the <code class="language-plaintext highlighter-rouge">constexpr</code> path for <code class="language-plaintext highlighter-rouge">Tan</code> is <code class="language-plaintext highlighter-rouge">1.19209e-07</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">2.22045e-16</code> for double precision floating point values, tested for all possible single 
precision floating point argument values for in the range <code class="language-plaintext highlighter-rouge">-((2*pi)+epsilon)</code> to <code class="language-plaintext highlighter-rouge">((2*pi)+epsilon)</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ASin</code> computes arc sine of its argument.</p>

    <p><code class="language-plaintext highlighter-rouge">ASin</code> outperforms <code class="language-plaintext highlighter-rouge">std::asin</code> by approximately <code class="language-plaintext highlighter-rouge">20</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">30</code> % for single precision floating point values.</p>

    <p>The maximum deviation between <code class="language-plaintext highlighter-rouge">std::asin</code> and <code class="language-plaintext highlighter-rouge">ASin</code> is <code class="language-plaintext highlighter-rouge">2.27673e-07</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">2.22044e-16</code> for double precision floating point values, tested for all possible single 
precision floating point argument values for in the range <code class="language-plaintext highlighter-rouge">-1.0</code> to <code class="language-plaintext highlighter-rouge">1.0</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ACos</code> computes the arc cosine of its argument.</p>

    <p><code class="language-plaintext highlighter-rouge">ACos</code> outperforms <code class="language-plaintext highlighter-rouge">std::acos</code> by approximately <code class="language-plaintext highlighter-rouge">30</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">50</code> % for single precision floating point values.</p>

    <p>The maximum deviation between <code class="language-plaintext highlighter-rouge">std::acos</code> and <code class="language-plaintext highlighter-rouge">ACos</code> is <code class="language-plaintext highlighter-rouge">1.19209e-07</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">2.22044e-16</code> for double precision floating point values, tested for all possible single 
precision floating point argument values for in the range <code class="language-plaintext highlighter-rouge">-1.0</code> to <code class="language-plaintext highlighter-rouge">1.0</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ATan</code> computes the arc tangent of its argument.</p>

    <p><code class="language-plaintext highlighter-rouge">ATan</code> outperforms <code class="language-plaintext highlighter-rouge">std::atan</code> by approximately <code class="language-plaintext highlighter-rouge">5</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">30</code> % for single precision floating point values.</p>

    <p>The maximum detected deviation between <code class="language-plaintext highlighter-rouge">std::atan</code> and <code class="language-plaintext highlighter-rouge">ATan</code> is <code class="language-plaintext highlighter-rouge">0.0</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">0.0</code> for double precision floating point values, tested with a 
uniform random distribution of <code class="language-plaintext highlighter-rouge">10'000</code> values in the range <code class="language-plaintext highlighter-rouge">-10'000</code> to <code class="language-plaintext highlighter-rouge">10'000</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ATan2</code> computes the arc tangent of <code class="language-plaintext highlighter-rouge">y</code> / <code class="language-plaintext highlighter-rouge">x</code>, its two arguments, using signs 
to determine quadrants.</p>

    <p><code class="language-plaintext highlighter-rouge">ATan2</code> outperforms <code class="language-plaintext highlighter-rouge">std::atan2</code> by approximately <code class="language-plaintext highlighter-rouge">20</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">40</code> % for single precision floating point values.</p>

    <p>The maximum detected deviation between <code class="language-plaintext highlighter-rouge">std::atan2</code> and <code class="language-plaintext highlighter-rouge">ATan2</code> is <code class="language-plaintext highlighter-rouge">0.0</code> for single precision
floating point values, and <code class="language-plaintext highlighter-rouge">0.0</code> for double precision floating point values, tested with a 
uniform random distribution of <code class="language-plaintext highlighter-rouge">10'000</code> values in the range <code class="language-plaintext highlighter-rouge">-10'000</code> to <code class="language-plaintext highlighter-rouge">10'000</code>.</p>
  </li>
</ul>

<h2 id="nearest-integral-value-floating-point-operations">Nearest integral value floating point operations</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Ceil</code> computes the nearest integral value not less than the given value.</p>

    <p><code class="language-plaintext highlighter-rouge">Ceil</code> calls <code class="language-plaintext highlighter-rouge">__ceil</code> or <code class="language-plaintext highlighter-rouge">__ceilf</code> at runtime.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Floor</code> computes the nearest integral value not greater than the given value.</p>

    <p><code class="language-plaintext highlighter-rouge">Floor</code> calls <code class="language-plaintext highlighter-rouge">__floor</code> or <code class="language-plaintext highlighter-rouge">__floorf</code> at runtime.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Trunc</code> computes the nearest integral value not greater in magnitude than the given value.</p>

    <p><code class="language-plaintext highlighter-rouge">Trunc</code> calls <code class="language-plaintext highlighter-rouge">__truncf</code> at runtime for single precision floating point numbers,
and calls <code class="language-plaintext highlighter-rouge">_mm_round_pd</code> double precision floating point numbers, improving performance
by <code class="language-plaintext highlighter-rouge">320</code> %.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Round</code> computes the nearest integral value, rounding away from zero in halfway cases.</p>

    <p><code class="language-plaintext highlighter-rouge">Round</code> calls <code class="language-plaintext highlighter-rouge">__roundf</code> at runtime for single precision floating point numbers,
and calls <code class="language-plaintext highlighter-rouge">_mm_round_pd</code> double precision floating point numbers, improving performance
by <code class="language-plaintext highlighter-rouge">500</code> %.</p>
  </li>
</ul>

<h2 id="floating-point-manipulation-functions">Floating point manipulation functions</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">FRExp</code> decomposes a number into significand and base-2 exponent.</p>

    <p><code class="language-plaintext highlighter-rouge">FRExp</code> outperforms <code class="language-plaintext highlighter-rouge">std::frexp</code> by approximately <code class="language-plaintext highlighter-rouge">450</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">550</code> % for single precision floating point values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ModF</code> decomposes a number into integer and fractional parts.</p>

    <p><code class="language-plaintext highlighter-rouge">ModF</code> outperforms <code class="language-plaintext highlighter-rouge">std::modf</code> by approximately <code class="language-plaintext highlighter-rouge">60</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">50</code> % for single precision floating point values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ScaleByN</code> multiplies a number by FLT_RADIX raised to a power.</p>

    <p><code class="language-plaintext highlighter-rouge">ScaleByN</code> outperforms <code class="language-plaintext highlighter-rouge">std::scalbn</code> by approximately <code class="language-plaintext highlighter-rouge">90</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">170</code> % for single precision floating point values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NextAfter</code> next representable floating-point value towards the given value.</p>

    <p><code class="language-plaintext highlighter-rouge">NextAfter</code> outperforms <code class="language-plaintext highlighter-rouge">std::nextafter</code> by approximately <code class="language-plaintext highlighter-rouge">40</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">90</code> % for single precision floating point values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NextUp</code> Return the smallest floating point number y of the same 
type as x such that x &lt; y. If no such y exists, e.g. if x is Inf or NaN, then return x.</p>

    <p>The standard C++ implementation is <code class="language-plaintext highlighter-rouge">std::nextafter( x, std::numeric_limits&lt;double&gt;::infinity( ) )</code>.</p>

    <p><code class="language-plaintext highlighter-rouge">NextUp</code> outperforms <code class="language-plaintext highlighter-rouge">std::nextafter</code> by approximately <code class="language-plaintext highlighter-rouge">1400</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">1300</code> % for single precision floating point values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">NextDown</code> Return the largest floating point number y of the same type 
as x such that y &lt; x. If no such y exists, e.g. if x is -Inf or NaN, then return x.</p>

    <p>The standard C++ implementation is <code class="language-plaintext highlighter-rouge">std::nextafter( x, -std::numeric_limits&lt;double&gt;::infinity( ) )</code>.</p>

    <p><code class="language-plaintext highlighter-rouge">NextDown</code> outperforms <code class="language-plaintext highlighter-rouge">std::nextafter</code> by approximately <code class="language-plaintext highlighter-rouge">210</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">330</code> % for single precision floating point values.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CopySign</code> copies the sign of a floating point value.</p>

    <p><code class="language-plaintext highlighter-rouge">NextDown</code> outperforms <code class="language-plaintext highlighter-rouge">std::nextafter</code> by approximately <code class="language-plaintext highlighter-rouge">300</code> % for double precision floating
point values, and by approximately <code class="language-plaintext highlighter-rouge">10</code> % for single precision floating point values.</p>
  </li>
</ul>

<h2 id="classification-and-comparison">Classification and comparison</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">IsNaN</code> checks if the given number is NaN.</p>

    <p><code class="language-plaintext highlighter-rouge">IsNaN</code> calls <code class="language-plaintext highlighter-rouge">std::isnan</code> at runtime.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">IsInf</code> checks if the given number is infinite.</p>

    <p><code class="language-plaintext highlighter-rouge">IsInf</code> calls <code class="language-plaintext highlighter-rouge">std::isinf</code> for double precision floating point values, and
outperforms <code class="language-plaintext highlighter-rouge">std::isinf</code> for single precision floating point values by <code class="language-plaintext highlighter-rouge">40</code> %.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SignBit</code> checks if the given number is negative.</p>

    <p><code class="language-plaintext highlighter-rouge">SignBit</code> outperforms <code class="language-plaintext highlighter-rouge">std::signbit</code> by approximately <code class="language-plaintext highlighter-rouge">50</code> % for both double and 
single precision floating point values.</p>
  </li>
</ul>

<h2 id="other-computations">Other computations</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Clamp</code> If the a value is within [minimumValue, maximumValue], the function 
returns the value, otherwise it returns the nearest boundary.</p>

    <p><code class="language-plaintext highlighter-rouge">Clamp</code> calls <code class="language-plaintext highlighter-rouge">std::clamp</code> at runtime.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Lerp</code> Computes the linear interpolation between a and b, if the 
parameter t is inside [​0​, 1), the linear extrapolation otherwise, 
i.e. the result of a + t * ( b - a ) with accounting 
for floating point calculation imprecision.</p>

    <p><code class="language-plaintext highlighter-rouge">Lerp</code> calls <code class="language-plaintext highlighter-rouge">std::lerp</code> at runtime.</p>
  </li>
</ul>


  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Harlinn</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Harlinn</li><li><a class="u-email" href="mailto:espen@harlinn.no">espen@harlinn.no</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Harlinn"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Harlinn</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is my personal site. </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

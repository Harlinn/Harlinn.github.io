<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Single Instruction Multiple Data (SIMD) | Harlinn</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Single Instruction Multiple Data (SIMD)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is my personal Github site," />
<meta property="og:description" content="This is my personal Github site," />
<link rel="canonical" href="https://harlinn.github.io/Cpp/Cpp/Math/SimdOperations.html" />
<meta property="og:url" content="https://harlinn.github.io/Cpp/Cpp/Math/SimdOperations.html" />
<meta property="og:site_name" content="Harlinn" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Single Instruction Multiple Data (SIMD)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"This is my personal Github site,","headline":"Single Instruction Multiple Data (SIMD)","url":"https://harlinn.github.io/Cpp/Cpp/Math/SimdOperations.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://harlinn.github.io/feed.xml" title="Harlinn" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Harlinn</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/Cpp/Cpp.html">C++</a><a class="page-link" href="/Databases/Databases.html">Databases</a><a class="page-link" href="/DotNet/DotNet.html">.Net</a><a class="page-link" href="/Java/Java.html">Java</a><a class="page-link" href="/Julia/Julia.html">Julia</a><a class="page-link" href="/Python/Python.html">Python</a><a class="page-link" href="/R/R.html">R</a><a class="page-link" href="/Rust/Rust.html">Rust</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Single Instruction Multiple Data (SIMD)</h1>
  </header>

  <div class="post-content">
    <p>Single Instruction Multiple Data (SIMD) is a parallel computing technolgy 
where a single instruction is executed simultaneously on multiple data 
points. The technolgy is often used to implement artificial intelligence (AI), 
machine learning (ML), and other data science solutions. SIMD is a key 
feature of modern processors, enabling efficient data processing and increasing 
computational performance. As demand for high-performance computing continues 
to grow, understanding and using SIMD will be increasingly important for 
optimizing applications and algorithms.</p>

<ul>
  <li><a href="#single-instruction-multiple-data">Single Instruction Multiple Data</a></li>
  <li><a href="#fast-linear-algebra-for-games-and-graphics">Fast Linear Algebra for Games and Graphics</a></li>
</ul>

<h1 id="single-instruction-multiple-data">Single Instruction Multiple Data</h1>
<p>The interface to SIMD operations in <a href="/Cpp/Harlinn.Windows/Harlinn.Common.Core/Harlinn.Common.Core.html">Harlinn.Common.Core</a> 
is provided in <code class="language-plaintext highlighter-rouge">HCCSIMD.h</code> contained within the <code class="language-plaintext highlighter-rouge">Harlinn::Common::Core::SIMD</code> namespace through a set of specializations
of the template:</p>

<pre><code class="language-C++">template&lt;typename T, size_t N&gt;
struct Traits : public std::false_type
{
};
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">Traits&lt;T,N&gt;</code> specializations provides access to the SIMD intrinsic functions, 
and strives to maintain a uniform set of names for the implemented functions. The
second template argument is sometimes used to select function implementations
optimized for <code class="language-plaintext highlighter-rouge">N</code> elements in the SIMD type.</p>

<p>Where <code class="language-plaintext highlighter-rouge">T</code> is the type of the values to use in the computations, and <code class="language-plaintext highlighter-rouge">N</code> is 
the number of valid elements in the SIMD type. The SIMD type is a representation 
of a CPU register used for SIMD operations. The Intel/AMD x64 architecture
provides several SIMD types:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">__m128</code> types: These types are used with the Streaming SIMD Extensions and Streaming SIMD Extensions 2 instructions intrinsics, and maps to the XMM[0-7] registers.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">__m128</code>: Holds four 32-bit floating point values.</li>
      <li><code class="language-plaintext highlighter-rouge">__m128i</code>: Holds sixteen 8-bit, eight 16-bit, four 32-bit, or two 64-bit integer values.</li>
      <li><code class="language-plaintext highlighter-rouge">__m128d</code>: Holds two 64-bit floating point values.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">__m256</code> types: These types are used with the AVX/AVX2 extensions, and maps to the YMM[0-15] registers.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">__m256</code>: Holds eight 32-bit floating point values.</li>
      <li><code class="language-plaintext highlighter-rouge">__m256i</code>: Holds thirty-two 8-bit, sixteen 16-bit, eight 32-bit, or four 64-bit integer values.</li>
      <li><code class="language-plaintext highlighter-rouge">__m256d</code>: Holds four 64-bit double precision floating point values.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">__m512</code> types: These types are used with the AVX 512 extensions, and maps to the ZMM[0-31] registers.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">__m512</code>: Holds sixteen 32-bit floating point values.</li>
      <li><code class="language-plaintext highlighter-rouge">__m512i</code>: Holds sixty-four 8-bit, thirty-two 16-bit, sixteen 32-bit, or eight 64-bit integer values.</li>
      <li><code class="language-plaintext highlighter-rouge">__m512d</code>: Holds eight 64-bit double precision floating point values.</li>
    </ul>
  </li>
</ul>

<p>These data types are not basic C/C++ data types, and have several usage restrictions:</p>

<ul>
  <li>Can only be used on either side of an assignment, as a return value, or as a parameter. Cannot be used in regular arithmetic expressions <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>, etc.</li>
  <li>Can be used as objects in aggregates, such as unions, to access the byte elements and structures.</li>
  <li>Can only be operated on using intrinsic functions implemented by the compiler.</li>
</ul>

<p>Before doing any operations on SIMD type variables, they must be loaded using special intrinsic functions:</p>

<pre><code class="language-C++">_mm256_load_ps( ptrToFloats );
</code></pre>
<p>Where, in this case, <code class="language-plaintext highlighter-rouge">ptrToFloats</code> is a 32 byte aligned pointer to 8 single precision floating point values.</p>

<p>The <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">Intel Intrinsics Guide</a> contains 
a brief description of the available intrinsic functions. It’s a bit short on details, and the relevant
details can be found in the <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel 64 and IA-32 Architectures Software Developer Manuals</a>.</p>

<p>The number of available intrinsic functions can be a bit overwhelming, and the <code class="language-plaintext highlighter-rouge">Traits&lt;T,N&gt;</code> specializations
groups the intrinsic functions according to the type they are designed to work with.</p>

<p><code class="language-plaintext highlighter-rouge">Traits&lt;float,4&gt;::Swizzle&lt;0,1,2,3&gt;( v )</code> and <code class="language-plaintext highlighter-rouge">Traits&lt;double,4&gt;::Swizzle&lt;0,1,2,3&gt;( v )</code> will 
both reverse the order of the <code class="language-plaintext highlighter-rouge">4</code> elements in <code class="language-plaintext highlighter-rouge">v</code>, and the first will invoke <code class="language-plaintext highlighter-rouge">_mm_permute_ps</code> while
the second invokes <code class="language-plaintext highlighter-rouge">_mm256_permute4x64_pd</code>, not <code class="language-plaintext highlighter-rouge">_mm256_permute_pd</code> which can only swap values inside a 128 bit lane,
and not <code class="language-plaintext highlighter-rouge">_mm_permute_pd</code> which operates on the <code class="language-plaintext highlighter-rouge">__m128d</code> SIMD type and can only hold two double precision values.</p>

<p>The template arguments mimics the <code class="language-plaintext highlighter-rouge">_MM_SHUFFLE</code> macro, where the first argument selects the value
that goes into the highest position in the resulting SIMD type, the second argument selects the value
that goes into the second highest positions, the third selects the value that goes into the second lowest 
position, and the fourth selects the value that goes into the lowest position. <code class="language-plaintext highlighter-rouge">0</code> selects the value
from the lowest position in <code class="language-plaintext highlighter-rouge">v</code>, while <code class="language-plaintext highlighter-rouge">3</code> selects the value from the highest position in <code class="language-plaintext highlighter-rouge">v</code>.</p>

<p>There are more than <code class="language-plaintext highlighter-rouge">80</code> intrinsic functions with <em>permute</em> in their name, and just separating them
by the type they operate on makes SIMD development more manageable.</p>

<p>The C/C++ compiler handles register allocation and instruction scheduling, but using the SIMD extensions can be complex:</p>

<pre><code class="language-C++">auto rmm1 = _mm_shuffle_ps( a, a, _MM_SHUFFLE( 3, 0, 2, 1 ) );
auto rmm2 = _mm_shuffle_ps( b, b, _MM_SHUFFLE( 3, 1, 0, 2 ) );
auto rmm3 = _mm_mul_ps( rmm1, b );
auto rmm4 = _mm_mul_ps( rmm1, rmm2 );
auto rmm5 = _mm_shuffle_ps( rmm3, rmm3, _MM_SHUFFLE( 3, 0, 2, 1 ) );
return _mm_sub_ps( rmm4, rmm5 );
</code></pre>

<p>The above computes the cross product between two vectors, <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, each containing 
three 32-bit floating point values.</p>

<p>Using the <code class="language-plaintext highlighter-rouge">SIMD::Traits&lt;float,3&gt;</code>, reduces the above to:</p>

<pre><code class="language-C++">return SIMD::Traits&lt;float,3&gt;::Cross( a, b );
</code></pre>

<p>While:</p>

<pre><code class="language-C++">return SIMD::Traits&lt;float,2&gt;::Cross( a, b );
</code></pre>

<p>calculates the cross product for vectors with only two elements, expanding to:</p>

<pre><code class="language-C++">auto rmm1 = _mm_permute_ps( b, _MM_SHUFFLE( 0, 1, 0, 1 ) );
rmm1 = _mm_mul_ps( rmm1, a );
auto rmm2 = _mm_permute_ps( rmm1, _MM_SHUFFLE( 1, 1, 1, 1 ) );
rmm1 = _mm_sub_ss( rmm1, rmm2 );
return _mm_permute_ps( rmm1, _MM_SHUFFLE( 0, 0, 0, 0 ) );
</code></pre>

<p>Both operates on a <code class="language-plaintext highlighter-rouge">__m128</code> holding four 32-bit floating point values, but 
last one calculates the cross product using only the values contained within the two
lowest order positions of the <code class="language-plaintext highlighter-rouge">__m128</code>.</p>

<h1 id="fast-linear-algebra-for-games-and-graphics">Fast Linear Algebra for Games and Graphics</h1>

<p>The library contains a set of linear algebra classes that are optimized
for games and other graphic intensive apps. The operations are implemented
using a blend of SIMD and regular C/C++, and the code is highly optimized,
performing as well as, and sometimes outperforming, the <a href="https://github.com/microsoft/DirectXMath">DirectXMath</a>
library.</p>

<ul>
  <li><a href="#vector"><code class="language-plaintext highlighter-rouge">Vector</code></a> is template for fixed size vectors of integer or floating point values.</li>
  <li>
    <p><a href="#tuple2-tuple3-and-tuple4"><code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code></a> 
are template classes that holds <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code> or <code class="language-plaintext highlighter-rouge">4</code> integer or floating point 
values. They are used to implement specializations of <code class="language-plaintext highlighter-rouge">Vector</code> and other
classes holding <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code> or <code class="language-plaintext highlighter-rouge">4</code> integer or floating point values.</p>

    <ul>
      <li><a href="#vector2f-vector3f-vector4f-vector2i-vector3i-vector4i"><code class="language-plaintext highlighter-rouge">Vector2f</code>, <code class="language-plaintext highlighter-rouge">Vector3f</code>, <code class="language-plaintext highlighter-rouge">Vector4f</code>, <code class="language-plaintext highlighter-rouge">Vector2i</code>, <code class="language-plaintext highlighter-rouge">Vector3i</code>, <code class="language-plaintext highlighter-rouge">Vector4i</code></a></li>
      <li><a href="#normal3f-and-normal3i"><code class="language-plaintext highlighter-rouge">Normal3f</code> and <code class="language-plaintext highlighter-rouge">Normal3i</code></a></li>
      <li><a href="#point3f-and-point3i"><code class="language-plaintext highlighter-rouge">Point3f</code> and <code class="language-plaintext highlighter-rouge">Point3i</code></a></li>
    </ul>
  </li>
  <li><a href="#quaternion"><code class="language-plaintext highlighter-rouge">Quaternion</code></a></li>
</ul>

<p>The purpose of specializations of <code class="language-plaintext highlighter-rouge">SIMD::Traits&lt;T, N&gt;</code> is to have a mechanism for
selecting implementations that are implemented for <code class="language-plaintext highlighter-rouge">T</code> and optimized for <code class="language-plaintext highlighter-rouge">N</code> elements,
when developing the C++ templates classes and template functions that forms the core
of the linear algebra features of the library.</p>

<p>The <code class="language-plaintext highlighter-rouge">SIMD::Traits&lt;T, N&gt;</code> specializations are used to implement a set of C++
classes that really simplifies SIMD development. These classes are contained in 
the <code class="language-plaintext highlighter-rouge">HCCVectorMath.h</code> header file.</p>

<p>The library exploits the ability of C++ to create zero-overhead abstractions,
making client code quite readable:</p>

<pre><code class="language-C++">using Vector = Math::Vector&lt;float, 4&gt;;

Vector v1( 1.0f, 2.0f, 3.f, 1.0f );
Vector v2( 1.0f, 2.0f, 3.f, 1.0f );
Vector v3 = v1 + v2 + v1 + v2 + v1 + v2;

</code></pre>
<p>where the <code class="language-plaintext highlighter-rouge">+</code> operator is implemented as:</p>

<pre><code class="language-C++">template&lt;Internal::TupleType T, 
        Internal::TupleType U, 
        typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT operator + ( const T&amp; lhs, const U&amp; rhs ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Add( Traits::Load( lhs.values.data( ) ), 
                            Traits::Load( rhs.values.data( ) ) );
}
</code></pre>

<p>Which the compiler turns into:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    using Vector = Math::Vector&lt;float, 4&gt;;

    Vector v1( 1.0f, 2.0f, 3.f, 1.0f );
00007FF6C7F162D8  vmovdqu     xmm4,xmmword ptr [__xmm@3f80000040400000400000003f800000 (07FF6C8387F60h)]  
    Vector v2( 1.0f, 2.0f, 3.f, 1.0f );
    Vector v3 = v1 + v2 + v1 + v2 + v1 + v2;
00007FF6C7F162E0  vaddps      xmm0,xmm4,xmm4  
00007FF6C7F162E4  vaddps      xmm1,xmm0,xmm4  
00007FF6C7F162E8  vaddps      xmm2,xmm1,xmm4  
00007FF6C7F162EC  vaddps      xmm3,xmm2,xmm4  
00007FF6C7F162F0  vaddps      xmm6,xmm3,xmm4  
</code></pre></div></div>

<p>The compiler detects that the two vectors are identical, and only
do a single load of the data into xmm4, and then generates 
code for the additions. Obviously <code class="language-plaintext highlighter-rouge">v1</code> could just be multiplied by 6.</p>

<p>The important thing is that <b>there are no unnecessary artifacts</b> caused 
by using the classes.</p>

<p>Rearranging, and grouping, the terms:</p>

<pre><code class="language-C++">Vector v3 = ( v1 + v2 ) + ( v1 + v2 ) + ( v1 + v2 );
</code></pre>

<p>improves the generated code significantly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00007FF6BC1F39E8  vaddps      xmm1,xmm6,xmm6  
00007FF6BC1F39EC  vaddps      xmm0,xmm1,xmm1  
00007FF6BC1F39F0  vaddps      xmm1,xmm0,xmm1 
</code></pre></div></div>
<p>Reducing the number of <code class="language-plaintext highlighter-rouge">vaddps</code> operations to just three.</p>

<p>Doing the same thing using <a href="https://github.com/microsoft/DirectXMath">DirectXMath</a> 
requires a bit more work:</p>

<pre><code class="language-C++">
XMFLOAT4A v1( { 1.0f, 2.0f, 3.f, 1.0f } );
XMFLOAT4A v2( { 1.0f, 2.0f, 3.f, 1.0f } );
auto v1Loaded = XMLoadFloat4A( &amp;v1 );
auto v2Loaded = XMLoadFloat4A( &amp;v2 );
        
auto v3Loaded = XMVectorAdd(
        XMVectorAdd( 
            XMVectorAdd( 
                v1Loaded,
                v2Loaded ),
            v1Loaded ),
        XMVectorAdd( 
            XMVectorAdd( 
                v2Loaded,
                v1Loaded ),
            v2Loaded ) );

</code></pre>

<p>Benchmarking the above <a href="https://github.com/microsoft/DirectXMath">DirectXMath</a> 
code against</p>

<pre><code class="language-C++">`Vector v3 = ( v1 + v2 ) + ( v1 + v2 ) + ( v1 + v2 );`
</code></pre>

<p>yields:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>----------------------------------------------------------------------------------
Benchmark                                        Time             CPU   Iterations
----------------------------------------------------------------------------------
BenchmarkVector2MultipleAdds                  4.36 ns         3.35 ns    224000000
BenchmarkVector2MultipleXMVectorAdd           4.56 ns         3.77 ns    165925926
</code></pre></div></div>

<p>So, there is rarely any overhead to using the library, compared to working directly
with the SIMD compiler intrinsics.</p>

<p>Ideally, the compiler would generate optimal code for any computations,
and it usually comes close - and when enabled using the <code class="language-plaintext highlighter-rouge">/arch:AVX</code>, <code class="language-plaintext highlighter-rouge">/arch:AVX2</code>, <code class="language-plaintext highlighter-rouge">/arch:AVX512</code>
or <code class="language-plaintext highlighter-rouge">/arch:AVX10.1</code> switches, it will utilize SIMD operations to improve performance. 
This just requires a rebuild of the solution, and will often improve performance significantly.</p>

<p>Note that AVX was introduced with the Sandy Bridge micro architecture back in 2011, 
while AVX2 came later with the Haswell micro architecture in 2012, and AMD added support
for AVX2 in 2015. So it’s generally safe to assume that any modern server, or workstation,
supports AVX2.</p>

<h2 id="vector">Vector</h2>

<p>Vector is a C++ template class that holds a fixed number of elements:</p>

<pre><code class="language-C++">template&lt;typename ValueT, size_t N&gt;
class alignas( Math::Internal::SIMD::Traits&lt;ValueT,N&gt;::AlignAs ) Vector
{
  ...
};
</code></pre>

<p>The template supports the unary <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">-=</code>, <code class="language-plaintext highlighter-rouge">+=</code>, <code class="language-plaintext highlighter-rouge">*=</code>, <code class="language-plaintext highlighter-rouge">/=</code>, 
and <code class="language-plaintext highlighter-rouge">[]</code> operators. The basic mathematical operators are <code class="language-plaintext highlighter-rouge">constexpr</code> implemented,
allowing code to be evaluated at compile time, while using SIMD instructions at
runtime, but <a href="https://eigen.tuxfamily.org">Eigen</a> and <a href="https://arma.sourceforge.net/">Armadillo</a> 
are far better alternatives for general linear algebra.</p>

<h2 id="tuple2-tuple3-and-tuple4">Tuple2, Tuple3 and Tuple4</h2>

<p>The <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> templates implements most of the magic, 
together with the <code class="language-plaintext highlighter-rouge">TupleSimd</code> template, required to provide an efficient
set of classes and templates that can handle linear algebra for games, 
graphic apps, and other apps that work with two and/or three dimensional data.</p>

<p>When working with data in two dimensions, it’s a common convention that the
type holding two dimensional data has two data fields, <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>. Similarly
a type holding three dimensional data is expected to have three data fields
named <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">Tuple2</code> template fills this role for two dimensional data:</p>
<pre><code class="language-C++">template&lt;class DerivedT, typename T&gt;
class Tuple2
{
public:
  ...
    union
    {
        ArrayType values;
        struct
        {
            value_type x, y;
        };
    };
  ...
};
</code></pre>

<p>where <code class="language-plaintext highlighter-rouge">values</code> is a <code class="language-plaintext highlighter-rouge">std::array&lt;value_type,2&gt;</code> sharing the location of
<code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> in memory. Setting <code class="language-plaintext highlighter-rouge">v.values[0] = 0</code> is the same as <code class="language-plaintext highlighter-rouge">v.x = 0</code>.</p>

<p><code class="language-plaintext highlighter-rouge">DerivedT</code> is required to be a class derived from the <code class="language-plaintext highlighter-rouge">Tuple2</code> template,
and <code class="language-plaintext highlighter-rouge">value_type</code> is declared as <code class="language-plaintext highlighter-rouge">using value_type = T;</code>.</p>

<p>Similarly the <code class="language-plaintext highlighter-rouge">Tuple3</code> template fills this role for three dimensional data:</p>

<pre><code class="language-C++">template&lt;class DerivedT, typename T&gt;
class Tuple3
{
public:
  ...
    union
    {
        ArrayType values;
        struct
        {
            value_type x, y, z;
        };
    };
  ...
};
</code></pre>
<p>and here <code class="language-plaintext highlighter-rouge">values</code> is a <code class="language-plaintext highlighter-rouge">std::array&lt;value_type,3&gt;</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Tuple4</code> adds an additional field <code class="language-plaintext highlighter-rouge">w</code>, and uses <code class="language-plaintext highlighter-rouge">std::array&lt;value_type,4&gt;</code>
for the values array.</p>

<p>To use SIMD on the Intel/AMD x64 architecture, data must, as mentioned,
be loaded into a SIMD type that is an abstract representation of an
AVX or SSE4 register. The <code class="language-plaintext highlighter-rouge">TupleSimd</code> template represents SIMD types
using one of the <code class="language-plaintext highlighter-rouge">SIMD::Traits</code> specializations combined with
a tuple type.</p>

<pre><code class="language-C++">template&lt;typename TraitsT, typename TupleT&gt;
class TupleSimd : public Internal::TupleBase
{
  ...    
};
</code></pre>
<p><code class="language-plaintext highlighter-rouge">TupleSimd</code> fills this role for each of the <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> 
template classes.</p>

<h3 id="tuple2-tuple3-and-tuple4-implementation-details">Tuple2, Tuple3 and Tuple4 implementation details</h3>

<p><code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> have similar implementations, following
the same pattern:</p>

<pre><code class="language-C++">template&lt;typename DerivedT, typename T&gt;
class Tuple3 : public Internal::TupleBase
{
</code></pre>

<p><code class="language-plaintext highlighter-rouge">Internal::TupleBase</code> is used as the base class for the 
<code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> enabling the use of <a href="https://en.cppreference.com/w/cpp/types/is_base_of"><code class="language-plaintext highlighter-rouge">std::is_base_of_v&lt;,&gt;</code></a>
to distinguish between types that are derived from <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code>
and those that are not, and this is used to ensure that the templates designed for 
<code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> will only be enabled for classes derived from either of them.</p>

<p>Inside the template definition, <code class="language-plaintext highlighter-rouge">DerivedType</code>, which is a class or struct derived from 
the <code class="language-plaintext highlighter-rouge">Tuple3</code> template, is defined together with <code class="language-plaintext highlighter-rouge">value_type</code> and <code class="language-plaintext highlighter-rouge">size_type</code>.</p>

<pre><code class="language-C++">public:
    using DerivedType = DerivedT;
    using value_type = T;
    using size_type = size_t;
</code></pre>

<p><code class="language-plaintext highlighter-rouge">Tuple3</code> holds three values, <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>, as its main purpose is to 
be a storage for three dimensional coordinates, and <code class="language-plaintext highlighter-rouge">Size</code> specifies the
number of values that <code class="language-plaintext highlighter-rouge">Tuple3</code> holds.</p>

<pre><code class="language-C++">    static constexpr size_type Size = 3;

    using Traits = SIMD::Traits&lt;value_type, Size&gt;;
    using SIMDType = typename Traits::SIMDType;
</code></pre>
<p>Above <code class="language-plaintext highlighter-rouge">Traits</code> is defined for <code class="language-plaintext highlighter-rouge">value_type</code> and <code class="language-plaintext highlighter-rouge">Size</code>, selecting
the <code class="language-plaintext highlighter-rouge">SIMD::Traits</code> specialization that fits the requirements for 
<code class="language-plaintext highlighter-rouge">Tuple3</code>.</p>

<p>Next <code class="language-plaintext highlighter-rouge">ArrayType</code> is defined:</p>

<pre><code class="language-C++">    using ArrayType = typename Traits::ArrayType;
</code></pre>

<p>This is the same as <code class="language-plaintext highlighter-rouge">std::array&lt;value_type,Size&gt;</code>, and while <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>
is the common notation for three dimensional information, <code class="language-plaintext highlighter-rouge">values</code>, 
as defined below, is much more convenient when developing templates 
that will work with <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code>, <code class="language-plaintext highlighter-rouge">Tuple4</code> and any class derived from 
either of them.</p>

<p>The mathematical operations are performed using the <code class="language-plaintext highlighter-rouge">Simd</code> 
type which holds a SIMD vector using the <code class="language-plaintext highlighter-rouge">TupleSimd</code> instantiated
for the <code class="language-plaintext highlighter-rouge">Traits</code> and the class derived from the <code class="language-plaintext highlighter-rouge">Tuple3</code> template,
ensuring that each derived class gets a unique <code class="language-plaintext highlighter-rouge">TupleSimd</code> C++ type.</p>

<pre><code class="language-C++">    using Simd = TupleSimd&lt;Traits, DerivedType&gt;;
</code></pre>
<p>The data fields of <code class="language-plaintext highlighter-rouge">Tuple3</code>:</p>
<pre><code class="language-C++">    union
    {
        ArrayType values;
        struct
        {
            value_type x, y, z;
        };
    };
</code></pre>
<p>The default constructor ensures that <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> are initialized to
<code class="language-plaintext highlighter-rouge">0</code>.</p>

<pre><code class="language-C++">    Tuple3( ) noexcept
            : x{}, y{}, z{}
    { }

    Tuple3( value_type xv, value_type yv, value_type zv ) noexcept
        : x( xv ), y( yv ), z( zv )
    { }

</code></pre>

<p>The next constructor initializes a <code class="language-plaintext highlighter-rouge">Tuple3</code> from a compatible <code class="language-plaintext highlighter-rouge">TupleSimd</code>,
which is any <code class="language-plaintext highlighter-rouge">TupleSimd</code> instantiated for the same <code class="language-plaintext highlighter-rouge">SIMD::Traits</code> specialization
as <code class="language-plaintext highlighter-rouge">Tuple3</code>. <code class="language-plaintext highlighter-rouge">SIMD::Traits</code> has a <code class="language-plaintext highlighter-rouge">ToArray</code> function that stores the values
in the SIMD type in a <code class="language-plaintext highlighter-rouge">std::array&lt;&gt;</code> with the same type as <code class="language-plaintext highlighter-rouge">ArrayType</code> and 
returns the data.</p>

<pre><code class="language-C++">
    template&lt;Internal::SimdType T&gt;
        requires std::is_same_v&lt;Traits, typename T::Traits&gt;
    Tuple3( const T&amp; other ) noexcept
        : values( Traits::ToArray( other.simd ) )
    { }

    template&lt;Internal::SimdType T&gt;
        requires std::is_same_v&lt;Traits, typename T::Traits&gt;
    DerivedType&amp; operator = ( const T&amp; other ) noexcept
    {
        values = Traits::ToArray( other.simd );
        return static_cast&lt; DerivedType&amp; &gt;( *this );
    }

    constexpr bool operator == ( const Tuple3&amp; other ) const noexcept
    {
        return IsSameValue( x, other.x ) &amp;&amp; IsSameValue( y, other.y ) 
                            &amp;&amp; IsSameValue( z, other.z );
    }
    constexpr bool operator != ( const Tuple3&amp; other ) const noexcept
    {
        return !IsSameValue( x, other.x ) || !IsSameValue( y, other.y ) 
                            || !IsSameValue( z, other.z );
    }

</code></pre>
<p>Compare the <code class="language-plaintext highlighter-rouge">Tuple3</code> with a compatible <code class="language-plaintext highlighter-rouge">TupleSimd</code>:</p>

<pre><code class="language-C++">
    template&lt;Internal::SimdType T&gt;
        requires std::is_same_v&lt;Traits, typename T::Traits&gt;
    bool operator == ( const T&amp; other ) const noexcept
    {
        return Traits::Equals( Traits::Load( values.data( ) ), other.simd );
    }

    template&lt;Internal::SimdType T&gt;
        requires std::is_same_v&lt;Traits, typename T::Traits&gt;
    bool operator != ( const T&amp; other ) const noexcept
    {
        return Traits::Equals( Traits::Load( values.data( ) ), other.simd ) == false;
    }

</code></pre>
<p>The only mathematical operation implemented for <code class="language-plaintext highlighter-rouge">Tuple3</code> is negation, note that
the type of the return value is <code class="language-plaintext highlighter-rouge">Simd</code>, the <code class="language-plaintext highlighter-rouge">TupleSimd</code> specialization for
this <code class="language-plaintext highlighter-rouge">Tuple3</code>.</p>

<pre><code class="language-C++">    Simd operator-( ) const noexcept
    {
        return Traits::Negate( Traits::Load( values.data( ) ) );
    }

    void Assign( value_type xv, value_type yv, value_type zv ) noexcept
    {
        x = xv;
        y = yv;
        z = zv;
    }
    void Assign( const ArrayType&amp; src ) noexcept
    {
        values = src;
    }
    void Assign( SIMDType src ) noexcept
    {
        values = Traits::ToArray( src );
    }
</code></pre>

<p>The ability to check for <code class="language-plaintext highlighter-rouge">NaN</code> or infinity should not require use of SIMD registers.</p>

<pre><code class="language-C++">
    bool HasNaN( ) const noexcept
    {
        return std::isnan( x ) || std::isnan( y ) || std::isnan( z );
    }

    bool IsFinite( ) const noexcept
    {
        return std::isfinite( x ) &amp;&amp; std::isfinite( y ) &amp;&amp; std::isfinite( z );
    }

    bool IsInfinite( ) const noexcept
    {
        return std::isinf( x ) || std::isinf( y ) || std::isinf( z );
    }

};
</code></pre>

<p>The library defines two internal concepts. <code class="language-plaintext highlighter-rouge">Internal::TupleType</code> and <code class="language-plaintext highlighter-rouge">Internal::SimdType</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> matches the <code class="language-plaintext highlighter-rouge">Internal::TupleType</code> concept, while
any <code class="language-plaintext highlighter-rouge">TupleSimd</code> derived type matches the <code class="language-plaintext highlighter-rouge">Internal::SimdType</code> concept.</p>

<p>In the code below, <code class="language-plaintext highlighter-rouge">Internal::IsCompatible&lt;T,U&gt;</code> is used to verify that
<code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code> are compatible types using the same <code class="language-plaintext highlighter-rouge">SIMD::Traits</code> specialization.</p>

<p>The first overload will be used when both arguments are compatible <code class="language-plaintext highlighter-rouge">TupleSimd</code>
based objects, so the implementation can perform the addition without
any loading of values into a SIMD datatype.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::SimdType U&gt;
    requires Internal::IsCompatible&lt;T,U&gt;
inline T operator + ( const T&amp; lhs, const U&amp; rhs ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Add( lhs.simd, rhs.simd );
}
</code></pre>

<p>The second overload accepts <code class="language-plaintext highlighter-rouge">TupleSimd</code> for the left hand argument,
and any compatible <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> or <code class="language-plaintext highlighter-rouge">Tuple4</code> as its right hand argument.</p>

<p>The implementation loads the data from the tuple type, before performing
the addition, returning <code class="language-plaintext highlighter-rouge">T</code> which is a <code class="language-plaintext highlighter-rouge">TupleSimd</code> based type.</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T, Internal::TupleType U&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T operator + ( const T&amp; lhs, const U&amp; rhs ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Add( lhs.simd, Traits::Load( rhs.values.data( ) ) );
}
</code></pre>
<p>The third overload accepts the same type of arguments as the second,
but takes a <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> or <code class="language-plaintext highlighter-rouge">Tuple4</code> as its left hand argument,
and <code class="language-plaintext highlighter-rouge">TupleSimd</code> for the right hand argument.</p>

<p>This time the contents of <code class="language-plaintext highlighter-rouge">lhs</code> gets loaded before performing the addition.</p>
<pre><code class="language-C++">template&lt;Internal::TupleType U, Internal::SimdType T&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline T operator + ( const U&amp; lhs, const T&amp; rhs ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Add( Traits::Load( lhs.values.data( ) ), rhs.simd );
}
</code></pre>
<p>The fourth, and last, overload, accepts compatible <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> or <code class="language-plaintext highlighter-rouge">Tuple4</code>
for both the left hand side and the right hand side of the addition, loading data
for both arguments before performing the addition.</p>
<pre><code class="language-C++">template&lt;Internal::TupleType T, Internal::TupleType U, 
                            typename ResultT = typename T::Simd&gt;
    requires Internal::IsCompatible&lt;T, U&gt;
inline ResultT operator + ( const T&amp; lhs, const U&amp; rhs ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Add( Traits::Load( lhs.values.data( ) ), 
                                Traits::Load( rhs.values.data( ) ) );
}

</code></pre>

<p>Loading to and storing from the SIMD types is done using the <code class="language-plaintext highlighter-rouge">values</code> field of
the <code class="language-plaintext highlighter-rouge">Tuple2</code>, <code class="language-plaintext highlighter-rouge">Tuple3</code> and <code class="language-plaintext highlighter-rouge">Tuple4</code> types, so they can all share the same
operator and function implementations:</p>

<pre><code class="language-C++">template&lt;Internal::SimdType T&gt;
inline T Round( const T&amp; t ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Round( t.simd );
}
template&lt;Internal::TupleType T, typename ResultT = typename T::Simd&gt;
inline ResultT Round( const T&amp; t ) noexcept
{
    using Traits = typename T::Traits;
    return Traits::Round( Traits::Load( t.values.data( ) ) );
}

</code></pre>

<p>The operators and functions nearly always return a <code class="language-plaintext highlighter-rouge">TupleSimd</code> based type,
ensuring that data is only loaded into a SIMD type when necessary.</p>

<h3 id="vector2f-vector3f-vector4f-vector2i-vector3i-vector4i">Vector2f, Vector3f, Vector4f, Vector2i, Vector3i, Vector4i</h3>

<p><code class="language-plaintext highlighter-rouge">Vector&lt;float,2&gt;</code>, <code class="language-plaintext highlighter-rouge">Vector&lt;float,3&gt;</code> and <code class="language-plaintext highlighter-rouge">Vector&lt;float,4&gt;</code> are specializations of <code class="language-plaintext highlighter-rouge">Vector&lt;T,N&gt;</code> that 
supports a wider repertoire of operations than the general <code class="language-plaintext highlighter-rouge">Vector&lt;T,N&gt;</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Vector&lt;float,2&gt;</code> is derived from the <code class="language-plaintext highlighter-rouge">Tuple2</code> template, <code class="language-plaintext highlighter-rouge">Vector&lt;float,3&gt;</code> is derived 
from the <code class="language-plaintext highlighter-rouge">Tuple3</code>, and <code class="language-plaintext highlighter-rouge">Vector&lt;float,4&gt;</code> is derived from <code class="language-plaintext highlighter-rouge">Tuple4</code>.</p>

<pre><code class="language-C++">template&lt;typename DerivedT, typename NumberT&gt;
inline Tuple3Simd&lt;Tuple3&lt;DerivedT, NumberT&gt;&gt; 
operator + ( const Tuple3Simd&lt;Tuple3&lt;DerivedT, NumberT&gt;&gt;&amp; lhs, 
            const Tuple3Simd&lt;Tuple3&lt;DerivedT, NumberT&gt;&gt;&amp; rhs )
{
    using Traits = typename Tuple3&lt;DerivedT, NumberT&gt;::Traits;
    return Traits::Add( lhs.simd, rhs.simd );
}
</code></pre>

<p>The next overload is addition between an instantiation of the <code class="language-plaintext highlighter-rouge">Tuple3</code> template class and 
its <code class="language-plaintext highlighter-rouge">Tuple3Simd</code> sibling, calling <code class="language-plaintext highlighter-rouge">SIMD::Traits&lt;float,3&gt;::Load( const float* values )</code>
to load the three 32-bit floating point values held by the <code class="language-plaintext highlighter-rouge">Tuple3</code> based object into
a <code class="language-plaintext highlighter-rouge">__m128</code> before passing the result to <code class="language-plaintext highlighter-rouge">SIMD::Traits&lt;float,3&gt;::Add( SIMDType a, SIMDType b )</code>.</p>

<pre><code class="language-C++">template&lt;typename DerivedT, typename NumberT&gt;
inline Tuple3Simd&lt;Tuple3&lt;DerivedT, NumberT&gt;&gt; 
operator + ( const Tuple3&lt;DerivedT, NumberT&gt;&amp; lhs, 
            const Tuple3Simd&lt;Tuple3&lt;DerivedT, NumberT&gt;&gt;&amp; rhs )
{
    using Traits = typename Tuple3&lt;DerivedT, NumberT&gt;::Traits;
    return Traits::Add( Traits::Load( lhs.values.data( ) ), 
                        rhs.simd );
}
</code></pre>
<p><code class="language-plaintext highlighter-rouge">SIMD::Traits&lt;float,3&gt;::Add( SIMDType a, SIMDType b )</code> returns a <code class="language-plaintext highlighter-rouge">__m128</code>
which gets assigned to the <code class="language-plaintext highlighter-rouge">simd</code> field of the <code class="language-plaintext highlighter-rouge">Tuple3Simd</code> type.</p>

<p>Similarly, the next two overloads loads the data for the <code class="language-plaintext highlighter-rouge">Tuple3</code> arguments into
a <code class="language-plaintext highlighter-rouge">__m128</code>.</p>
<pre><code class="language-C++">template&lt;typename DerivedT, typename NumberT&gt;
inline Tuple3Simd&lt;Tuple3&lt;DerivedT, NumberT&gt;&gt; 
operator + ( const Tuple3Simd&lt;Tuple3&lt;DerivedT, NumberT&gt;&gt;&amp; lhs, 
            const Tuple3&lt;DerivedT, NumberT&gt;&amp; rhs )
{
    using Traits = typename Tuple3&lt;DerivedT, NumberT&gt;::Traits;
    return Traits::Add( lhs.simd, 
                        Traits::Load( rhs.values.data( ) ) );
}
template&lt;typename DerivedT, typename NumberT&gt;
inline Tuple3Simd&lt;Tuple3&lt;DerivedT, NumberT&gt;&gt; 
operator + ( const Tuple3&lt;DerivedT, NumberT&gt;&amp; lhs, 
            const Tuple3&lt;DerivedT, NumberT&gt;&amp; rhs )
{
    using Traits = typename Tuple3&lt;DerivedT, NumberT&gt;::Traits;
    return Traits::Add( Traits::Load( lhs.values.data( ) ), 
                        Traits::Load( rhs.values.data( ) ) );
}
</code></pre>

<p>The four overloads are needed to avoid unnecessary loads and stores 
from the XMM register holding the <code class="language-plaintext highlighter-rouge">__m128</code> while the return type preserves
C++ ability to distinguish between overloads based on the argument types.</p>

<pre><code class="language-C++">using Vector = Math::Vector&lt;float, 3&gt;;

Vector v1( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
Vector v2( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );

Vector result = Dot( Abs( Max( Ceil( -v1 ), Floor( v2 ) ) ), v2 );
</code></pre>
<p>In the above code, the data gets loaded into a <code class="language-plaintext highlighter-rouge">__m128</code> when that is required,
and only stored into a vector object when assigned to <code class="language-plaintext highlighter-rouge">result</code>.</p>

<p>Below are two benchmarks, the first using <code class="language-plaintext highlighter-rouge">Math::Vector&lt;float, 3&gt;</code>, 
while the second uses <code class="language-plaintext highlighter-rouge">pbrt::Vector3f</code>.</p>

<pre><code class="language-C++">static void BenchmarkVector3( benchmark::State&amp; state )
{
    using namespace Harlinn::Common::Core::Math;
    using Vector = Math::Vector&lt;float, 3&gt;;
    DoubleGenerator.Reset( );

    for ( auto _ : state )
    {
        Vector v1( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        Vector v2( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        benchmark::DoNotOptimize( Dot( Abs( Max( Ceil( -v1 ), Floor( v2 ) ) ), v2 ) );
    }
}
BENCHMARK( BenchmarkVector3 );

static void BenchmarkPBRTVector3f( benchmark::State&amp; state )
{
    using namespace pbrt;
    using Vector = pbrt::Vector3f;
    DoubleGenerator.Reset( );


    for ( auto _ : state )
    {
        Vector v1( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        Vector v2( FloatGenerator( ), FloatGenerator( ), FloatGenerator( ) );
        benchmark::DoNotOptimize( Dot( Abs( Max( Ceil( -v1 ), Floor( v2 ) ) ), v2 ) );
    }
}
BENCHMARK( BenchmarkPBRTVector3f );
</code></pre>
<p><code class="language-plaintext highlighter-rouge">BenchmarkVector2</code> runs <code class="language-plaintext highlighter-rouge">20</code> % faster than <code class="language-plaintext highlighter-rouge">BenchmarkPBRTVector3f</code> which is
optimized by the compiler for the AVX2 instruction set:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-------------------------------------------------------------------
Benchmark                         Time             CPU   Iterations
-------------------------------------------------------------------
BenchmarkVector3               5.63 ns         4.85 ns    186666667
BenchmarkPBRTVector3f          7.08 ns         5.86 ns    112000000
</code></pre></div></div>

<p>The following operations are currently supported: <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, unary <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>,
<code class="language-plaintext highlighter-rouge">+=</code>, <code class="language-plaintext highlighter-rouge">-=</code>, <code class="language-plaintext highlighter-rouge">*=</code>, <code class="language-plaintext highlighter-rouge">/=</code>, <code class="language-plaintext highlighter-rouge">Abs</code>, <code class="language-plaintext highlighter-rouge">Min</code>, <code class="language-plaintext highlighter-rouge">Max</code>, <code class="language-plaintext highlighter-rouge">Sqr</code>, <code class="language-plaintext highlighter-rouge">Ceil</code>, <code class="language-plaintext highlighter-rouge">Floor</code>, <code class="language-plaintext highlighter-rouge">Round</code>, 
<code class="language-plaintext highlighter-rouge">Trunc</code>, <code class="language-plaintext highlighter-rouge">Lerp</code>, <code class="language-plaintext highlighter-rouge">Saturate</code>, <code class="language-plaintext highlighter-rouge">Sqrt</code>, <code class="language-plaintext highlighter-rouge">FMA</code>, <code class="language-plaintext highlighter-rouge">FMSub</code>, <code class="language-plaintext highlighter-rouge">Sin</code>, <code class="language-plaintext highlighter-rouge">Cos</code>, <code class="language-plaintext highlighter-rouge">Tan</code>, 
<code class="language-plaintext highlighter-rouge">ASin</code>, <code class="language-plaintext highlighter-rouge">ACos</code>, <code class="language-plaintext highlighter-rouge">ATan</code>, <code class="language-plaintext highlighter-rouge">ATan2</code>, <code class="language-plaintext highlighter-rouge">SinH</code>, <code class="language-plaintext highlighter-rouge">CosH</code>, <code class="language-plaintext highlighter-rouge">TanH</code>, <code class="language-plaintext highlighter-rouge">ASinH</code>, <code class="language-plaintext highlighter-rouge">ACosH</code>, 
<code class="language-plaintext highlighter-rouge">ATanH</code>, <code class="language-plaintext highlighter-rouge">Log</code>, <code class="language-plaintext highlighter-rouge">Log1P</code>, <code class="language-plaintext highlighter-rouge">Log10</code>, <code class="language-plaintext highlighter-rouge">Log2</code>, <code class="language-plaintext highlighter-rouge">Exp</code>, <code class="language-plaintext highlighter-rouge">Exp10</code>, <code class="language-plaintext highlighter-rouge">Exp2</code>, <code class="language-plaintext highlighter-rouge">ExpM1</code>, 
<code class="language-plaintext highlighter-rouge">Pow</code>, <code class="language-plaintext highlighter-rouge">Hypot</code>, and <code class="language-plaintext highlighter-rouge">Permute</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Dot</code> is implemented for the <code class="language-plaintext highlighter-rouge">Vector&lt;float,2&gt;</code>, <code class="language-plaintext highlighter-rouge">Vector&lt;float,3&gt;</code> and 
<code class="language-plaintext highlighter-rouge">Vector&lt;float,4&gt;</code> specializations.</p>

<h4 id="normal3f-and-normal3i">Normal3f and Normal3i</h4>
<h4 id="point3f-and-point3i">Point3f and Point3i</h4>
<h2 id="quaternion">Quaternion</h2>


  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Harlinn</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Harlinn</li><li><a class="u-email" href="mailto:espen@harlinn.no">espen@harlinn.no</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Harlinn"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Harlinn</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is my personal Github site, </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
